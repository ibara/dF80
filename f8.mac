TITLE  FORTRAN-80 Ver. 3.4 Copyright 1978, 79, 80 (C) By Microsoft
SUBTTL Disassembled code Created: 19-Feb-85 in assembly language z80
;
; z80dasm 1.1.3
; command line: ./z80dasm -a -l -t -S f80.sym -s f80.sym1 -o f80.mac -b f80.blocks F80.COM
;
; m80 f8,f8=f8
; l80 l80 f8,f8/n/e
;
;#################
;# START MODULE	 #
;#################
;
FALSE	equ 0
TRUE	equ NOT FALSE

DBG	equ 0
TRACE	equ 0

V3_44	equ FALSE	;; F80 v3.4
;;V3_44 equ TRUE	;; L80 v3.44

	.z80
	aseg
	org 100h

BDOS	equ 0005h   ; CP/M BDOS entry point
TPATOP	equ BDOS+1  ; Top of user TPA (address at 6,7)
CCPbuf	equ 080h

_DRV	equ 1	    ; Number of drive characters
_NAM	equ 8	    ; Number of characters in the name
_EXT	equ 3	    ; Number of characters in the extension

FCBlen	equ 33	    ; Length of FCB
reclng	equ 128
;
;   Number of records
;
SRClen	equ 4	    ; Source buffer
RELlen	equ 2	    ; REL buffer
LSTlen	equ 4	    ; List buffer

CMDLEN	equ 80
;
;   Equates for non graphic characters
;
null	equ 00h
bell	equ 07h
_bell	equ 87h
tab	equ 09h	    ; TAB character
_tab	equ 89h
lf	equ 0ah	    ; Line Feed
_lf	equ 8ah
ff	equ 0ch
_ff	equ 8ch
cr	equ 0dh	    ; Carriage Return
eof	equ 1ah	    ; End Of File mark

NoMSB	equ 01111111b
MSB	equ 10000000b

	jp main ;0100

TopMem: dw 0	;0103	Top of memory
TopDat: dw 0	;0105	Top of data

PosStm: db 0	;0107   Beginning statement
;
;   FORTRAN program line
;			     First character 'C' - Comment Card
l0108h: ds 5	;0108	1-5  Field for statement label(number).
l010dh: db 0	;010d	  6  Continuation character field (any character, except 0)
	ds 66	;010e  7-72  Statement (program code) Field
l0150h: ds 8	;0150 73-80  Field identification codes
;
Column: db 0	;0158
l0159h: db 0	;0159	REL byte
	db 0	;015a
NumSrc: dw 0	;015b	Line number source file
;
StartZ:			;** Start of zeroed area **
DataID: dw 0	;015d
l015fh: dw 0	;015f
;
l0161h: dw 0	;0161
	dw 0	;0163
;
ScopeID:db 0	;0165
BlkDat: db 0	;0166	Flag Block data 1-BLOCK DATA
l0167h: dw 0	;0167
l0169h: dw 0	;0169
;
l016bh: dw 0	;016b
l016dh: dw 0	;016d
l016fh: dw 0	;016f
;
l0171h: dw 0	;0171
l0173h: db 0	;0173
EntryID:dw 0	;0174
l0176h: dw 0	;0176
l0178h: dw 0	;0178
incflg: db 0	;017a
;
IncBuf: ds 28h	;017b	Buffer for include file name
;
l01a3h: db 0	;01a3

l01a4h: dw 0	;01a4	[66c6]
l01a6h: dw 0	;01a6
l01a8h: db 0	;01a8
l01a9h: db 0	;01a9
l01aah: dw 0	;01aa

SegmID: db 0	;01ac	Flag Address mode 0-CSEG, 2-DSEG
DO_Flg: db 0	;01ad	Flag DO Termination

l01aeh: dw 0	;01ae

l01b0h: dw 0	;01b0	[66c6]
l01b2h: dw 0	;01b2

l01b4h: db 0	;01b4
l01b5h: db 0	;01b5
SizeID: db 0	;01b6	Size Variable
l01b7h: db 0	;01b7

l01b8h: dw 0	;01b8
l01bah: dw 0	;01ba
l01bch: dw 0	;01bc

conflg: db 0	;01be	Log device flag [0 is printer]
ErrCnt: dw 0	;01bf	Error counter
l01c1h: db 0	;01c1

l01c2h: dw 0	;01c2
l01c4h: dw 0	;01c4	[fbe6]
DatSiz: dw 0	;01c6	Data size [1]

l01c8h: db 0	;01c8
l01c9h: dw 0	;01c9
l01cbh: db 0	;01cb
l01cch: dw 0	;01cc
inclfl:		;
l01ceh: db 0	;01ce
;
l01cfh: db 0	;01cf	1
l01d0h: db 0	;01d0	2
l01d1h: db 0	;01d1	3
l01d2h: db 0	;01d2	4
l01d3h: db 0	;01d3	5
l01d4h: db 0	;01d4	6
l01d5h: db 0	;01d5	7
l01d6h: db 0	;01d6	8
;
l01d7h: db 0	;01d7	1
l01d8h: db 0	;01d8	2
l01d9h: db 0	;01d9	3
l01dah: db 0	;01da	4
l01dbh: db 0	;01db	5
l01dch: db 0	;01dc	6
l01ddh: db 0	;01dd	7
l01deh: db 0	;01de	8
;
l01dfh: db 0	;01df	1
	db 0	;01e0	2
	db 0	;01e1	3
	db 0	;01e2	4
	db 0	;01e3	5
l01e4h: db 0	;01e4	6
	db 0	;01e5	7
	db 0	;01e6	8
;
l01e7h: db 0	;01e7
l01e8h: db 0	;01e8
TypeID: db 0	;01e9	Type variable (0-Integer, 1-Real, 2-Byte, 3-Double, 4-Integer*4), 7-Array?, 9-?
l01eah: db 0	;01ea
l01ebh: db 0	;01eb
;
; Table type definitions variables
; 0 - INTEGER,INTEGER*2
; 1 - REAL
; 2 - LOGICAL, BYTE
; 3 - DOUBLE PRECISION, REAL*8
; 4 - INTEGER*4
;			Default
tTypDef:db 0	;01ec	1 'A'
	db 0	;01ed	1 'B'
	db 0	;01ee	1 'C'
	db 0	;01ef	1 'D'
	db 0	;01f0	1 'E'
	db 0	;01f1	1 'F'
	db 0	;01f2	1 'G'
	db 0	;01f3	1 'H'
	db 0	;01f4	0 'I'
	db 0	;01f5	0 'J'
	db 0	;01f6	0 'K'
	db 0	;01f7	0 'L'
	db 0	;01f8	0 'M'
	db 0	;01f9	0 'N'
	db 0	;01fa	1 'O'
	db 0	;01fb	1 'P'
	db 0	;01fc	1 'Q'
	db 0	;01fd	1 'R'
	db 0	;01fe	1 'S'
	db 0	;01ff	1 'T'
	db 0	;0200	1 'U'
	db 0	;0201	1 'V'
	db 0	;0202	1 'W'
	db 0	;0203	1 'X'
	db 0	;0204	1 'Y'
	db 0	;0205	1 'Z'
;
l0206h: dw 0	;0206	[FA04]
;
KindID: db 0	;0208	0-?, 1-Constant, 2-Label, 3-Variable, 4-Array, 5-Routine, 6-Common

l0209h: dw 0	;0209	[FA04]
l020bh: db 0	;020b
l020ch: dw 0	;020c
l020eh: dw 0	;020e
l0210h: dw 0	;0210
HeapEnd:dw 0	;0212	[FA04]
l0214h: dw 0	;0214	[66c6]
HeapPtr:dw 0	;0216	[66c6]

l0218h: db 0	;0218
PrgSiz: dw 0	;0219	Program Size
l021bh: dw 0	;021b
l021dh: dw 0	;021d

l021fh: db 0	;021f
l0220h: db 0	;0220
	db 0	;0221
	db 0	;0222
	db 0	;0223
	db 0	;0224
	db 0	;0225
	db 0	;0226
	db 0	;0227

i_Type: db 0	;0228

l0229h: dw 0	;0229	4 and 3 bytes statement l01dbh
l022bh: db 0	;022b	2 byte statement	l01ddh
l022ch: db 0	;022c	1 byte statement

l022dh: db 0	;022d
l022eh: db 0	;022e
l022fh: db 0	;022f
NumDim: db 0	;0230	Number of dimension declarators

MnCode: dw 0	;0231

NumIO:	db 0	;0233	Number of parameters statement READ or WRITE
l0234h: dw 0	;0234

l0236h: dw 0	;0236
l0238h: dw 0	;0238

l023ah: dw 0	;023a
l023ch: dw 0	;023c	[fa66]
l023eh: dw 0	;023e	[fa2c]
l0240h: dw 0	;0240	[fa58]

l0242h: db 0	;0242

l0243h: dw 0	;0243
l0245h: dw 0	;0245
l0247h: dw 0	;0247
l0249h: dw 0	;0249

l024bh: db 0	;024b
l024ch: db 0	;024c
l024dh: db 0	;024d

l024eh: dw 0	;024e
l0250h: dw 0	;0250

SubrFlg:db 0	;0252	Flag Subroutine 1-Subroutine, 0-Function
	db 0	;0253
	db 0	;0254
	db 0	;0255
	db 0	;0256
	db 0	;0257
	db 0	;0258

l0259h: dw 0	;0259
l025bh: dw 0	;025b
l025dh: dw 0	;025d
l025fh: dw 0	;025f

l0261h: db 0	;0261
MainFlg:db 0	;0262	Flag module 0-Main program, 1-Subprogram

l0263h: dw 0	;0263
CurAdr: dw 0	;0265 + Address current program Processing statement
l0267h: dw 0	;0267
l0269h: dw 0	;0269 ?Two-dimensional array
l026bh: db 0	;026b ?Three-dimensional array
l026ch: db 0	;026c ++

l026dh: dw 0	;026d
l026fh: dw 0	;026f ?One-dimensional array
l0271h: dw 0	;0271 ?Two-dimensional array
l0273h: dw 0	;0273 ?Three-dimensional array
l0275h: dw 0	;0275

l0277h: db 0	;0277
l0278h: db 0	;0278
l0279h: db 0	;0279
l027ah: db 0	;027a

l027bh: dw 0	;027b
l027dh: dw 0	;027d
l027fh: dw 0	;027f

l0281h: db 0	;0281

l0282h: dw 0	;0282
l0284h: dw 0	;0284

l0286h: db 0	;0286

l0287h: dw 0	;0287
l0289h: dw 0	;0289
l028bh: dw 0	;028b
tmpvar:
l028dh: dw 0	;028d
l028fh: dw 0	;028f
l0291h: dw 0	;0291
NumArg: dw 0	;0293	Number of arguments to transfer
l0295h: dw 0	;0295

l0297h: db 0	;0297
l0298h: db 0	;0298
l0299h: db 0	;0299

l029ah: dw 0	;029a
l029ch: dw 0	;029c		+0-intefer +1 real +2 byte +3 double ???
l029eh: dw 0	;029e
l02a0h: dw 0	;02a0	[fa36]

l02a2h: db 0	;02a2
l02a3h: db 0	;02a3

l02a4h: dw 0	;02a4
l02a6h: dw 0	;02a6
l02a8h: dw 0	;02a8
l02aah: dw 0	;02aa
WrnCnt: dw 0	;02ac	Warning counter
l02aeh: dw 0	;02ae	[fa4e]
l02b0h: dw 0	;02b0	[fa22]
l02b2h: dw 0	;02b2	[fa40]
EndZ:				    ;** End of Zeroed Area **

l02b4h: db 0	;02b4	1
l02b5h: db 0	;02b5	2
	db 0	;02b6	3
	db 0	;02b7	4
	db 0	;02b8	5
	db 0	;02b9	6
	db 0	;02ba	7
	db 0	;02bb	8
	db 0	;02bc	9
	db 0	;02bd	10
	db 0	;02be	11
	db 0	;02bf	12
	db 0	;02c0	13
	db 0	;02c1	14
	db 0	;02c2	15
	db 0	;02c3	16
	db 0	;02c4	17
	db 0	;02c5	18
	db 0	;02c6	19
l02c7h: db 0	;02c7	20
	db cr	;02c8

l02c9h: db 'ESLAF'	    ;02c9 "FALSE"
l02ceh: db '.EURT'	    ;02ce "TRUE."
l02d3h: db 'ITCNUF'	    ;02d3 "FUNCTI"
l02d9h: db '=RRE'	    ;02d9 "ERR="
l02ddh: db '=DNE'	    ;02dd "END="
l02e1h: db '=CER'	    ;02e1 "REC="
l02e5h: db 'NIAM$'	    ;02e5 "$MAIN"
l02eah: db 'TINI$'	    ;02ea "$INIT"
;
; Type variables
;	   ;- Length string
	   ;	;- String
	   ;	;    ;- ID_Type
	   ;	;    ;
l02efh: db 03h,'YTE',2		       ;02ef "bYTE"
l02f4h: db 06h,'NTEGER',0	       ;02f4 "iNTEGER"
l02fch: db 0eh,'OUBLEPRECISION',3      ;02fc "dOUBLEPRECISION"
l030ch: db 06h,'OGICAL',2	       ;030c "lOGICAL"
l0314h: db 03h,'EAL',1		       ;0314 "rEAL"

NumMod: db 0		    ;0319   Number of compiled program modules
l031ah: dw 0		    ;031a   [fa04]
l031ch: dw 0		    ;031c   [fa66]
l031eh: dw 0		    ;031e   [fc75]

l0320h: db 'FOR',cr	    ;0320
l0324h: dc 'Line: '	    ;0324
;
;   Statement table
;      ;- Statement
       ;      ;- Offset
       ;      ;	   ;- Type statement
       ;      ;	   ;
l032ah:
    db 'ASSI',001h,9	    ;032a   ASSIgn
    dw PrAssign		    ;0330

    db 'BACK',003h,0ah	    ;0332   BACKspace
    dw PrBackspace	    ;0338

    db 'BYTE',000h,1	    ;033a   BYTE
    dw PrByte		    ;0340

    db 'BLOC',008h,0	    ;0342   BLOCkdata
    dw PrBlockdata	    ;0348

    db 'CALL',000h,9	    ;034a   CALL
    dw PrCall		    ;0350

    db 'COMM',00dh,4	    ;0352   COMMon
    dw PrCommon		    ;0358

    db 'CONT',00fh,9	    ;035a   CONTinue
    dw PrContinue	    ;0360

    db 'DATA',000h,6	    ;0362   DATA
    dw PrData		    ;0368

    db 'DIME',013h,1	    ;036a   DIMEnsion
    dw PrDimension	    ;0370

    db 'DOUB',018h,1	    ;0372   DOUBleprecision
    dw PrDouble		    ;0378   trap_ms1 (047b4h) ***

    db 'ENCO',023h,0ah	    ;037a   ENCOde(
    dw PrEncode		    ;0380

    db 'ENDF',026h,0ah	    ;0382   ENDFile
    dw PrBackspace	    ;0388

    db 'EQUI',029h,5	    ;038a   EQUIvalence
    dw PrEquivalence	    ;0390

    db 'EXTE',030h,1	    ;0392   EXTErnal
    dw PrExternal	    ;0398

    db 'DECO',023h,0ah	    ;039a   DECOde(
    dw PrEncode		    ;03a0

    db 'FORM',034h,9	    ;03a2   FORMat
    dw PrFormat		    ;03a8

    db 'FUNC',036h,0	    ;03aa   FUNCtion
    dw PrFunction	    ;03b0

    db 'GOTO',000h,9	    ;03b2   GOTO
    dw PrGoto		    ;03b8

    db 'IF( ',000h,9	    ;03ba   IF(
    dw PrIf		    ;03c0

    db 'INCL',03ah,9	    ;03c2   INCLude
    dw PrInclude	    ;03c8

    db 'IMPL',03dh,1	    ;03ca   IMPLicit
    dw PrImpicit	    ;03d0

    db 'INTE',041h,1	    ;03d2   INTEger
    dw PrIneger		    ;03d8   trap_ms1 (047bah) ***

    db 'LOGI',044h,1	    ;03da   LOGIcal
    dw PrByte		    ;03e0

    db 'PAUS',047h,0ah	    ;03e2   PAUSe
    dw PrPause		    ;03e8

    db 'PROG',048h,0	    ;03ea   PROGram
    dw PrProgram	    ;03f0

    db 'READ',04bh,0ah	    ;03f2   READ(
    dw PrRead		    ;03f8

    db 'RETU',04ch,9	    ;03fa   RETUrn
    dw PrReturn		    ;0400

    db 'REAL',000h,1	    ;0402   REAL
    dw PrReal		    ;0408   trap_ms1 (047b7h) ***

    db 'REWI',04eh,0ah	    ;040a   REWInd
    dw PrBackspace	    ;0410

    db 'STOP',000h,0ah	    ;0412   STOP
    dw PrPause		    ;0418

    db 'SUBR',050h,0	    ;041a   SUBRoutine
    dw PrSubroutine	    ;0420

    db 'WRIT',056h,0ah	    ;0422   WRITe(
    dw PrRead		    ;0428
;
;   Continuation of statements
;
l042ah:
    dc 'GN'		;042a  1    assiGN
    dc 'SPACE'		;042c  2    backSPACE
    dc 'KDATA'		;0431  3    blocKDATA
    dc 'ON'		;0436  4    commON
    dc 'INUE'		;0438  5    contINUE
    dc 'NSION'		;043c  6    dimeNSION
    dc 'LEPRECISION'	;0441  7    doubLEPRECISION
    dc 'DE('		;044c  8    encoDE(, decoDE(
    dc 'ILE'		;044f  9    endfILE
    dc 'VALENCE'	;0452 10    equiVALENCE
    dc 'RNAL'		;0459 11    exteRNAL
    dc 'AT'		;045d 12    formAT
    dc 'TION'		;045f 13    funcTION
    dc 'UDE'		;0463 14    inclUDE
    dc 'ICIT'		;0466 15    implICIT
    dc 'GER'		;046a 16    inteGER
    dc 'CAL'		;046d 17    logiCAL
    dc 'E'		;0470 18    pausE
    dc 'RAM'		;0471 19    progRAM
    dc '('		;0474 20    read(
    dc 'RN'		;0475 21    retuRN
    dc 'ND'		;0477 22    rewiND
    dc 'OUTINE'		;0479 23    subrOUTINE
    dc 'E('		;047f 24    writE(
;
;   Table Arithmetic operators
;
	db '+-*/,)'	;0481
l0487h: db '='		;0487
;
;   Table Logical operations
;
	db '.EG'	;0488	'GE.' 10
	db '.EL'	;048b	'LE.'  9
	db '.EN'	;048e	'NE.'  8
	db '.TL'	;0491	'LT.'  7
	db '.TG'	;0494	'GT.'  6
	db '.QE'	;0497	'EQ.'  5
	db 'ROX'	;049a	'XOR'  4
	db '.RO'	;049d	'OR.'  3
	db 'DNA'	;04a0	'AND'  2
l04a3h: db 'TON'	;04a3	'NOT'  1
;
;	(l0242h) (l01b4h)
;	db   0	  0		0 "+"
l04a6h: db 001h, 00bh	;04a6	1 "-"
	db 003h, 00bh	;04a8	2 "*"
	db 002h, 00ch	;04aa	3 "/"
	db 004h, 00ch	;04ac	4 ","
	db 006h, 00eh	;04ae	5 ")"
	db 00ch, 00fh	;04b0	6 "="
	db 007h, 001h	;04b2	7 "GE."
	db 00dh, 009h	;04b4	8 "LE."
	db 00eh, 009h	;04b6	9 "NE."
	db 00fh, 009h	;04b8  10 "LT."
	db 010h, 009h	;04ba  11 "GT."
	db 011h, 009h	;04bc  12 "EQ."
	db 012h, 009h	;04be  13 "XOR"
	db 008h, 003h	;04c0  14 "OR."
	db 009h, 003h	;04c2  15 "AND"
	db 00ah, 005h	;04c4  16 "NOT"
	db 00bh, 007h	;04c6  17 "**"
	db 005h, 00dh	;04c8  18

;
l04cah: db 000h	    ;04ca   00	.
	db 00bh	    ;04cb   0b	.
	db 00ch	    ;04cc   0c	.
	db 00bh	    ;04cd   0b	.
	db 00ch	    ;04ce   0c	.
	db 00dh	    ;04cf   0d	.
;
l04d0h: db 00eh	    ;04d0   0e	.
	db 001h	    ;04d1   01	.
	db 003h	    ;04d2   03	.
	db 003h	    ;04d3   03	.
	db 005h	    ;04d4   05	.
	db 007h	    ;04d5   07	.
;
l04d6h: db 00fh	    ;04d6   0f	.
	db 009h	    ;04d7   09	.
	db 009h	    ;04d8   09	.
	db 009h	    ;04d9   09	.
	db 009h	    ;04da   09	.
	db 009h	    ;04db   09	.
	db 009h	    ;04dc   09	.
	db 00eh	    ;04dd   0e	.
	db 00dh	    ;04de   0d	.
	db 00fh	    ;04df   0f	.
	db 011h	    ;04e0   11	.
	db 010h	    ;04e1   10	.
	db 012h	    ;04e2   12	.
	db 010h	    ;04e3   10	.
	db 011h	    ;04e4   11	.
	db 012h	    ;04e5   12	.
	db 00dh	    ;04e6   0d	.
	db 00eh	    ;04e7   0e	.
	db 00fh	    ;04e8   0f	.
;*
;*    ENTRY Reg	 A - SIZ (SizeID)
;*	    Reg HL - ADR
s_04e9h:
    add a,6		;04e9
    push af		;04eb \ Save SIZ+6
    push hl		;04ec \
    call ChkMem		;04ed	Test Allocate A bytes of memory
    pop de		;04f0 /			de=ADR
    ld hl,(HeapEnd)	;04f1	hl=(HeapEnd)
    ex de,hl		;04f4	hl=ADR		de=(HeapEnd)
    call subHL_DE	;04f5	hl=ADR-(HeapEnd)
    ld b,h		;04f8
    ld c,l		;04f9	bc=ADR-(HeapEnd)
    pop af		;04fa / Restore SIZ+6
    cpl			;04fb
    ld l,a		;04fc
    ld h,0ffh		;04fd	hl= -(SIZ+6)
    inc hl		;04ff	hl=1-(SIZ+6)
    push de		;0500 \ Save (HeapEnd) ----------------+
    ex de,hl		;0501	hl=(HeapEnd)	de=1-(SIZ+6)   ;
    add hl,de		;0502				       ;
    ld (HeapEnd),hl	;0503	(HeapEnd)=(HeapEnd)-(SIZ+6)+1  ;
    push hl		;0506 \			       -----+  ;
    ld hl,(l0209h)	;0507				    ;  ;
    add hl,de		;050a				    ;  ;
    ld (l0209h),hl	;050b	(l0209h)=(l0209h)+1-(SIZ+6) ;  ;
    pop hl		;050e / hl=(HeapEnd)-(SIZ+6)+1	----+  ;
    pop de		;050f / de=(HeapEnd)   ----------------+
;				bc=ADR-(HeapEnd)
    ld a,b		;0510
    or c		;0511	Test bc
    jp z,l051fh ;-----; ;0512	if ADR-(HeapEnd).eq.0 --> ...
l0515h:		 ;<-; ;
      inc hl	    ; ; ;0515	hl=hl+1
      inc de	    ; ; ;0516	de=de+1
      ld a,(de)	    ; ; ;0517
      ld (hl),a	    ; ; ;0518	(hl)=(de)
      dec bc	    ; ; ;0519	bc=bc-1
      ld a,b	    ; ; ;051a
      or c	    ; ; ;051b
      jp nz,l0515h;-+ ; ;051c	if bc.ne.0 --> ...
l051fh:		;<----+
    ld (l0206h),hl	;051f	(l0206h)=
    ret			;0522
;*
;*  (l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
;*    ENTRY Reg HL -
;*
s_0523h:
    ld (l01d3h),hl	;0523	(l01d3h)=hl
    ld hl,00000h	;0526
    ld (l01d5h),hl	;0529	(l01d5h)=0
    xor a		;052c
    ld (TypeID),a	;052d	(TypeID)=0 (INTEGER)
    inc a		;0530
    ld (KindID),a	;0531	(KindID)=1 (Constant)
    ld a,4		;0534
    ld (SizeID),a	;0536	(SizeID)=4
    jp s_055ah		;0539	--> ...
;*
;*  Processing ASSIGN (ASSIGN label TO int_var)
;*
PrAssign:
    call PrLabel	;053c	Processing label
    ld a,'T'		;053f
    call ch_chr		;0541	Check character (a character for check)
    call g_n_chr	;0544 ?
    ld a,'O'		;0547
    call ch_chr		;0549	Check character (a character for check)
    call s_1472h	;054c	cd 72 14
    call s_2576h	;054f	Processing integer constant with error checking & Test (KindID).ne.1
    ld a,7		;0552	a=7
    call s_1473h	;0554	cd 73 14
    jp l09e4h		;0557	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_055ah:
    ld bc,l0649h		;055a	Point to l0649h
    push bc			;055d \ Save to return					SP=l0649h
    ld hl,(l031ch)		;055e	hl=[fa66]
    ld (l01cch),hl		;0561	(l01cch)=(l031ch)
l0564h:		;<--; <-----;
    call Locate	    ;	    ;	;0564	Locate Symbol in the Symbol table from l01d8h-(SizeID)
    jp z,l05d6h ;---)-----; ;	;0567	if eq.0 (Name found) --> ...
l056ah:	     ;<-----)---; ; ;
    call s_0669h    ;	; ; ;	;056a	Calculate address next Symbol in Symbol stable
		    ;	; ; ;	;	(l01cch)=(l01cch)-(SizeID)-6
    ex de,hl	    ;	; ; ;	;056d					    de=(l01cch) SP=l0649h
    ld hl,(l0206h)  ;	; ; ;	;056e				hl=(l0206h)
    call cmpHL_DE   ;	; ; ;	;0571	Compare HL with DE
    ex de,hl	    ;	; ; ;	;0574				hl=(l01cch) de=(l0206h)
    jp c,l0564h ;---+	; ; ;	;0575	if (l0206h) < (l01cch) --> Locate a symbol in the symbol table
    ld bc,l05b1h	; ; ;	;0578	Point to l05b1h
    push bc		; ; ;	;057b \ Save to return		hl=(l01cch) de=(l0206h) SP=l05b1h->l0649h
    ld a,(l0261h)	; ; ;	;057c
    cp 8		; ; ;	;057f
    ret c	   ;--; ; ; ;	;0581	if (l0261h) < 8		    Return to l05b1h	SP=l0649h
    ld a,(KindID)     ; ; ; ;	;0582
    cp 6	      ; ; ; ;	;0585
    ret z	   ;--; ; ; ;	;0587	if (KindID).eq.6 (Common)   Return to l05b1h
    dec a	      ; ; ; ;	;0588
    ret z	   ;--; ; ; ;	;0589	if (KindID).eq.1 (Constant) Return to l05b1h
    dec a	      ; ; ; ;	;058a
    ret z	   ;--; ; ; ;	;058b	if (KindID).eq.2 (Label)    Return to l05b1h
    ld a,(l0298h)     ; ; ; ;	;058c
    cp '('	      ; ; ; ;	;058f
    ret nz	   ;--; ; ; ;	;0591	if (l0298h).ne.'('	    Return to l05b1h
    ex (sp),hl	      ; ; ; ;	;0592				hl=l05b1h		SP=(l01cch)->l0649h
    ld hl,(l031eh)    ; ; ; ;	;0593
    ld (l01cch),hl    ; ; ; ;	;0596	(l01cch)=(l031eh)
l0599h:	      ;<--;   ; ; ; ;
    call Locate	  ;   ; ; ; ;	;0599	Locate Symbol in the Symbol table from l01d8h-(SizeID)
    jp z,l05d2h ;-)-; ; ; ; ;	;059c	if a.eq.0 (name found) --> ...
    call s_0669h  ; ; ; ; ; ;	;059f	Calculate address next Symbol in Symbol stable
		  ; ; ; ; ; ;		(l01cch)=(l01cch)-(SizeID)-6
    ex de,hl	  ; ; ; ; ; ;	;05a2					    de=(l01cch)
    ld hl,(l031ch); ; ; ; ; ;	;05a3	hl=[fa66]		hl=(l031ch)
    call cmpHL_DE ; ; ; ; ; ;	;05a6	Compare HL with DE
    ex de,hl	  ; ; ; ; ; ;	;05a9				hl=(l01cch) de=(l031ch)
    jp c,l0599h ;-+ ; ; ; ; ;	;05aa	if (l031ch) < (l01cch) --> ...
    pop hl	    ; ; ; ; ;	;05ad /				hl=(l01cch)		SP=l0649h
    ld (l01cch),hl  ; ; ; ; ;	;05ae	(l01cch)=(l01cch) old value
l05b1h:		;<--)-+ ; ; ;
    ld (EntryID),hl ;	; ; ;	;05b1	(EntryID)=
    ld a,(SizeID)   ;	; ; ;	;05b4	a=(SizeID)
    call s_04e9h    ;	; ; ;	;05b7	cd e9 04
    xor a	    ;	; ; ;	;05ba
    ld (ScopeID),a  ;	; ; ;	;05bb	(ScopeID)=0
    ld (SegmID),a   ;	; ; ;	;05be	(SegmID)=0 (CSEG)
    ld h,a	    ;	; ; ;	;05c1
    ld l,a	    ;	; ; ;	;05c2
    ld (DataID),hl  ;	; ; ;	;05c3	(DataID)=0
    call PutAttr    ;	; ; ;	;05c6	Put Attributes in Symbol table
    ld a,(KindID)   ;	; ; ;	;05c9
    cp 5	    ;	; ; ;	;05cc
    ret z	    ;	; ; ;	;05ce	if (KindID).eq.5 (Routine) Return to l0649h
		    ;	; ; ;
    jp l061eh	;---)-; ; ; ;	;05cf	--> ...
		    ; ; ; ; ;
l05d2h:	     ;<-----+ ; ; ; ;
    pop bc	      ; ; ; ;	;05d2 / Balansig SP
    jp l061bh	 ;----)-)-)-)-; ;05d3	--> ...
		      ; ; ; ; ;
l05d6h:	      ;<------)-)-+ ; ;		Symbol found
    ld a,(KindID)     ; ;   ; ; ;05d6
    dec a	      ; ;   ; ; ;05d9
    ld hl,(l01cch)    ; ;   ; ; ;05da
    dec hl	      ; ;   ; ; ;05dd					hl=(l01cch)-1
    ld a,(hl)	      ; ;   ; ; ;05de					Load byte from (l01cch)-1
    jp nz,l05efh ;--; ; ;   ; ; ;05df	if (KindID).ne.1 (Constant) --> ...
    rra		    ; ; ;   ; ; ;05e2
    rra		    ; ; ;   ; ; ;05e3
    rra		    ; ; ;   ; ; ;05e4					Shift 3 bits to the left
    and 00000111b   ; ; ;   ; ; ;05e5					Select 3 low bits
    ld b,a	    ; ; ;   ; ; ;05e7					b=type variable from Symbols table
    ld a,(TypeID)   ; ; ;   ; ; ;05e8					Load value type variable
    cp b	    ; ; ;   ; ; ;05eb					Compare with value from Symbol table
    jp nz,l056ah ;--)-)-+   ; ; ;05ec	if (TypeID).ne.b --> Calculate address next symbol in the Symbols table
l05efh:	      ;<----+ ;	    ; ;
    and 00000111b     ;	    ; ; ;05ef					Select 3 low bits (a=name_id from Symbol table)
    inc hl	      ;	    ; ; ;05f1					hl=(l01cch)
    ld c,a	      ;	    ; ; ;05f2	c=name_id from Symbol table
    ld a,(KindID)     ;	    ; ; ;05f3
    sub 5	      ;	    ; ; ;05f6
    jp z,l060eh	 ;--; ;	    ; ; ;05f8	if (KindID).eq.5 (Routine) --> ...
    dec a	    ; ;	    ; ; ;05fb
    jp nz,l0608h;-; ; ;	    ; ; ;05fc	if (KindID).ne.6 (Common)  --> ...
    ld a,c	  ; ; ;	    ; ; ;05ff					a=name_id from Symbol table
    cp 5	  ; ; ;	    ; ; ;0600
    jp nc,l060eh;-)-; ;	    ; ; ;0602	if name_id from Symbol table >= 5 (Routine) --> ...
    jp l0564h ;---)-)-)-----+ ; ;0605	--> Locate symbol in the symbol table
		  ; ; ;	    ; ;
l0608h:	      ;<--+ ; ;	    ; ;
    ld a,c	    ; ;	    ; ; ;0608					a=name_id from Symbol table
    cp 6	    ; ;	    ; ; ;0609
    jp z,l0564h ;---)-)-----+ ; ;060b	if name_id from Symbol table.eq.6 (Common) --> Search name in Symbols table
l060eh:	     ;<-----+ ;	      ;
    ld a,(KindID)     ;	      ; ;060e					a=(KindID)
    add a,c	      ;	      ; ;0611					a=(KindID)+name_id from Symbol table
    cp 0bh	      ;	      ; ;0612
    jp nz,l061bh ;-;  ;	      ; ;0614	if (KindID)+name_id from Symbol table.ne.0bh --> Skip error message
    call err_msg   ;  ;	      ; ;0617	Warning (2)
    db 2	   ;  ;	      ; ;061a	Block Name = Procedure Name
		   ;  ;	      ;
l061bh:		;<-+<-)-------+
    call s_4647h      ;		;061b	Extract Attributes from the symbol table, entry( l01cch)
l061eh:	     ;<-------+
    cp 3			;061e
    ret nz	  ;---;		;0620	if (KindID).ne.3 (Variable) Return to l0649h
    ld a,(l0261h)     ;		;0621
    cp 8	      ;		;0624
    ret c	  ;---;		;0626	if(l0261h) < 8	  Return to l0649h
    ld hl,(CurAdr)    ;		;0627	hl=Address current program Processing statement
    ld de,PrCall      ;		;062a	de=Address program Processing CALL
    call cmpHL_DE     ;		;062d
    ret z	  ;---;		;0630	if(CurAdr).eq.PrCall Return to l0649h
    ld a,(l01d6h)     ;		;0631
    cp 02ah	      ;		;0634
    ret z	  ;---;		;0636	if(l01d6h).eq.2ah Return to l0649h
    ld a,(l0242h)     ;		;0637
    or a	      ;		;063a
    jp nz,s_0cf8h     ;		;063b	if(l0242h).ne.0 --> ...
    ld a,(l0298h)     ;		;063e
    cp '('	      ;		;0641
    jp nz,s_0cf8h     ;		;0643	if(l0298h).ne.'(' --> ...
    jp s_0a09h	      ;		;0646	--> ...
		      ;
l0649h:		;<----+
    ld hl,(l01cch)		;0649	2a cc 01
    ret				;064c
;*
;*  Locate Symbol in the Symbol table from l01d8h-(SizeID)
;*    ENTRY Reg HL - ADDR
;*    EXIT  Zero set - if the name found in the symbols table
;*
Locate:
    ld a,(hl)		;064d	Load byte from (ADDR)
    and 7fh		;064e	Clear high bit (a=(SIZ))
    ld b,a		;0650	b=(SIZ)
    ld a,(SizeID)	;0651
    cp b		;0654
    ret nz		;0655	if (SizeID).ne.(SIZ) Return
    push af		;0656 \ Save (SizeID)
    cpl			;0657
    ld c,a		;0658
    ld b,0ffh		;0659	bc = -(SizeID)
    ex de,hl		;065b			    de=ADDR
    ld hl,l01d8h	;065c	hl=l01d8h
    add hl,bc		;065f	hl=l01d8h-(SizeID)
    ex de,hl		;0660	hl=ADDR		    de=l01d8h-(SizeID)
    sub 4		;0661
    ld c,a		;0663	c=(SizeID)-4
    add hl,bc		;0664	hl=ADDR-(SizeID)-4
    pop bc		;0665 / b=(SizeID)
    jp cmpstr		;0666	--> Compare strings ^HL:^DE with length in B
;*
;*  Calculate address next symbol in the Symbols table (l01cch)=(l01cch)-(SizeID)-6
;*
s_0669h:

IFT TRACE
;   EX	AF,AF'
;   EXX
;   call ilstrg
;   db	'^s_0669h^',cr,_lf
;   EXX
;   EX	AF,AF'
ENDIF
IFT DBG
;   call ptest1
;   ret
ENDIF

    ld hl,(l01cch)	;0669
    ld a,(hl)		;066c	Load byte from (l01cch)
    and 7fh		;066d	Clear high bit (a=(SizeID))
    cpl			;066f
    sub 5		;0670
    ld c,a		;0672
    ld b,0ffh		;0673
    add hl,bc		;0675
    ld (l01cch),hl	;0676	(l01cch)=(l01cch)-(SizeID)-6
    ret			;0679
;*
;*  Compare strings ^HL:^DE with length in B
;*
cmpstr:
l067ah:		;<--;
      ld a,(de)	    ;	;067a +
      cp (hl)	    ;	;067b +
      ret nz	    ;	;067c + if(de).ne.(hl) Returm
      inc de	    ;	;067d + de=de+1
      inc hl	    ;	;067e + hl=hl+1
      dec b	    ;	;067f + b=b-1
    jp nz,l067ah ;--+	;0680 + if b.ne.0 Compare next letter
    ret			;0683 +
;
;-------------------------------------------------- bred
    ld bc,02f3ah	;0684	01 3a 2f
l_0687h:
      sub 00ah		;0687	d6 0a
      inc b		;0689	04
    jp nc,l_0687h	;068a	d2 87 06
    add a,c		;068d	81
    ld c,a		;068e	4f
    ret			;068f
;---------------------------------------------- end bred
;*
;*  BLOCK DATA [subprogram-name]
;*
PrBlockdata:
    xor a		;0690
    ld (l0173h),a	;0691	(l0173h)=0
    inc a		;0694
    ld (BlkDat),a	;0695	(BlkDat)=1 (Block data)
    ld (l0261h),a	;0698	(l0261h)=1
    jp PrProgram	;069b	--> Processing PROGRAM
;
;
;
main:
    ld hl,0f800h	;069e	hl = -8
    xor a		;06a1	a=0
    ld (l01b7h),a	;06a2	(l01b7h)=0
    ld (l0159h),hl	;06a5	Reset bit count
    ld hl,l06aeh	;06a8	hl=Point to Start F80
    jp l60b5h		;06ab	--> Parse command line
;
; Start F80
; ENTRY Reg HL holds available top of memory
;	Reg B holds number of pages for extra stack (/P option)
;
l06aeh:
    ld (TopMem),hl	;06ae	Save value Top of Memory (TopMem)=[fe05]
    ld sp,hl		;06b1	Set for stack
    ld de,-400		;06b2	Size page extra stack
l06b5h:		 ;<-;
      add hl,de	    ;	;06b5	hl=fe05+fe70=[fe75]
      dec b	    ;	;06b6	b=b-1
    jp nz,l06b5h ;--+	;06b7	if b.ne.0 --> ...
    ld (TopDat),hl	;06ba	Save value Top of data
    ld a,(enaLST)	;06bd	Test list enabled
    or a		;06c0
    jp z,l070ah		;06c1	if(enaLST).eq.0 --> Compile module
    ld hl,l0821h	;06c4	hl='FORTRAN-80...'
    call PrStrg		;06c7	Print string
    ld hl,l06e5h	;06ca	hl='BYTES:'
    call PrStrg		;06cd	Print string
    ld hl,(TopDat)	;06d0	Load value Top of data
    ld de,l66c6h	;06d3	Address of the first byte of the data area
    call subHL_DE	;06d6	hl=hl-de Size data area
    call PrNumb		;06d9	Print number in HL as decimal number
    ld hl,l06eeh	;06dc	hl='Created: 19-Feb-85'
    call PrStrg		;06df	Print string
    jp l070ah		;06e2	--> Compile module
;
l06e5h:
    db	cr,lf,'BYTES:',0a0h  ;06e5
l06eeh:
    db	cr,lf,'Created: 19-Feb-85',cr,8ah
;
;   Compile next module
;
l0704h:
    call p_crlf		;0704	Put cr lf to console
    call p_crlf		;0707	Put cr lf to console
;
;   Compile module
;
l070ah:
    ld hl,(TopMem)	;070a	Load value Top of memory
    ld sp,hl		;070d	Set for stack
    ld hl,00000h	;070e	hl=0
    ld (NumSrc),hl	;0711	(NumSrc)=0 Line number source file = 0
    call s_1b32h	;0714	Clear buffer ^l02b4h length 20
    ld a,(l01b7h)	;0717
    or a		;071a
    call z,s_19c0h	;071b	if (l01b7h).eq.0 call ...
    ld a,(l01b7h)	;071e
    or a		;0721
    jp z,l0739h ;---;	;0722	if (l01b7h).eq.0 --> Initialization before compiling
    ld c,0fh	    ;	;0725	c=15 REL types - END FILE
    call RELITEM    ;	;0727	Give end file
    call w_byte	    ;	;072a	Put byte to REL file from Reg B
    call lclose	    ;	;072d	Close list file
    call oclose	    ;	;0730	Close REL file
    call sclose	    ;	;0733	Close source file
    jp main	    ;	;0736
		    ;
l0739h:		;<--+
;
;   Initialization before compiling
;
    ld hl,StartZ	;0739 + ** Start of zeroed area **
    ld de,EndZ		;073c + ** End of zeroed area **
;
;   Reset variables
;
l073fh:		   ;<-;
      ld (hl),0	      ; ;073f + (hl)=0
      inc hl	      ; ;0741 + hl=hl+1
      call cmpHL_DE   ; ;0742 + Compare HL with DE
    jp nz,l073fh   ;--+ ;0745 + if HL.ne.EndZ --> Initialize next byte
;
    ld hl,NumMod	;0748
    ld a,(hl)		;074b
    or a		;074c	if (NumMod).ne.0 --> hl,(l031ah); goto l0793h
    jp nz,l081bh    ;-- ;074d	(skip initial initializing the symbol table)
		    ;		Increment counter compiled program modules
    inc (hl)	    ;	;0750	(NumMod)=(NumMod)+1
    ld hl,(TopDat)  ;	;0751	Load value Top of Data
    ld (l031eh),hl  ;	;0754	(l031eh)=(TopDat)
    push hl	    ;	;0757 \ Save value (TopDat)	    [FC75]
    ld de,lent2	    ;	;0758	Length data Table Intrinsic functions
    call subHL_DE   ;	;075b	hl=(TopDat)-lent2
    ld (l031ch),hl  ;	;075e	(l031dh)=(TopDat)-lent2	    [fa66]
    inc hl	    ;	;0761	Create a destination address
    ex de,hl	    ;	;0762	 de=(TopDat)-lent2+1	    [FA67]
    ld hl,IntrFun   ;	;0763	 hl=Point to Table Intrinsic functions
    ld bc,lent2	    ;	;0766	 bc=Length data transferred
    call MoveBC	    ;	;0769	Move BC bytes from ^HL to ^DE
    pop hl	    ;	;076c / Restore value (TopDat)	    [FC75]
    ld de,lent2	    ;	;076d	Length data Table Intrinsic functions
    call subHL_DE   ;	;0770	hl=(TopDat)-lent2
    ld de,lent1	    ;	;0773	Length of service data in the symbol table
    call subHL_DE   ;	;0776	hl=(TopDat)-lent2-lent1
    inc hl	    ;	;0779	Create a destination address
    ex de,hl	    ;	;077a	 de=(TopDat)-lent2-lent1+1  [FA05]
    ld hl,l66c6h    ;	;077b	 hl=Point to Table service data in the symbol table
    ld bc,lent1	    ;	;077e	 bc=Length data transferred
    call MoveBC	    ;	;0781	Move BC bytes from ^HL to ^DE
    ld hl,(TopDat)  ;	;0784
    ld de,lent2	    ;	;0787
    call subHL_DE   ;	;078a	hl=(TopDat)-lent2
    ld de,lent1	    ;	;078d
    call subHL_DE   ;	;0790	hl=(TopDat)-lent2-lent1	    [FA04]
l0793h:		;<--+
    ld (l0206h),hl	;0793	(l0206h)= [FA04]
    ld (HeapEnd),hl	;0796	(HeapEnd)=[FA04]
    ld (l0209h),hl	;0799	(l0209h)= [FA04]
    ld (l031ah),hl	;079c	(l031ah)= [FA04]
    ex de,hl		;079f	de=(l031ah)		    [FA04]
    ld hl,offs6		;07a0
    add hl,de		;07a3
    ld (l02aeh),hl	;07a4	(l02aeh)=offs6+(l031ah)	    [FA4E]=4a+fa04
    ld hl,lent1		;07a7
    add hl,de		;07aa
    ld (l023ch),hl	;07ab	(l023ch)=lent1+(l031ah)	    [FA66]=62+fa04
    ld hl,offs2		;07ae
    add hl,de		;07b1
    ld (l02b0h),hl	;07b2	(l02b0h)=offs2+(l031ah)	    [FA22]=1e+fa04
    ld hl,offs3		;07b5
    add hl,de		;07b8
    ld (l023eh),hl	;07b9	(l023eh)=offs3+(l031ah)	    [FA2C]=28+fa04
    ld hl,offs4		;07bc
    add hl,de		;07bf
    ld (l02a0h),hl	;07c0	(l02a0h)=offs4+(l031ah)	    [FA36]=32+fa04
    ld hl,offs5		;07c3
    add hl,de		;07c6
    ld (l02b2h),hl	;07c7	(l02b2h)=offs5+(l031ah)	    [FA40]=3c+fa04
    ld hl,offs7		;07ca
    add hl,de		;07cd
    ld (l0240h),hl	;07ce	(l0240h)=offs7+(l031ah)	    [FA58]=54+fa04
    ld hl,(l031ch)	;07d1	hl=(l031ch)=fa66
    ld de,00180h	;07d4
    add hl,de		;07d7
    ld (l01c4h),hl	;07d8	(l01c4h)=fa66+180=fbe6
    ld hl,l66c6h	;07db
    ld (l01b0h),hl	;07de	(l01b0h)=66c6
    ld (l01a4h),hl	;07e1	(l01a4h)=66c6
    ld (l0214h),hl	;07e4	(l0214h)=66c6
    ld (HeapPtr),hl	;07e7	(HeapPtr)=66c6
    ld hl,00001h	;07ea
    ld (DatSiz),hl	;07ed	(DatSiz)=1
;
;   Define default variable types
;
    ld hl,tTypDef	;07f0	hl=Pointer table type definitions variables
;
;   Define A-H as REAL
;
    ld a,1		;07f3	a=1 (REAL)
    ld b,8		;07f5	b=8
l07f7h:		 ;<-;
      ld (hl),a	    ;	;07f7	(hl)=1
      inc hl	    ;	;07f8	hl=hl+1
      dec b	    ;	;07f9	b=b-1
    jp nz,l07f7h ;--+	;07fa	if b.ne.0 --> ...
;
;   Define I-N as INTEGER
;
    ld c,6		;07fd	c=6
l07ffh:		 ;<-;
      ld (hl),b	    ;	;07ff	(hl)=0 (INTEGER)
      dec c	    ;	;0800	c=c-1
      inc hl	    ;	;0801	hl=hl+1
    jp nz,l07ffh ;--+	;0802	if c.ne.0 --> ...
;
;   Define O-Z as REAL
;
    ld b,0ch		;0805	b=12
l0807h:		 ;<-;
      ld (hl),a	    ;	;0807	(hl)=1 (REAL)
      inc hl	    ;	;0808	hl=hl+1
      dec b	    ;	;0809	b=b-1
    jp nz,l0807h ;--+	;080a	if b.ne.0 --> ...

    jp Firstep		;080d	--> First step of the compilation
;
;--------------------------------
;   Move BC bytes from ^HL to ^DE
;--------------------------------
MoveBC:
l0810h:	       ;<---;
      ld a,(hl)	    ;	;0810
      ld (de),a	    ;	;0811	(de)=(hl)
      inc de	    ;	;0812	de=de+1
      inc hl	    ;	;0813	hl=hl+1
      dec bc	    ;	;0814	bc=bc-1
      ld a,b	    ;	;0815	a=b
      or c	    ;	;0816	if bc.ne.0 move next byte
    jp nz,l0810h ;--+	;0817
    ret			;081a
;
l081bh:
    ld hl,(l031ah)	;081b	2a 1a 03
    jp l0793h		;081e	--> ...
;
l0821h:
    dc	'FORTRAN-80 Ver. 3.4 Copyright 1978, 79, 80 (C) By Microsoft'
;
;+  Move B bytes from ^HL to ^DE
;
s_085ch:
l085ch:	       ;<---;
      ld a,(hl)	    ;	;085c +
      ld (de),a	    ;	;085d + (de)=(hl)
      inc hl	    ;	;085e + hl=hl+1
      inc de	    ;	;085f + de=de+1
      dec b	    ;	;0860 + b=b-1
    jp nz,l085ch ;--+	;0861 + if b.ne.0 Move next byte
    ret			;0864 +
;
;   Processing CALL name or CALL name(par1,par2,...,parn)
;
PrCall:
    call PrName		;0865	Processing name
    call s_0a09h	;0868	cd 09 0a
    ld a,(l0298h)	;086b
    cp '('		;086e
    jp z,l0882h ;---;	;0870	if (l0298h).eq.'(' --> Processing actual parameters
    call s_1472h    ;	;0873	cd 72 14
l0876h:		 ;<-)-;
    ld hl,00000h    ; ; ;0876	hl=0
    ld (CurAdr),hl  ; ; ;0879	(CurAdr)=0
    call s_3169h    ; ; ;087c	cd 69 31
    jp l09e4h	    ; ; ;087f	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
		    ; ;
l0882h:		;<--+ ;		Processing of the actual parameters
    ld hl,00000h      ; ;0882	hl=0
    ld (CurAdr),hl    ; ;0885	(CurAdr)=0
    ld a,0ffh	      ; ;0888	3e ff
    call s_14dbh      ; ;088a	cd db 14
    call s_0e9dh      ; ;088d	cd 9d 0e
    call s_51e9h      ; ;0890	cd e9 51
    jp l0876h	;-----+ ;0893	--> ...
;
;   Creating built-in routine
;     ENTRY reg BC
;
CrBuilt:
    ld hl,l01d6h	;0896
    ld a,c		;0899
    cp 05bh		;089a
    jp c,l08a2h ;---;	;089c	if c < 5bh --> ...
    sub 02ch	    ;	;089f	d6 2c
    ld c,a	    ;	;08a1	4f
l08a2h:	    ;<------+
    ld (hl),'$'		;08a2	(l01d6h)='$'
    dec hl		;08a4
    ld (hl),b		;08a5	(l01d5h)=b
    dec hl		;08a6
    ld (hl),c		;08a7	(l01d4h)=c
    ld a,3		;08a8
    ld (SizeID),a	;08aa	(SizeID)=3
    ld a,5		;08ad
    ld (KindID),a	;08af	(KindID)=5 (Routine)
    ld a,(i_Type)	;08b2
    push af		;08b5 \ Save (i_Type)
    ld hl,(l01cch)	;08b6
    push hl		;08b9 \ Save (l01cch)
    ld a,(l0298h)	;08ba
    push af		;08bd \ Save (l0298h)
    ld a,'('		;08be
    ld (l0298h),a	;08c0	(l0299h)='('
    call s_055ah	;08c3	cd 5a 05
    call s_34c3h	;08c6	cd c3 34
    pop af		;08c9 /
    ld (l0298h),a	;08ca	Restore (l0298h)
    pop hl		;08cd / Restore (l01cch)
    pop af		;08ce /
    ld (i_Type),a	;08cf	Restore (i_Type)
    jp ExtAttr		;08d2	--> Extract Attributes from the symbol table
;
;
;
s_08d5h:
    ld a,(NumDim)	;08d5
    cp 3		;08d8
    ld de,00000h	;08da
    jp nz,l08f5h ;--;	;08dd	if (NumDim).ne.3 {de=0 --> ...}
		    ;
;   Three-dimensional array
		    ;
    push af	    ;	;08e0 \
    ld hl,(l0273h)  ;	;08e1
    ld bc,-8	    ;	;08e4
    add hl,bc	    ;	;08e7	hl=(l0273h)-8
    ld b,(hl)	    ;	;08e8	46
    dec hl	    ;	;08e9	2b
    ld c,(hl)	    ;	;08ea	4e
    dec bc	    ;	;08eb	0b
    ld hl,(l026bh)  ;	;08ec	2a 6b 02
    ex de,hl	    ;	;08ef	eb
    call s_4917h    ;	;08f0	cd 17 49
    ex de,hl	    ;	;08f3	eb
    pop af	    ;	;08f4 /
		    ;
l08f5h:	      ;<----+
    cp 2		;08f5
    jp c,l0911h	 ;--;	;08f7	if (NumDim) < 2 --> ...
		    ;
;   Two-dimensional array
		    ;
    ld hl,(l0271h)  ;	;08fa
    ld bc,-8	    ;	;08fd
    add hl,bc	    ;	;0900	hl=(l0271h)-8
    ld b,(hl)	    ;	;0901	46
    dec hl	    ;	;0902	2b
    ld c,(hl)	    ;	;0903	4e
    dec bc	    ;	;0904	0b
    ex de,hl	    ;	;0905	eb
    add hl,bc	    ;	;0906	09
    ld b,h	    ;	;0907
    ld c,l	    ;	;0908	bc=hl
    ld hl,(l0269h)  ;	;0909	2a 69 02
    ex de,hl	    ;	;090c	eb
    call s_4917h    ;	;090d	cd 17 49
    ex de,hl	    ;	;0910	eb
		    ;
l0911h:	      ;<----+
;
;   One-dimensional array
;
    ld hl,(l026fh)	;0911	2a 6f 02
    ld bc,-8		;0914	0fff8h
    add hl,bc		;0917	09
    ld b,(hl)		;0918	46
    dec hl		;0919	2b
    ld c,(hl)		;091a	4e
    dec bc		;091b	0b
    ex de,hl		;091c	eb
    add hl,bc		;091d	09
    ex de,hl		;091e	eb
    ld a,(l02aah)	;091f
    ld c,a		;0922
    ld b,0		;0923	bc=(l02aah)
    jp s_4917h		;0925	--> ...
;
;+  Test continue processing statement
;
l0928h:
    ld a,(l0298h)	;0928 +
    cp ','		;092b + Test separator
    jp nz,l09e4h	;092d + if ((l0298h).ne.',') --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    ld hl,(CurAdr)	;0930 + Address current program Processing statement
    jp (hl)		;0933 + go to (CurAdr)
;
;+  Compare HL with DE
;     ENTRY Reg HL and DE hold pointer
;     EXIT  Carry set if HL<DE
;	    Zero  set if HL=DE
cmpHL_DE:
    ld a,h		;0934 + Compare HI
    sub d		;0935 +
    ret nz		;0936 + .. exit if .NEQ.
    ld a,l		;0937 + Compare LO
    sub e		;0938 +
    ret			;0939 +
;
;+  (l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
;
s_093ah:
    ld hl,00000h	;093a + hl=0
s_093dh:
    ld (l01cfh),hl	;093d +
    ld (l01d1h),hl	;0940 +
    ld (l01d3h),hl	;0943 +
    ld (l01d5h),hl	;0946 +
    ret			;0949 +
;
;+  Initialization field l01d7h 8-byte character ' '
;
s_094ah:
    ld a,' '		;094a +
s_094ch:
    ld b,8		;094c + b=8 counter
    ld hl,l01d7h	;094e + address of the buffer to hold the string
l0951h:		;<--;
      ld (hl),a	    ;	;0951 + save to buffer
      dec b	    ;	;0952 + b=b-1
      inc hl	    ;	;0953 + hl=hl+1
    jp nz,l0951h ;--+	;0954 + test b.ne.0
    ret			;0957 +
;
;   Processing COMMON /y1/a1 /y2/a2/.../yn/an
;
PrCommon:
    call g_n_chr		;0958 +
    cp '/'			;095b +
    jp z,l09c8h	 ;------------; ;095d + if chr.eq.'/' --> Processing COMMON block storage name
    ld (l0173h),a	      ; ;0960 + (l0173h)=chr
l0963h:		    ;<------; ;
    ld a,1		    ; ; ;0963
    ld (SizeID),a	    ; ; ;0965	(SizeID)=1
    ld a,0a0h		    ; ; ;0968
    ld (l01d6h),a	    ; ; ;096a	(l01d6h)=0a0h
l096dh:		    ;<----; ; ;
    ld a,6		  ; ; ; ;096d	a=6
    ld (KindID),a	  ; ; ; ;096f	(KindID)=6 (Common)
    call s_055ah	  ; ; ; ;0972	cd 5a 05
    ld (l0178h),hl	  ; ; ; ;0975	(l0178h)=
l0978h:		    ;<--; ; ; ;
    call PrName		; ; ; ; ;0978	Processing name (common variable)
    ld a,(ScopeID)	; ; ; ; ;097b
    or a		; ; ; ; ;097e
    jp nz,wrn004 ;--;	; ; ; ; ;097f	if (ScopeID).ne.0 --> Warning (4) COMMON Name Usage
    ld a,(KindID)   ;	; ; ; ; ;0982
    sub 4	    ;	; ; ; ; ;0985
    jp z,l099ah	 ;--)-; ; ; ; ; ;0987	if (KindID).eq.4 (Array) --> ...
    inc a	    ; ; ; ; ; ; ;098a
    jp z,l0992h ;-; ; ; ; ; ; ; ;098b	if (KindID).eq.3 (Variable) --> skip error message
wrn004:	     ;<---)-+ ; ; ; ; ;
    call err_msg  ;   ; ; ; ; ; ;098e	Warning (4)
    db 4	  ;   ; ; ; ; ; ;0991	COMMON Name Usage
l0992h:	    ;<----+   ; ; ; ; ;
    ld a,(l0298h)     ; ; ; ; ; ;0992
    cp '('	      ; ; ; ; ; ;0995
    call z,s_19e8h    ; ; ; ; ; ;0997	if (l0298h).eq.'(' --> Processing subscript an array
l099ah:		;<----+ ; ; ; ;
    call s_5a24h	; ; ; ; ;099a	cd 24 5a
    push hl		; ; ; ; ;099d \ e5
    ld hl,(l0178h)	; ; ; ; ;099e
    ld (EntryID),hl	; ; ; ; ;09a1	(EntryID)=(l0178h)
    dec hl		; ; ; ; ;09a4
    dec hl		; ; ; ; ;09a5	hl=hl-2
    ld d,(hl)		; ; ; ; ;09a6	56
    dec hl		; ; ; ; ;09a7	2b
    ld e,(hl)		; ; ; ; ;09a8	5e
    ex (sp),hl		; ; ; ; ;09a9	e3
    add hl,de		; ; ; ; ;09aa	19
    ex de,hl		; ; ; ; ;09ab	eb
    ld (DataID),hl	; ; ; ; ;09ac	(DataID)=
    pop hl		; ; ; ; ;09af / e1
    ld (hl),e		; ; ; ; ;09b0	73
    inc hl		; ; ; ; ;09b1	23
    ld (hl),d		; ; ; ; ;09b2	72
    ld a,1		; ; ; ; ;09b3	a=1
    ld (ScopeID),a	; ; ; ; ;09b5	(ScopeID)=1
    call PutAttr	; ; ; ; ;09b8	Put Attributes in Symbol table
    ld a,(l0298h)	; ; ; ; ;09bb
    cp ','		; ; ; ; ;09be	Test separator
    jp z,l0978h	  ;-----+ ; ; ; ;09c0	if (l0298h).eq.',' --> Processing next name variable
    cp '/'		  ; ; ; ;09c3
    jp nz,l09e4h	  ; ; ; ;09c5	if (l0298h).ne.'/' --> Clear (l0299h)&(DO_Flg)->Ending parsing statement
			  ; ; ;
;   Processing COMMON block storage name
			  ; ; ;
l09c8h:		     ;<---)-)-+
    call s_1cb5h	  ; ;	;09c8	cd b5 1c
    ld a,'/'		  ; ;	;09cb	a='/'
    call ch_chr		  ; ;	;09cd	Check character (a character for check)
    ld a,(KindID)	  ; ;	;09d0
    or a		  ; ;	;09d3
    jp z,l0963h	    ;-----)-+	;09d4	if (KindID).eq.0 --> ...
    ld hl,l01d6h	  ;	;09d7
    ld a,(hl)		  ;	;09da
    or 080h		  ;	;09db
    ld (hl),a		  ;	;09dd	(l01d6h)=(l01d6h).or.10000000b
    jp l096dh	  ;-------+	;09de	--> ...
;*
;*  Processing CONTINUE
;*
PrContinue:
    call g_n_chr	;09e1 +
;*
;*  Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;*
l09e4h:
    xor a		;09e4 + a=0
    jp l259ch		;09e5 + --> Save (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*  Converting value Integer to Real $AC=FLOAT(HL)
;*
s_09e8h:
    push bc		;09e8
    ld bc,'CA'		;09e9	$CA - Integer to Real
    call CrBuilt	;09ec	Creating built-in routine
    ld a,1		;09ef
    ld (i_Type),a	;09f1	(i_Type)=1 (REAL)
    pop bc		;09f4
    ret			;09f5
;*
l09f6h:
    ld a,'S'		;09f6	$CS
    db 11h    ;--;	;09f8	ld de,0433eh (in the original) trap_ms ***
l09f9h:		 ;
    ld a,'C'	 ;	;09f9	$CC - Integer to Double
    db 11h	 ;	;09fb	ld de,l4b3eh (in the original) trap_ms ***
l09fch:	    ;<---+
    ld a,'K'		;09fc	$CK - Real to Double
    push bc		;09fe
    ld c,a		;09ff
    ld b,'C'		;0a00
    call CrBuilt	;0a02	Creating built-in routine
    ld a,3		;0a05	a=3 (DOUBLE)
    pop bc		;0a07
    ret			;0a08	Return to l2abbh
;
;
;
s_0a09h:
    ld de,PrRead	    ;0a09   Address program processing READ, WRITE
    ld hl,(CurAdr)	    ;0a0c   Address current program Processing statement
    call cmpHL_DE	    ;0a0f
    ret z		    ;0a12   if (CurAdr).eq.PrRead Return
    ld a,(KindID)	    ;0a13
    cp 5		    ;0a16
    ret z		    ;0a18   if (KindID).eq.5 (Routine) Return
    cp 3		    ;0a19
    jp nz,err106    ;---;   ;0a1b   if (KindID).ne.3 (Variable) --> Error (106) Illegal Procedure Name
    ld a,(ScopeID)	;   ;0a1e
    or a		;   ;0a21
    jp z,l0a34h ;--;	;   ;0a22   if (ScopeID).eq.0 --> ...
    cp 3	   ;	;   ;0a25
    jp z,l0a3ch ;--)--; ;   ;0a27   if (ScopeID).eq.3 --> ...
    ld hl,00000h   ;  ; ;   ;0a2a
    ld (DataID),hl ;  ; ;   ;0a2d   (DataID)=0
    ld a,h	   ;  ; ;   ;0a30
    ld (ScopeID),a ;  ; ;   ;0a31   (ScopeID)=0
l0a34h:	      ;<---+  ; ;
    ld hl,(DataID)    ; ;   ;0a34
    ld a,h	      ; ;   ;0a37
    or l	      ; ;   ;0a38
    jp nz,err106 ;-;  ; ;   ;0a39   if (DataID).ne.0 --> Error (106) Illegal Procedure Name
l0a3ch:	      ;<---)--+ ;
    ld a,5	   ;	;   ;0a3c   a=5
    ld (KindID),a  ;	;   ;0a3e   (KindID)=5 (Routine)
    jp PutAttr	   ;	;   ;0a41   --> Put Attributes in Symbol table
err106:	      ;<---+ <--+
    call err_msg	    ;0a44   Error (106)
    db 106		    ;0a47   Illegal Procedure Name
;
;   Processing DATA (DATA list/ul,u2,...,un/,...)
;
PrData:
    ld hl,(PrgSiz)	    ;0a48   Load Program size
    push hl		    ;0a4b \ e5
    ld hl,00001h	    ;0a4c
    ld (l027dh),hl	    ;0a4f   (l027dh)=1
    dec hl		    ;0a52   hl=0
    add hl,sp		    ;0a53   hl=Stack pointer
    ld (l0214h),hl	    ;0a54   (l0214h)=Stack pointer
    ld (l028dh),hl	    ;0a57   (l028dh)=Stack pointer
l0a5ah:		;<--;
    call ChkVar	    ;	    ;0a5a   Check that the name refers to a variables
    ld a,(ScopeID)  ;	    ;0a5d
    dec a	    ;	    ;0a60
    jp z,l0a6fh ;-; ;	    ;0a61   if (ScopeID).eq.1 --> ...
    ld a,(BlkDat) ; ;	    ;0a64   Load Flag Block data
    or a	  ; ;	    ;0a67
    jp z,l0a6fh ;-; ;	    ;0a68   if (BlkDat).eq.0 (not Block data)--> skip error message
    call err_msg  ; ;	    ;0a6b   Warning (9)
    db 9	  ; ;	    ;0a6e   Non-COMMON Variable in BLOCK DATA
l0a6fh:	       ;<-+ ;
    call s_0cf8h    ;	    ;0a6f   cd f8 0c
    ld hl,(l01cch)  ;	    ;0a72   2a cc 01
    call ChkStack   ;	    ;0a75   Check the stack
    push hl	    ;	    ;0a78 \ e5
    xor a	    ;	    ;0a79   a=0
    push af	    ;	    ;0a7a \ f5
    ld a,(l0298h)   ;	    ;0a7b
    cp '('	    ;	    ;0a7e
    jp z,l0a93h ;-; ;	    ;0a80   if (l0298h).eq.'(' --> ...
l0a83h:	     ;<---)-)-;
    ld a,(l0298h) ; ; ;	    ;0a83
    cp ','	  ; ; ;	    ;0a86
    jp z,l0a5ah ;-)-+ ;	    ;0a88   if (l0298h).eq.',' --> ...
    ld a,'/'	  ;   ;	    ;0a8b
    call ch_chr	  ;   ;	    ;0a8d   Check character (a character for check)
    jp l0ab1h	;-)-; ;	    ;0a90   --> ...
		  ; ; ;
l0a93h:	      ;<--+ ; ;
    call DimDecl    ; ;	    ;0a93   Processing Dimension declarators
    ld a,(NumDim)   ; ;	    ;0a96
    ld hl,l022dh    ; ;	    ;0a99
    cp (hl)	    ; ;	    ;0a9c
    jp z,l0aa4h ;-; ; ;	    ;0a9d   if(NumDim).eq.(l022dh) --> skip error message
    call err_msg  ; ; ;	    ;0aa0   Error (136)
    db 136	  ; ; ;	    ;0aa3   Wrong Number of Subscripts
		  ; ; ;
l0aa4h:	      ;<--+ ; ;
    call s_46e9h    ; ;	    ;0aa4   cd e9 46
    pop af	    ; ;	    ;0aa7 / f1
    cpl		    ; ;	    ;0aa8   2f
    push af	    ; ;	    ;0aa9 \ f5
    call s_08d5h    ; ;	    ;0aaa   cd d5 08
    push hl	    ; ;	    ;0aad   e5
    jp l0a83h ;-----)-+	    ;0aae   --> ...
		    ;
l0ab1h:		;<--+
    ld a,1		    ;0ab1
    ld (l0259h),a	    ;0ab3   (l0259h) = 1
l0ab6h:
    ld hl,00001h	    ;0ab6
    ld (l0282h),hl	    ;0ab9   (l0282h) = 1
l0abch:		;<--------;
    call s_093ah	  ; ;0abc   (l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
    call g_n_chr	  ; ;0abf +
    cp 'Z'		  ; ;0ac2 +
    jp z,l0b01h	 ;------; ; ;0ac4 + if chr.eq.'Z' --> Expected single quote & 4 hexadecimal digits
    cp 'X'		; ; ;0ac7 +
    jp z,l0b01h	 ;------; ; ;0ac9 + if chr.eq.'X' --> Expected single quote & 4 hexadecimal digits
    ld hl,l01cbh	; ; ;0acc
    ld (hl),0ffh	; ; ;0acf   (l01cbh) = 0ffh
    cp ''''		; ; ;0ad1   Test single quote
    jp z,l0b6ah	 ;----; ; ; ;0ad3   if chr.eq.'''' --> ...
    ld (l0173h),a     ; ; ; ;0ad6   (l0173h)=chr
    call s_1cb5h      ; ; ; ;0ad9   cd b5 1c
    ld a,(KindID)     ; ; ; ;0adc
    dec a	      ; ; ; ;0adf
    jp nz,err107      ; ; ; ;0ae0   if (KindID).ne.1 (Constant) --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l0242h)     ; ; ; ;0ae3
    cp 2	      ; ; ; ;0ae6
    jp nz,l0b63h ;--; ; ; ; ;0ae8   if (l0242h).ne.2 --> ...
    ld a,(TypeID)   ; ; ; ; ;0aeb
    or a	    ; ; ; ; ;0aee
    jp nz,err107    ; ; ; ; ;0aef   if (TypeID).ne.0 (INTEGER) --> Error (107) Invalid DATA Constant or Repeat Factor
    ld hl,(l01d3h)  ; ; ; ; ;0af2
    ld (l0282h),hl  ; ; ; ; ;0af5   (l0282h)=(l01d3h)
    ld a,h	    ; ; ; ; ;0af8
    or l	    ; ; ; ; ;0af9
    jp nz,l0abch ;--)-)-)-+ ;0afa   if(l0282h).ne.0 --> ...
err107:		    ; ; ;
    call err_msg    ; ; ;   ;0afd + Error (107)
    db 06bh	    ; ; ;   ;0b00 + Invalid DATA Constant or Repeat Factor
		    ; ; ;
l0b01h:	     ;<-----)-;-+
		    ; ;
;   Expected single quote & 4 hexadecimal digits
		    ; ;
    call g_n_chr    ; ;	    ;0b01 +
    cp ''''	    ; ;	    ;0b04 + Test single quote
    jp nz,err107    ; ;	    ;0b06 + if chr.ne.'''' --> Error (107) Invalid DATA Constant or Repeat Factor
    call s_1adeh    ; ;	    ;0b09   cd de 1a
    ld a,8	    ; ;	    ;0b0c   a=8
    jp l0b6fh	;---)-)-;   ;0b0e   --> Save value type definitions variable ...
		    ; ; ;
l0b11h:		    ; ; ;
    ld bc,l0c22h    ; ; ;   ;0b11   point to l0c22h
    push bc	    ; ; ;   ;0b14   save to return
    ld a,(l0281h)   ; ; ;   ;0b15
    cp 3	    ; ; ;   ;0b18
    ret z	    ; ; ;   ;0b1a   if (l0281h).eq.3 return to l0c22h
    ld hl,(l01dbh)  ; ; ;   ;0b1b
    ld a,h	    ; ; ;   ;0b1e
    or l	    ; ; ;   ;0b1f
    ld hl,(l01ddh)  ; ; ;   ;0b20
    or h	    ; ; ;   ;0b23
    or l	    ; ; ;   ;0b24
    jp z,l0b2ch ;-; ; ; ;   ;0b25   if (l01dbh).eq.0.or.(l01ddh).eq.0 --> skip error message
    call err_msg  ; ; ; ;   ;0b28 + Warning (29)
    db 29	  ; ; ; ;   ;0b2b + Hex Constant Overflow
		  ; ; ; ;
l0b2ch:	      ;<--+ ; ; ;
    ld hl,(l01d7h)  ; ; ;   ;0b2c
    ld (l01dbh),hl  ; ; ;   ;0b2f   (l01dbh)=(l01d7h)
    ld hl,(l01d9h)  ; ; ;   ;0b32
    ld (l01ddh),hl  ; ; ;   ;0b35   (l01ddh)=(l01d9h)
    ld a,(l0281h)   ; ; ;   ;0b38
    cp 4	    ; ; ;   ;0b3b
    ret z	    ; ; ;   ;0b3d   if (l0281h).eq.4 return to l0c22h
    dec a	    ; ; ;   ;0b3e
    ret z	    ; ; ;   ;0b3f   if (l0281h).eq.1 return to l0c22h
    ld hl,(l01ddh)  ; ; ;   ;0b40
    ld a,h	    ; ; ;   ;0b43
    or l	    ; ; ;   ;0b44
    jp z,l0b4ch ;-; ; ; ;   ;0b45   if (l01ddh).eq.0 --> skip error message
    call err_msg  ; ; ; ;   ;0b48 + Warning (29)
    db 29	  ; ; ; ;   ;0b4b + Hex Constant Overflow
l0b4ch:	    ;<----+ ; ; ;
    ld a,(l0281h)   ; ; ;   ;0b4c
    ld hl,(l01dbh)  ; ; ;   ;0b4f
    ld (l01ddh),hl  ; ; ;   ;0b52   (l01ddh)=(l01dbh)
    or a	    ; ; ;   ;0b55
    ret z	    ; ; ;   ;0b56   if (l0281h).eq.0 Reurn to l0c22h
    ld a,h	    ; ; ;   ;0b57   7c
    or a	    ; ; ;   ;0b58   b7
    ld a,l	    ; ; ;   ;0b59   7d
    ld (l01deh),a   ; ; ;   ;0b5a   (l01deh)=
    ret z	    ; ; ;   ;0b5d   if h.eq.0	     Return to l0c22h
    call err_msg    ; ; ;   ;0b5e + Warning (29)
    db 29	    ; ; ;   ;0b61 + Hex Constant Overflow
    ret		    ; ; ;   ;0b62 +		     Return to l0c22h
		    ; ; ;
l0b63h:		;<--+ ; ;
    ld a,(l01cbh)     ; ;   ;0b63
    or a	      ; ;   ;0b66
    jp z,l0b72h	  ;-; ; ;   ;0b67   if (l01cbh).eq.0 --> ...
l0b6ah:	      ;<----)-+ ;
    call s_4ab1h    ;	;   ;0b6a   cd b1 4a
    ld a,9	    ;	;   ;0b6d   a=9
l0b6fh:	    ;<------)---+
    ld (TypeID),a   ;	    ;0b6f   (TypeID)= Save value type variable
l0b72h:	  ;<--------+
    ld a,(TypeID)	    ;0b72
    ld (l027fh),a	    ;0b75   (l027fh)=(TypeID)
    call s_4860h	    ;0b78   Move 8 bytes from ^l01cfh to ^l01d7h
    ld hl,l01d7h	    ;0b7b
    ld de,l01dfh	    ;0b7e
    call s_4866h	    ;0b81   Move 8 bytes from ^HL to ^DE
l0b84h:		;<--------;
    ld hl,(l027dh)	  ; ;0b84
    dec hl		  ; ;0b87
    ld (l027dh),hl	  ; ;0b88   (l027dh)=(l027dh)-1
    ld a,h		  ; ;0b8b
    or l		  ; ;0b8c
    jp z,l0c87h		  ; ;0b8d   if (l027dh).eq.0 --> ...
l0b90h:			  ;
    ld a,(l027fh)	  ; ;0b90
    ld hl,l0281h	  ; ;0b93
    cp (hl)		  ; ;0b96
    jp nz,l0ba7h ;--;	  ; ;0b97   if (l027fh).ne.(l0281h) --> ...
    or a	    ;	  ; ;0b9a
    jp nz,l0c22h;-; ;	  ; ;0b9b   if (l027fh).eq.0 --> ...
    ld hl,(l01dbh); ;	  ; ;0b9e
    ld (l01ddh),hl; ;	  ; ;0ba1   (l01ddh)=(l01dbh)
    jp l0c22h	;-; ;	  ; ;0ba4   --> ...
		  ; ;	  ;
l0ba7h:	      ;<--)-+	  ;
    or a	  ;	  ; ;0ba7
    jp nz,l0bb4h;-)-;	  ; ;0ba8   if (l027fh).ne.0 --> ...
    ld a,(hl)	  ; ;	  ; ;0bab
    cp 4	  ; ;	  ; ;0bac
    jp z,l0c22h ;-; ;	  ; ;0bae   if (l0281h).eq.4 --> ...
    ld a,(l027fh) ; ;	  ; ;0bb1
l0bb4h:	      ;<--)-+	  ;
    dec a	  ;	  ; ;0bb4
    jp nz,l0bbeh;-)-;	  ; ;0bb5   if (l027fh).eq.1 --> ...
    ld a,(hl)	  ; ;	  ; ;0bb8
    cp 3	  ; ;	  ; ;0bb9
    jp z,l0c22h ;-; ;	  ; ;0bbb   if (l0281h).eq.3 --> ...
l0bbeh:	      ;<--)-+	  ;
    ld a,(l027fh) ;	  ; ;0bbe
    or a	  ;	  ; ;0bc1
    jp nz,l0be9h;-)-----; ; ;0bc2   if (l027fh).ne.0 --> ...
    ld a,(hl)	  ;	; ; ;0bc5
    cp 2	  ;	; ; ;0bc6
    jp nz,err107  ;	; ; ;0bc8   if (l0281h).ne.2 --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l01dch) ;	; ; ;0bcb
    or a	  ;	; ; ;0bce
    jp z,l0bd6h ;-)-;	; ; ;0bcf   if (l01dch).eq.0 --> ...
    inc a	  ; ;	; ; ;0bd2
    jp nz,err107  ; ;	; ; ;0bd3   if (l01dch).eq.0ffh --> Error (107) Invalid DATA Constant or Repeat Factor
l0bd6h:	      ;<--)-+	; ;
    ld a,(l01dbh) ;	; ; ;0bd6   3a db 01
    jp l0c1fh  ;--)---; ; ; ;0bd9   --> ...
		  ;   ; ; ;
l0bdch:	    ;<----)-; ; ; ;
    xor a	  ; ; ; ; ; ;0bdc   a=0
    or (hl)	  ; ; ; ; ; ;0bdd   b6
    jp z,l0c22h ;-; ; ; ; ; ;0bde   if a.eq.0 --> ...
    cp 4	  ; ; ; ; ; ;0be1
    jp z,l0c22h ;-; ; ; ; ; ;0be3   if a.eq.4 --> ...
    jp l0beeh ;-; ; ; ; ; ; ;0be6   --> ...
		; ; ; ; ; ;
l0be9h:	  ;<----)-)-)-)-+ ;
    cp 2	; ; ; ;	  ; ;0be9
    jp z,l0bdch;)-)-+ ;	  ; ;0beb   if (l027fh).eq.2 --> ...
l0beeh:	     ;<-+ ;   ;	  ;
    sub 8	  ;   ;	  ; ;0bee   d6 08
    jp z,l0b11h	  ;   ;	  ; ;0bf0   ca 11 0b
    dec a	  ;   ;	  ; ;0bf3   3d
    jp nz,err107  ;   ;	  ; ;0bf4   if ne 0 --> Error (107) Invalid DATA Constant or Repeat Factor
    ld a,(l0281h) ;   ;	  ; ;0bf7
    cp 3	  ;   ;	  ; ;0bfa
    jp z,l0c22h ;-;   ;	  ; ;0bfc   if (l0281h).eq.3 --> ...
    ld hl,(l01d7h);   ;	  ; ;0bff
    ld (l01dbh),hl;   ;	  ; ;0c02   (l01dbh)=(l01d7h)
    ld hl,(l01d9h);   ;	  ; ;0c05
    ld (l01ddh),hl;   ;	  ; ;0c08   (l01ddh)=(l01d9h)
    cp 4	  ;   ;	  ; ;0c0b
    jp z,l0c22h ;-;   ;	  ; ;0c0d   if (l0281h).eq.4 --> ...
    dec a	  ;   ;	  ; ;0c10
    jp z,l0c22h ;-;   ;	  ; ;0c11   if (l0281h).eq.1 --> ...
    ld hl,(l01dbh);   ;	  ; ;0c14
    ld (l01ddh),hl;   ;	  ; ;0c17   (l01ddh)=(l01dbh)
    dec a	  ;   ;	  ; ;0c1a
    jp nz,l0c22h;-;   ;	  ; ;0c1b   if (l0281h).ne.2 --> ...
    ld a,l	  ;   ;	  ; ;0c1e   7d
l0c1fh:	     ;<---)---+	  ;
    ld (l01deh),a ;	  ; ;0c1f   (l01deh)=
l0c22h:	  ;<------+	  ;
    ld a,(l0281h)	  ; ;0c22
    cp 4		  ; ;0c25
    jp z,l0c32h	 ;--;	  ; ;0c27   if (l0281h).eq.4 --> ...
    inc a	    ;	  ; ;0c2a   a=a+1
    rlca	    ;	  ; ;0c2b   
    or a	    ;	  ; ;0c2c   for compatibility with z80
    jp po,l0c32h ;--;	  ; ;0c2d   e2 32 0c
    ld a,1	    ;	  ; ;0c30   a=1
l0c32h:		;<--+	  ;
    ld hl,l01e4h	  ; ;0c32   21 e4 01
    call w_NAMe		  ; ;0c35   Put Name from Symbol table to REL file
    ld hl,l01dfh	  ; ;0c38   21 df 01
    call s_4863h	  ; ;0c3b   Move 8 bytes from ^l01dfh to ^l01d7h
    ld hl,(l0282h)	  ; ;0c3e
    dec hl		  ; ;0c41
    ld (l0282h),hl	  ; ;0c42   (l0282h)=(l0282h)-1
    ld a,h		  ; ;0c45
    or l		  ; ;0c46
    jp nz,l0b84h  ;-------+ ;0c47   if (l0282h).ne.0 --> ...
    ld a,(l0298h)	    ;0c4a
    cp ','		    ;0c4d
    jp z,l0ab6h		    ;0c4f   if (l0298h).eq.',' --> ...
    ld hl,(l0214h)	    ;0c52
    ex de,hl		    ;0c55
    ld hl,00000h	    ;0c56
    add hl,sp		    ;0c59
    call cmpHL_DE	    ;0c5a   Compare HL with DE
    jp nz,err108	    ;0c5d + if SP.ne.(l0214h) --> Error (108) Incorrect Number of DATA Constants
    ld hl,(l028dh)	    ;0c60   2a 8d 02
    ld sp,hl		    ;0c63   Set for stack
    ld a,'/'		    ;0c64 +
    call ch_chr		    ;0c66 + Check character (a character for check)
    call g_n_chr	    ;0c69 +
    pop hl		    ;0c6c / e1
    call s_56dbh	    ;0c6d   cd db 56
    xor a		    ;0c70
    ld (l0259h),a	    ;0c71   (l0259h)=0
    ld a,(l0298h)	    ;0c74
    cp cr		    ;0c77 +
    jp z,l09e4h		    ;0c79 + if (l0298h).eq.cr --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    cp ','		    ;0c7c   Test separator
    jp z,PrData		    ;0c7e   if (l0298h).eq.',' --> Processing DATA
    ld (l0173h),a	    ;0c81   (l0173h)=(l0298h)
    jp PrData		    ;0c84   --> Processing DATA
;
l0c87h:
    ld hl,00000h	;0c87	hl=0
    add hl,sp		;0c8a	hl=Stack pointer
    ex de,hl		;0c8b	eb
    ld hl,(l0214h)	;0c8c	2a 14 02
    dec hl		;0c8f	2b
    call cmpHL_DE	;0c90	Compare HL with DE
    jp nc,l0c9ah ;--;	;0c93	if (l0214h)-1 >= SP --> Skip error message
err108:		    ;
    call err_msg    ;	;0c96 + Error (108)
    db 108	    ;	;0c99 + Incorrect Number of DATA Constants
		    ;
l0c9ah:		;<--+
    ld d,(hl)		;0c9a	56
    dec hl		;0c9b	2b
    ld e,(hl)		;0c9c	5e
    dec hl		;0c9d	2b
    push hl		;0c9e \ e5
    ex de,hl		;0c9f	eb
    call ExtAttr	;0ca0	Extract Attributes from the symbol table
    call s_5a24h	;0ca3	cd 24 5a
    pop hl		;0ca6 / e1
    ld a,(hl)		;0ca7	7e
    dec hl		;0ca8	2b
    or a		;0ca9	b7
    jp p,l0cbdh ;---;	;0caa	f2 bd 0c
    dec hl	    ;	;0cad	2b
    ld d,(hl)	    ;	;0cae	56
    dec hl	    ;	;0caf	2b
    ld e,(hl)	    ;	;0cb0	5e
    push hl	    ;	;0cb1 \ e5
    ld hl,(DataID)  ;	;0cb2	2a 5d 01
    add hl,de	    ;	;0cb5	19
    ld (DataID),hl  ;	;0cb6	(DataID)=(DataID)+de
    ld de,00001h    ;	;0cb9	de=1
    pop hl	    ;	;0cbc / e1
l0cbdh:	       ;<---+
    ld (l0214h),hl	;0cbd	(l0214h)=
    ex de,hl		;0cc0	eb
    ld (l027dh),hl	;0cc1	(l027dh)=
    ld a,(TypeID)	;0cc4
    ld (l0281h),a	;0cc7	(l0281h)=(TypeID)
    ld hl,(DataID)	;0cca	2a 5d 01
    ld bc,020bh		;0ccd	Address modes DSEG (2), REL type - Set loading location counter (11)
    ld a,(ScopeID)	;0cd0
    dec a		;0cd3
    jp nz,l0cdfh ;--;	;0cd4	if (ScopeID).ne.1 --> ...
    push hl	    ;	;0cd7 \
    call s_5623h    ;	;0cd8	cd 23 56
    pop hl	    ;	;0cdb /
    ld bc,030bh	    ;	;0cdc	Address modes COMMON (3), REL type - Set loading location counter (11)
l0cdfh:	       ;<---+
    call s_56deh	;0cdf	cd de 56
    ld a,(NoCode)	;0ce2
    or a		;0ce5	test /N
    jp nz,l0b90h	;0ce6	if (NoCode).ne.0 skip output --> ...
    call s_4f46h	;0ce9	if (Column).ne.0 Put cr lf to console
    call s_1465h	;0cec	Print *****
    call s_461bh	;0cef	cd 1b 46
    call puttab		;0cf2	Put tab to console
    jp l0b90h		;0cf5	--> ...
;*
;*
;*
s_0cf8h:
    ld a,(ScopeID)	;0cf8
    or a		;0cfb
    ret nz		;0cfc	if(ScopeID).ne.0 Return
s_0cfdh:
    call s_5a24h	;0cfd	cd 24 5a
    ld a,2		;0d00 +
    ld (ScopeID),a	;0d02 + (ScopeID)=2
    ex de,hl		;0d05	eb
    ld hl,(DatSiz)	;0d06
    ld (DataID),hl	;0d09	(DataID)=(DatSiz)
    add hl,de		;0d0c	19
    ld (DatSiz),hl	;0d0d	(DatSiz)= Save Data size
    jp PutAttr		;0d10	--> Put Attributes in Symbol table
;*
;*  Signed divide DE/HL-->DE,HL
;*
;?			     !! No execution path to here !!
    ld a,d		;0d13	7a
    or a		;0d14	b7
    ld b,d		;0d15	42
    call m,s_0d64h	;0d16	Make >0 if less
    ld a,h		;0d19
    xor b		;0d1a
    ld b,a		;0d1b	Set common sign
    ld a,h		;0d1c	Test zero result
    or l		;0d1d
    ret z		;0d1e	if(hl.eq.0) Return
    ld a,h		;0d1f	else
    or a		;0d20
    ex de,hl		;0d21
    call m,s_0d64h	;0d22
    push bc		;0d25 \
    call s_0d30h	;0d26	Divide
    pop af		;0d29 /
    or a		;0d2a
    call m,s_0d64h	;0d2b	Make >0
    ex de,hl		;0d2e
    ret			;0d2f
;*
;*  Unsigned divide DE/HL-->DE,HL
;*
s_0d30h:
    ld a,h		;0d30	Get two's divisor complement
    cpl			;0d31
    ld b,a		;0d32
    ld a,l		;0d33
    cpl			;0d34
    ld c,a		;0d35
    inc bc		;0d36	Build two's divisor complement
    ld hl,00000h	;0d37	Init result
    ld a,011h		;0d3a	Set bit length
    push af		;0d3c \
    or a		;0d3d
    jp l0d4bh	;---;	;0d3e
		    ;
l0d41h:	     ;<-----)-;
    push af	    ; ; ;0d41 \
    push hl	    ; ; ;0d42 \
    add hl,bc	    ; ; ;0d43	Add divisor
    jp nc,l0d4ah;-; ; ; ;0d44	Check bit	    trap_ms (l0d4ah) ***
    pop af	  ; ; ; ;0d47 /
    scf		  ; ; ; ;0d48
    db 3eh	  ; ; ; ;0d49	ld a,0e1h (in the original)  trap_ms ***
l0d4ah:	     ;<---+ ; ;
    pop hl	    ; ; ;0d4a /
l0d4bh:		;<--+ ;
    ld a,e	      ; ;0d4b	Shift left 32 bit
    rla		      ; ;0d4c
    ld e,a	      ; ;0d4d
    ld a,d	      ; ;0d4e
    rla		      ; ;0d4f
    ld d,a	      ; ;0d50
    ld a,l	      ; ;0d51
    rla		      ; ;0d52
    ld l,a	      ; ;0d53
    ld a,h	      ; ;0d54
    rla		      ; ;0d55
    ld h,a	      ; ;0d56
    pop af	      ; ;0d57 /
    dec a	      ; ;0d58	Test end
    jp nz,l0d41h ;----+ ;0d59
    ld a,h		;0d5c	Fix remainder
    or a		;0d5d
    rra			;0d5e
    ld h,a		;0d5f
    ld a,l		;0d60
    rra			;0d61
    ld l,a		;0d62
    ret			;0d63
;*
;*  Make number greater 0, DE=-DE
;*
s_0d64h:
    xor a		;0d64 + Clear entry
    ld c,a		;0d65 +
    sub e		;0d66 + Calculate 0-DE
    ld e,a		;0d67 +
    ld a,c		;0d68 +
    sbc a,d		;0d69 +
    ld d,a		;0d6a +
    ret			;0d6b +
;*
;*  Processing DIMENSION (DIMENSION name(iconst1,iconst2,iconst3))
;*
PrDimension:
    call PrName		;0d6c	Processing name
    call s_19e8h	;0d6f	Processing subscript an array
    jp l0928h		;0d72	--> Test continue processing statement
;*
;*  Processing DO loop parameters m1,m2,m3
;*    ENTRY Reg HL -
;*
s_0d75h:
    ld (l01b2h),hl	;0d75	(l01b2h)=
    ld hl,(l01cch)	;0d78
    ld (l01aeh),hl	;0d7b	(l01aeh)=(l01cch)
    call s_257ch	;0d7e	Processing integer constant (m1-initial Value)
    ld (l01aah),hl	;0d81	(l01aah)=
    call ChComma	;0d84	Check ','
    call s_257ch	;0d87	Processing integer constant (m2-final Value)
    ld (l01a6h),hl	;0d8a	(l01a6h)=
    ld hl,(l023eh)	;0d8d
    ld (l01cch),hl	;0d90	(l01cch)=(l023eh)
    ld a,(l0298h)	;0d93
    cp ','		;0d96	if (l0298h).eq.','
    call z,s_257ch	;0d98	  Processing integer constant (m3-optional Increment)
    ld hl,(l01cch)	;0d9b
    ld (l01a8h),hl	;0d9e	(l01a8h)=(l01cch)
    jp l0e41h		;0da1	--> ...
;
;
;
s_0da4h:
    call s_4788h	;0da4	cd 88 47
    ld hl,(l01aeh)	;0da7
    push hl		;0daa \ Save (l01aeh)
    call ExtAttr	;0dab	Extract Attributes from the symbol table
    ld a,(TypeID)	;0dae
    push af		;0db1 \ Save (TypeID)
    ld hl,(l01aah)	;0db2	hl=(l01aah)
    call ExtAttr	;0db5	Extract Attributes from the symbol table
    ld a,(TypeID)	;0db8
    or a		;0dbb
    jp z,l0dd0h	 ;----; ;0dbc	if (TypeID).eq.0 (INTEGER) --> ...
    pop af	      ; ;0dbf / Restore (TypeID)
    or a	      ; ;0dc0
    jp nz,l0dd1h ;--; ; ;0dc1	if (TypeID).ne.0 (INTEGER) --> ...
    call s_2dech    ; ; ;0dc4	cd ec 2d
    call s_25a5h    ; ; ;0dc7	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ; ; ;0dca	(i_Type)=0 (INTEGER)
    jp l0dd7h	;-; ; ; ;0dcd	--> ...
		  ; ; ;
l0dd0h:	     ;<---)-)-+
    pop af	  ; ;	;0dd0 / Restore (TypeID)
l0dd1h:	       ;<-)-+
    ld (TypeID),a ;	;0dd1	(TypeID)= Save value type variable
    call s_2dech  ;	;0dd4	cd ec 2d
l0dd7h:	      ;<--+
    ld hl,(PrgSiz)	;0dd7
    ld (l01aah),hl	;0dda	(l01aah)=(PrgSiz)
    pop hl		;0ddd / Restore (l01aeh)
    call ExtAttr	;0dde	Extract Attributes from the symbol table
    ld a,7		;0de1	a=7
    call s_294ah	;0de3	cd 4a 29
    jp s_55fdh		;0de6	--> ...
;
;   Parse DO statement (DO label i = m1,m2,m3)
;
l0de9h:
    ld a,2		;0de9	a=2
    call GetStr		;0deb	Reading string length 2 characters
    ld de,0444fh	;0dee	de="DO"
    ld hl,(l01ddh)	;0df1	2a dd 01
    call cmpHL_DE	;0df4	Compare HL with DE
    jp nz,err126	;0df7	if HL.ne DE --> Error (126) Illegal Character for Syntax
    ld a,0ah		;0dfa	a=0ah
    call s_5012h	;0dfc	cd 12 50
    call s_218ch	;0dff	Processing label & Test (TypeID).eq.INTEGER
    ld a,(ScopeID)	;0e02
    or a		;0e05
    jp z,l0e0dh ;---;	;0e06	if (ScopeID).eq.0 --> skip error message
    call err_msg    ;	;0e09 + Error (124)
    db 124	    ;	;0e0c + Backwards DO reference
l0e0dh:		;<--+
    ld hl,(l01cch)	;0e0d
    push hl		;0e10 \ Save (l01cch)
    inc a		;0e11
    ld (l0173h),a	;0e12	(l0173h)=(ScopeID)+1
    call s_2569h	;0e15	Processing integer constant & Test (KindID).ne.1
    ld a,'='		;0e18
    call ch_chr		;0e1a	Check character (a character for check)
    pop hl		;0e1d / Restore (l01cch)
    call s_0d75h	;0e1e	Processing DO loop parameters m1,m2, m3
    call s_0da4h	;0e21	Code generation DO statement
    jp l1b3fh		;0e24	--> Clear (l0299h) Set (DO_Flg) -> Ending parsing statement
;
;
;
s_0e27h:
    ld hl,(DataID)	;0e27
    ld a,h		;0e2a
    or l		;0e2b
    jp z,l0e39h ;---;	;0e2c	if (DataID).eq.0 --> ...
    ld a,(TypeID)   ;	;0e2f
    or a	    ;	;0e32
    ret nz	    ;	;0e33	if (TypeID).ne.0 (INTEGER) Return
    call err_msg    ;	;0e34 + Warning (19)
    db 19	    ;	;0e37 + Statement Number Not FORMAT
    ret		    ;	;0e38 +
;		    ;
l0e39h:		;<--+
    ld a,1		;0e39	a=1
    ld (TypeID),a	;0e3b	(TypeID)=1 (REAL)
    jp PutAttr		;0e3e	--> Put Attributes in Symbol table
;
l0e41h:
    ld a,0ah		;0e41	a=10
    call ChkMem		;0e43	Test Allocate A bytes of memory
    ld hl,(HeapPtr)	;0e46				    hl=(HeapPtr)
    ex de,hl		;0e49						 de=(HeapPtr)
    ld hl,(l01a4h)	;0e4a				    hl=(l01a4h)
    ld (l01b0h),hl	;0e4d	(l01b0h)=(l01a4h)
    call subHL_DE	;0e50	hl=hl-de=(l01a4h)-(HeapPtr)
    ld b,h		;0e53
    ld c,l		;0e54	bc=hl			    bc=(l01a4h)-(HeapPtr)
    push de		;0e55 \ Save de=(HeapPtr) -------+
    ld hl,0000ah	;0e56	hl=10			 ;
    push hl		;0e59 \ Save hl=10 ------------+ ;
    add hl,de		;0e5a			       ; ;  hl=(HeapPtr)+10
    ld (HeapPtr),hl	;0e5b	(HeapPtr)=(HeapPtr)+10 ; ;  hl=(HeapPtr)
    pop de		;0e5e /		   ------------+ ;		 de=10
    push hl		;0e5f \ Save (HeapPtr)	  -----+ ;
    ld hl,(l0214h)	;0e60			       ; ;  hl=(l0214h)
    add hl,de		;0e63			       ; ;  hl=(l0214h)+10
    ld (l0214h),hl	;0e64	(l0214h)=(l0214h)+10   ; ;
    pop hl		;0e67 / -----------------------+ ;  hl=(HeapPtr)+10
    pop de		;0e68 / -------------------------+  de=(HeapPtr)
    jp z,l0e7ah	  ;---; ;0e69	if (l01a4h)-(HeapPtr).eq.0 --> ...
    dec hl	      ; ;0e6c	hl=(HeapPtr)+9
    dec de	      ; ;0e6d	de=(HeapPtr)-1
l0e6eh:		;<--; ;		bc=(l01a4h)-(HeapPtr)
      ld a,(de)	    ; ; ;0e6e
      ld (hl),a	    ; ; ;0e6f	(hl)=(de)
      dec hl	    ; ; ;0e70	hl=hl-1
      dec de	    ; ; ;0e71	de=de-1
      inc bc	    ; ; ;0e72	bc=bc+1
      ld a,b	    ; ; ;0e73
      or c	    ; ; ;0e74	Test bc
    jp nz,l0e6eh ;--+ ; ;0e75	if bc.ne.0 --> ...
    ex de,hl	      ; ;0e78	eb
    inc hl	      ; ;0e79	hl=hl-1
l0e7ah:		  ;<--+
    ld (l01a4h),hl	;0e7a	(l01a4h)=
    jp s_55fdh		;0e7d	--> ...
;
;
;
s_0e80h:
    ld a,4		;0e80	a=4
    call ChkMem		;0e82	Test Allocate A bytes of memory
    ld hl,(HeapPtr)	;0e85
    ld (l0214h),hl	;0e88	(l0214h)=(HeapPtr)
    xor a		;0e8b	a=0
    ld (hl),a		;0e8c	77
    inc hl		;0e8d	23
    ld (hl),a		;0e8e	77
    ex de,hl		;0e8f	eb
    ld hl,(l0243h)	;0e90	2a 43 02
    ex de,hl		;0e93	eb
    inc hl		;0e94	23
    ld (hl),e		;0e95	73
    inc hl		;0e96	23
    ld (hl),d		;0e97	72
    inc hl		;0e98	23
    ld (HeapPtr),hl	;0e99	(HeapPtr)=(HeapPtr)+4
    ret			;0e9c
;*
;*
;*
s_0e9dh:
    ld a,4		    ;0e9d   a=4
    call ChkMem		    ;0e9f   Test Allocate A bytes of memory
    ld hl,(HeapPtr)	    ;0ea2
    ld (l0214h),hl	    ;0ea5   (l0214h)=(HeapPtr)
    inc hl		    ;0ea8
    inc hl		    ;0ea9
    inc hl		    ;0eaa
    inc hl		    ;0eab
    ld (HeapPtr),hl	    ;0eac   (HeapPtr)=(HeapPtr)+4
    call s_5643h	    ;0eaf   cd 43 56
    xor a		    ;0eb2   a=0
    ld (l022eh),a	    ;0eb3   (l022eh)=0
    ret			    ;0eb6
;*
;*  Processing ENCODE(, DECODE(
;*	(DECODE(a,label) k)
;*
PrEncode:
    call s_1ca9h	    ;0eb7   cd a9 1c
    cp 4		    ;0eba
    jp z,l21aeh		    ;0ebc   if (KindID).eq.4 (Array)--> ...
    call err_msg	    ;0ebf   Warning (32)
    db 32		    ;0ec2   Array Name Expected
    jp l21aeh		    ;0ec3   --> ...
;*
;*
;*
s_0ec6h:
    ld a,(l01e7h)		;0ec6
    dec a			;0ec9
    jp z,l110dh			;0eca	if (l01e7h).eq.1 --> ...
l0ecdh:
    ld hl,(l0234h)		;0ecd
    ex de,hl			;0ed0
    ld hl,(l0206h)		;0ed1
    call subHL_DE		;0ed4	hl=(l0206h)-(l0234h)
    ex de,hl			;0ed7
    ld hl,(HeapEnd)		;0ed8
    inc hl			;0edb
    inc hl			;0edc
    inc hl			;0edd
    inc hl			;0ede	hl=(HeapEnd)+4
    call cmpHL_DE		;0edf
    jp nz,l105ch		;0ee2	if ((HeapEnd)+4).ne.((l0206h)-(l0234h)) --> ...
    ld a,(hl)			;0ee5	7e
    and 01fh			;0ee6	00011111b
    cp 013h			;0ee8
    jp nz,l0efch ;--;		;0eea	if a.ne.13h  --> ...
    xor a	    ;		;0eed
    ld (l02a2h),a   ;		;0eee	(l02a2h)=0
    ld hl,(l0234h)  ;		;0ef1
    ld (l01cch),hl  ;		;0ef4	(l01cch)=(l0234h)
    ld a,017h	    ;		;0ef7	a=017h
    call s_1473h    ;		;0ef9	cd 73 14
l0efch:		;<--+
    ld hl,(l0236h)		;0efc
    ld (l01cch),hl		;0eff	(l01cch)=(l0236h)
    xor a			;0f02
    ld (l02a2h),a		;0f03	(l02a2h)=0
    ld a,(l0242h)		;0f06
    sub 6			;0f09
    jp z,l0f73h	   ;----;	;0f0b	if(l0242h).eq.6 --> ...
    dec a		;	;0f0e
    jp z,l0f73h	   ;----;	;0f0f	if(l0242h).eq.7 --> ...
l0f12h:	      ;<--------)---;
    ld a,(l0242h)	;   ;	;0f12	a=(l0242h)
    ld hl,(l0236h)	;   ;	;0f15
    ld (l01cch),hl	;   ;	;0f18	(l01cch)=(l0236h)
    call s_1473h	;   ;	;0f1b	cd 73 14
    ld a,(l0242h)	;   ;	;0f1e
    cp 6		;   ;	;0f21
    jp nc,l0f53h  ;-----)-; ;	;0f23	if(l0242h) >= 6 --> ...
l0f26h:	     ;<---------)-)-)-;
    ld a,(l01ebh)	; ; ; ; ;0f26
    ld (l01eah),a	; ; ; ; ;0f29	(l01eah)=(l01ebh)
l0f2ch:	      ;<------; ; ; ; ;
    ld hl,(HeapEnd)   ; ; ; ; ; ;0f2c
    inc hl	      ; ; ; ; ; ;0f2f
    inc hl	      ; ; ; ; ; ;0f30
    inc hl	      ; ; ; ; ; ;0f31
    inc hl	      ; ; ; ; ; ;0f32
    ex de,hl	      ; ; ; ; ; ;0f33
    ld hl,(l0206h)    ; ; ; ; ; ;0f34
    call subHL_DE     ; ; ; ; ; ;0f37
    ld (l0234h),hl    ; ; ; ; ; ;0f3a	(l0234h)=(l0206h)-((HeapEnd)+4)
    ret		      ; ; ; ; ; ;0f3d
		      ; ; ; ; ;
l0f3eh:	      ;<----; ; ; ; ; ;
    cp 0ch	    ; ; ; ; ; ; ;0f3e
    jp z,l0f26h	    ; ; ; ; ; ; ;0f40	if(l0242h).eq.12 --> ...
    cp 13h	    ; ; ; ; ; ; ;0f43
    jp nc,l0f26h ;--)-)-)-)-)-; ;0f45	if(l0242h) >= 19 --> ...
    ld hl,(HeapEnd) ; ; ; ; ; ; ;0f48
    inc hl	    ; ; ; ; ; ; ;0f4b
    inc hl	    ; ; ; ; ; ; ;0f4c
    inc hl	    ; ; ; ; ; ; ;0f4d
    ld (hl),2	    ; ; ; ; ; ; ;0f4e	((HeapEnd)+3)=2
    jp l0f67h ;---; ; ; ; ; ; ; ;0f50	--> ...
		  ; ; ; ; ; ; ;
l0f53h:	   ;<-----)-)-)-)-+ ; ;
    cp 8	  ; ; ; ;   ; ; ;0f53
    jp c,l0f26h ;-)-)-)-)---)-+ ;0f55	if(l0242h) < 8 --> ...
    cp 0bh	  ; ; ; ;   ;	;0f58
    jp nc,l0f3eh;-)-+ ; ;   ;	;0f5a	if(l0242h) >= 11 --> ...
    ld hl,l01eah  ;   ; ;   ;	;0f5d	21 ea 01
    ld a,(hl)	  ;   ; ;   ;	;0f60	7e
    inc hl	  ;   ; ;   ;	;0f61	23
    or (hl)	  ;   ; ;   ;	;0f62	b6
    rra		  ;   ; ;   ;	;0f63	1f
    jp c,err132	  ;   ; ;   ;	;0f64	if --> Error (132) Illegal Mixed Mode Operation
l0f67h:	      ;<--+   ; ;   ;
    ld a,2	      ; ;   ;	;0f67
    ld (l01eah),a     ; ;   ;	;0f69	(l01eah)=2
    jp l0f2ch	  ;---+ ;   ;	;0f6c	--> ...
			;   ;
err132:			;   ;
    call err_msg	;   ;	;0f6f	Error (132)
    db 132		;   ;	;0f72	Illegal Mixed Mode Operation
			;   ;
l0f73h:		;<------+   ;
    ld hl,(l0236h)	    ;	;0f73	2a 36 02
    ex de,hl		    ;	;0f76	eb
    call s_0feeh	    ;	;0f77	cd ee 0f
    jp c,l0f12h	   ;--------;	;0f7a	da 12 0f
    ld (l01b8h),hl	    ;	;0f7d	(l01b8h)=
    ex de,hl		    ;	;0f80	eb
    ld (l01bah),hl	    ;	;0f81	(l01bah)=
    ld h,b		    ;	;0f84
    ld l,c		    ;	;0f85	hl=bc
    ld (l01bch),hl	    ;	;0f86	(l01bch)=
    ld hl,(l0206h)	    ;	;0f89	2a 06 02
l0f8ch:		  ;<----;   ;
    ex de,hl		;   ;	;0f8c	eb
    ld hl,(HeapEnd)	;   ;	;0f8d	2a 12 02
    call cmpHL_DE	;   ;	;0f90	Compare HL with DE
    jp z,l0f12h	   ;----)---+	;0f93	if HL.eq.DE --> ...
    ex de,hl		;	;0f96	eb
    ld a,(hl)		;	;0f97	7e
    or a		;	;0f98	b7
    jp m,l0fbfh	 ;----; ;	;0f99	if a < 0 --> ...
    push hl	      ; ;	;0f9c \ e5
    dec hl	      ; ;	;0f9d	2b
    dec hl	      ; ;	;0f9e	2b
    ld d,(hl)	      ; ;	;0f9f	56
    dec hl	      ; ;	;0fa0	2b
    ld e,(hl)	      ; ;	;0fa1	5e
    call s_0feeh      ; ;	;0fa2	cd ee 0f
    jp c,l0fbeh	 ;--; ; ;	;0fa5	da be 0f    trap_ms (00fbeh) ***
    ld a,h	    ; ; ;	;0fa8	7c
    and l	    ; ; ;	;0fa9	a5
    inc a	    ; ; ;	;0faa	3c
    push hl	    ; ; ;	;0fab \ e5
    ld hl,(l01b8h)  ; ; ;	;0fac	2a b8 01
    jp nz,l0fc6h ;--)-)-)---;	;0faf	c2 c6 0f
		    ; ; ;   ;
l0fb2h:	   ;<-------)-)-)-; ;
    ld a,h	    ; ; ; ; ;	;0fb2	7c
    or l	    ; ; ; ; ;	;0fb3	b5
    pop hl	    ; ; ; ; ;	;0fb4 / e1
    jp z,l0fbeh ;---; ; ; ; ;	;0fb5	if hl.eq.0 --> ...  trap_ms (00fbeh) ***
l0fb8h:	    ;<------)-)-)-)-)-;
    pop hl	    ; ; ; ; ; ; ;0fb8 / e1
    ld a,(hl)	    ; ; ; ; ; ; ;0fb9	7e
    or 080h	    ; ; ; ; ; ; ;0fba	f6 80
    ld (hl),a	    ; ; ; ; ; ; ;0fbc	77
    db 3eh	    ; ; ; ; ; ; ;0fbd	ld a,0e1h (in the original)  trap_ms ***
l0fbeh:	     ;<-----+ ; ; ; ; ;
    pop hl	    ; ; ; ; ; ; ;0fbe /
l0fbfh:	       ;<---)-+ ; ; ; ;
    dec hl	    ;	; ; ; ; ;0fbf	2b
    dec hl	    ;	; ; ; ; ;0fc0	2b
    dec hl	    ;	; ; ; ; ;0fc1	2b
    dec hl	    ;	; ; ; ; ;0fc2	2b
    jp l0f8ch ;-----)---+ ; ; ; ;0fc3	--> ...
		    ;	  ; ; ;
l0fc6h:	    ;<------)-----)-+ ;
    ld a,h	    ;	  ;   ; ;0fc6	7c
    and l	    ;	  ;   ; ;0fc7	a5
    inc a	    ;	  ;   ; ;0fc8	3c
    ex (sp),hl	    ;	  ;   ; ;0fc9	e3
    jp z,l0fb2h ;---)-----+   ; ;0fca	if hl.eq.-1 --> ...
    ex de,hl	    ;	      ; ;0fcd	eb
    ex (sp),hl	    ;	      ; ;0fce	e3
    call cmpHL_DE   ;	      ; ;0fcf	Compare HL with DE
    pop de	    ;	      ; ;0fd2 / d1
    jp nz,l0fbeh ;--;	      ; ;0fd3	if HL.ne.DE --> ...	trap_ms (00fbeh) ***
    ld hl,(l01bch)  ;	      ; ;0fd6	2a bc 01
    call cmpHL_DE   ;	      ; ;0fd9	Compare HL with DE
    jp c,l0fbeh	 ;--;	      ; ;0fdc	if HL < DE --> ...	trap_ms (00fbeh) ***
    ld hl,(l01bah)  ;	      ; ;0fdf	2a ba 01
    ex de,hl	    ;	      ; ;0fe2	eb
    ld h,b	    ;	      ; ;0fe3
    ld l,c	    ;	      ; ;0fe4	hl=bc
    call cmpHL_DE   ;	      ; ;0fe5	Compare HL with DE
    jp c,l0fbeh	 ;--+	      ; ;0fe8	if HL < DE --> ...	trap_ms (00fbeh) ***
    jp l0fb8h  ;--------------+ ;0feb	--> ...
;*
;*  ENTRY Reg DE - ADR
;*
s_0feeh:
    ld hl,(l0206h)	    ;0fee
    call subHL_DE	    ;0ff1   hl=(l0206h)-ADR
    jp c,l1037h	  ;-----;   ;0ff4   if (l0206h). < .ADR --> ...
    ld a,(hl)		;   ;0ff7
    and 00011111b	;   ;0ff8
    cp 013h		;   ;0ffa
    scf			;   ;0ffc   Set carry
    ret nz		;   ;0ffd   if (hl).ne.013h Return
    dec hl		;   ;0ffe
    dec hl		;   ;0fff   hl=(l0206h)-ADR-2
    ld d,(hl)		;   ;1000
    dec hl		;   ;1001   de=(hl)
    ld e,(hl)		;   ;1002
    ex de,hl		;   ;1003   eb
l1004h:		;<--;	;
    call ExtAttr    ;	;   ;1004   Extract Attributes from the symbol table
    ld a,(KindID)   ;	;   ;1007
    cp 3	    ;	;   ;100a
    ld hl,(l01d4h)  ;	;   ;100c   hl=(l01d4h)
    jp z,l1004h ;---+	;   ;100f   if (KindID).eq.3 (Variable)--> ...
    ld a,(ScopeID)	;   ;1012
    cp 3		;   ;1015
    jp z,l1032h	 ;--;	;   ;1017   if (ScopeID).eq.3 --> ...
    ld hl,(DataID)  ;	;   ;101a
    push hl	    ;	;   ;101d \ Save (DataID)
    call s_5a24h    ;	;   ;101e   cd 24 5a
    pop de	    ;	;   ;1021 / de=(DataID)
l1022h:	     ;<-----)-; ;
    add hl,de	    ; ; ;   ;1022   19
    dec hl	    ; ; ;   ;1023   2b
    ld b,h	    ; ; ;   ;1024
    ld c,l	    ; ; ;   ;1025   bc=hl
    ld hl,(EntryID) ; ; ;   ;1026
    ld a,(ScopeID)  ; ; ;   ;1029
    dec a	    ; ; ;   ;102c
    ret z	    ; ; ;   ;102d   if (ScopeID).eq.1 Return
    xor a	    ; ; ;   ;102e   a=0
    ld h,a	    ; ; ;   ;102f
    ld l,a	    ; ; ;   ;1030   hl=0
    ret		    ; ; ;   ;1031
		    ; ; ;
l1032h:	    ;<------; ; ;
    xor a	    ; ; ;   ;1032   a=0
    ld hl,0ffffh    ; ; ;   ;1033   hl=0ffffh
    ret		    ; ; ;   ;1036
		    ; ; ;
l1037h:	      ;<----)-)-+
    ex de,hl	    ; ;	    ;1037   eb
    call ExtAttr    ; ;	    ;1038   Extract Attributes from the symbol table
    ld a,(KindID)   ; ;	    ;103b
    cp 3	    ; ;	    ;103e
    jp z,l1047h ;-; ; ;	    ;1040   if (KindID).eq.3 (Variable) --> ...
    cp 4	  ; ; ;	    ;1043
    scf		  ; ; ;	    ;1045   Set carry
    ret nz	  ; ; ;	    ;1046   if (KindID).eq.4 (Array) Return
l1047h:	      ;<--+ ; ;
    ld a,(ScopeID)  ; ;	    ;1047
    cp 3	    ; ;	    ;104a
    jp z,l1032h ;---+ ;	    ;104c   if (ScopeID).eq.3 --> ...
    ld hl,(DataID)    ;	    ;104f
    ex de,hl	      ;	    ;1052   de=(DataID)
    ld a,(l02aah)     ;	    ;1053
    ld l,a	      ;	    ;1056
    ld h,0	      ;	    ;1057   hl=(l02aah)
    jp l1022h  ;------+	    ;1059   --> ...
;
l105ch:
    ld hl,(l0234h)	    ;105c
    ld (l01cch),hl	    ;105f   (l01cch)=(l0234h)
    ld a,(l0242h)	    ;1062
    cp 6		    ;1065
    jp z,l1107h	  ;-----;   ;1067   if (l0242h).eq.6 --> ...
    ex de,hl		;   ;106a
    ld hl,(l0206h)	;   ;106b
    call cmpHL_DE	;   ;106e   Compare HL with DE
    jp nc,l10eeh   ;----)-; ;1071   if (l0206h) >= (l01cch) --> ...
    ld a,(l0242h)	; ; ;1074
    cp 0ch		; ; ;1077
    jp nz,l10a4h ;----; ; ; ;1079   if (l0242h).ne.0ch --> ...
    call s_4647h      ; ; ; ;107c   Extract Attributes from the symbol table, entry( l01cch)
    dec a	      ; ; ; ;107f
    jp nz,l10a0h  ;-; ; ; ; ;1080   if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)   ; ; ; ; ;1083
    and 1	    ; ; ; ; ;1086
    jp z,l115dh	    ; ; ; ; ;1088   if (TypeID).eq.1 (REAL) --> ...
    ld hl,l01d6h    ; ; ; ; ;108b
    ld a,(hl)	    ; ; ; ; ;108e
    or a	    ; ; ; ; ;108f
    ret z	    ; ; ; ; ;1090   if (l01d6h).eq.0 Return
    dec hl	    ; ; ; ; ;1091   hl-hl-1
    ld a,(hl)	    ; ; ; ; ;1092
    xor 80h	    ; ; ; ; ;1093   10000000b
    ld (hl),a	    ; ; ; ; ;1095   (l01d6h)=(l01d6h).XOR.10000000b
    call s_055ah    ; ; ; ; ;1096   cd 5a 05
    ld hl,(l01cch)  ; ; ; ; ;1099
    ld (l0234h),hl  ; ; ; ; ;109c   (l0234h)=(l01cch)
    ret		    ; ; ; ; ;109f
		    ; ; ; ;
l10a0h:	       ;<---+ ; ; ;
    ld hl,(l01cch)    ; ; ; ;10a0   2a cc 01
    ex de,hl	      ; ; ; ;10a3   eb
l10a4h:		;<----+ ; ;
    call s_56fah	; ; ;10a4   cd fa 56
l10a7h:			; ;
    jp nz,l1107h   ;----; ; ;10a7   if ne.0 --> ...
    ld a,(hl)		; ; ;10aa   7e
    and 01fh		; ; ;10ab   00011111b
    jp nz,l570ch	; ; ;10ad   if ne.0 --> ...
    ld a,(hl)		; ; ;10b0   7e
    or a		; ; ;10b1   b7
    jp m,l570ch		; ; ;10b2   if < 0 --> ...
l10b5h:		;<--;	; ;
    dec hl	    ;	; ; ;10b5   2b
    dec hl	    ;	; ; ;10b6   2b
    dec hl	    ;	; ; ;10b7   2b
    dec hl	    ;	; ; ;10b8   2b
    ld a,(l0242h)   ;	; ; ;10b9   3a 42 02
    ld b,a	    ;	; ; ;10bc   save (l0242h)
    ld a,(hl)	    ;	; ; ;10bd   7e
    and 01fh	    ;	; ; ;10be   00011111b
    cp b	    ;	; ; ;10c0   b8
    jp nz,l570ch    ;	; ; ;10c1   if a.ne.(l0242h) --> ...
    ld a,(hl)	    ;	; ; ;10c4   7e
    and 80h	    ;	; ; ;10c5   10000000b
    jp nz,l570ch    ;	; ; ;10c7   if ne.0 --> ...
    dec hl	    ;	; ; ;10ca   2b
    dec hl	    ;	; ; ;10cb   2b
    ld d,(hl)	    ;	; ; ;10cc   56
    dec hl	    ;	; ; ;10cd   2b
    ld e,(hl)	    ;	; ; ;10ce   5e
    push hl	    ;	; ; ;10cf \ e5
    ld hl,(l0236h)  ;	; ; ;10d0   2a 36 02
    call cmpHL_DE   ;	; ; ;10d3   Compare HL with DE
    pop hl	    ;	; ; ;10d6 / e1
    jp nz,l570ch    ;	; ; ;10d7   if HL.ne.DE --> ...
    inc hl	    ;	; ; ;10da   23
    inc hl	    ;	; ; ;10db   23
    inc hl	    ;	; ; ;10dc   23
    ex de,hl	    ;	; ; ;10dd   eb
    ld hl,(l0206h)  ;	; ; ;10de   2a 06 02
    call subHL_DE   ;	; ; ;10e1   hl=hl-de
    ld (l0234h),hl  ;	; ; ;10e4   (l0234h)=
    ld a,(l01ebh)   ;	; ; ;10e7
    ld (l01eah),a   ;	; ; ;10ea   (l01eah)=(l01ebh)
    ret		    ;	; ; ;10ed
		    ;	; ;
l10eeh:		;<--)---)-+
    ld hl,l10a7h    ;	;   ;10ee
    ld (l025fh),hl  ;	;   ;10f1   (l025fh)=l10a7h
    ld hl,(l01cch)  ;	;   ;10f4
    ld (l025dh),hl  ;	;   ;10f7   (l025dh)=(l01cch)
    ex de,hl	    ;	;   ;10fa
    ld hl,(l0206h)  ;	;   ;10fb
    call subHL_DE   ;	;   ;10fe   hl=hl-de
    ld (l025bh),hl  ;	;   ;1101   (l025bh)=(l0206h)-(l01cch)
    jp l10b5h	;---+	;   ;1104   --> ...
			;
l1107h:		    ;<--+
    call s_1472h	    ;1107   cd 72 14
    jp l0efch		    ;110a   --> ...
;
l110dh:
    ld a,(l0242h)	    ;110d
    cp 0ch		    ;1110
    jp z,l115dh	   ;----;   ;1112   if(l0242h).eq.0ch --> ...
    ld a,(l01e8h)	;   ;1115
    dec a		;   ;1118
    jp z,l1143h	 ;----; ;   ;1119   if(l01e8h).eq.1 --> ...
l111ch:	     ;<-----; ; ;
    xor a	    ; ; ;   ;111c
    ld (l01e7h),a   ; ; ;   ;111d   (l01e7h)=0
    ld a,(l0242h)   ; ; ;   ;1120
    cp 3	    ; ; ;   ;1123
    jp c,l1132h ;-; ; ; ;   ;1125   if(l0242h) < 3 --> ...
    cp 8	  ; ; ; ;   ;1128
    jp c,l0ecdh	  ; ; ; ;   ;112a   if(l0242h) < 8 --> ...
    cp 0bh	  ; ; ; ;   ;112d
    jp nc,l0ecdh  ; ; ; ;   ;112f   if(l0242h) >= 0bh --> ...
l1132h:	      ;<--+ ; ; ;
    ld hl,(l0234h)  ; ; ;   ;1132
    ex de,hl	    ; ; ;   ;1135   de=(l0234h) ------;
    ld hl,(l0236h)  ; ; ;   ;1136		      ;
    ld (l0234h),hl  ; ; ;   ;1139   (l0234h)=(l0236h) ;
    ex de,hl	    ; ; ;   ;113c   hl=(l0234h) <-----+
    ld (l0236h),hl  ; ; ;   ;113d   (l0236h)=(l0234h)
    jp l0ecdh	    ; ; ;   ;1140   --> ...
		    ; ; ;
l1143h:		;<--)-+ ;
    ld a,(l0242h)   ;	;   ;1143
    cp 6	    ;	;   ;1146
    jp nc,l111ch ;--+	;   ;1148   if (l0242h) >= 6 --> ...
    ld hl,(l0236h)	;   ;114b   hl=(l0236h)
    call ExtAttr	;   ;114e   Extract Attributes from the symbol table
    ld hl,(l01d3h)	;   ;1151
    ld (l0236h),hl	;   ;1154   (l0236h)=(l01d3h)
    ld hl,(l01d5h)	;   ;1157
    ld (l0238h),hl	;   ;115a   (l0238h)=(l01d5h)
l115dh:		    ;<--+
    ld hl,(l0234h)	    ;115d   hl=(l0234h)
    call ExtAttr	    ;1160   Extract Attributes from the symbol table
    ld a,(l0242h)	    ;1163
    dec a		    ;1166
    jp z,l1193h ;-;	    ;1167   if(l0242h).eq.1 (Addition) --> ...
    dec a	  ;	    ;116a
    jp z,l119fh ;-)-;	    ;116b   if(l0242h).eq.2 (Multiplication) --> ...
    dec a	  ; ;	    ;116e
    jp z,l11bdh ;-)-)-;	    ;116f   if(l0242h).eq.3 (Subtraction) --> ...
    dec a	  ; ; ;	    ;1172
    jp z,l11c9h	  ; ; ;	    ;1173   if(l0242h).eq.4 (Division) --> ...
    dec a	  ; ; ;	    ;1176
    jp z,l11d5h	  ; ; ;	    ;1177   if(l0242h).eq.5 --> ...
    ld hl,l01d3h  ; ; ;	    ;117a   hl=l01d3h
    call s_20d9h  ; ; ;	    ;117d   Negate Integer*4 ^hl=-^hl
l1180h:	    ;<====)=)=)===I
    call s_055ah  ; ; ;	  I ;1180   cd 5a 05
    ld (l0234h),hl; ; ;	  I ;1183   (l0234h)=
    ret		  ; ; ;	  I ;1186
		  ; ; ;	  I
l1187h:	     ;<---)-)-)-; I
    ld hl,00000h  ; ; ; ; I ;1187
    ld (l01d3h),hl; ; ; ; I ;118a   (l01d3h)=0
    ld (l01d5h),hl; ; ; ; I ;118d   (l01d5h)=0
    jp l1180h ;===)=)=)=)=I ;1190   --> ...
		  ; ; ; ; I
l1193h:	   ;<-----+ ; ; ; I
    ld hl,l01d3h    ; ; ; I ;1193   hl=l01d3h
    ld de,l0236h    ; ; ; I ;1196   de=l0236h
    call s_20beh    ; ; ; I ;1199   Addition integer*4 ^hl=^de+^hl
    jp l1180h	;===)=)=)=I ;119c   --> ...
		    ; ; ; I
l119fh:	    ;<------+ ; ; I
    ld hl,00000h      ; ; I ;119f
    ld (l0234h),hl    ; ; I ;11a2   (l0234h)=0
l11a5h:		;<--; ; ; I
    ld hl,l01d3h    ; ; ; I ;11a5   hl=l01d3h
    ld de,l0236h    ; ; ; I ;11a8   de=l0236h
    call s_20e6h    ; ; ; I ;11ab   Multiplication integer*4 ^hl=^de+^hl
l11aeh:		    ; ; ; I
    ld hl,(l0234h)  ; ; ; I ;11ae
    dec hl	    ; ; ; I ;11b1
    ld (l0234h),hl  ; ; ; I ;11b2   (l0234h)=(l0234h)-1
    ld a,h	    ; ; ; I ;11b5
    or a	    ; ; ; I ;11b6
    jp m,l1180h	  ;=)=)=)=I ;11b7   if (l0234h) < 0 --> ...
    jp l11a5h  ;----+ ; ; I ;11ba   --> ...
		      ; ; I
l11bdh:		;<----+ ; I
    ld hl,l01d3h	; I ;11bd   hl=l01d3h
    ld de,l0236h	; I ;11c0   de=l0236h
    call s_20cbh	; I ;11c3   Subtraction integer*4 ^de=^hl-^de
    jp l1180h	     ;==)=I ;11c6   --> ...
			; I
l11c9h:			; I
    ld hl,l01d3h	; I ;11c9   hl=l01d3h
    ld de,l0236h	; I ;11cc   de=l0236h
    call s_2137h	; I ;11cf   Division integer*4 ^hl=^de+^hl
    jp l1180h	     ;==)=I ;11d2   --> ...
			;
l11d5h:			;
    ld hl,(l0236h)	;   ;11d5
    ld (l0234h),hl	;   ;11d8   (l0234h)=(l0236h)
    ld a,h		;   ;11db   7c
    or a		;   ;11dc   b7
    ld hl,(l01d3h)	;   ;11dd
    ld (l0236h),hl	;   ;11e0   (l0236h)=(l01d3h)
    ld hl,(l01d5h)	;   ;11e3
    ld (l0238h),hl	;   ;11e6   (l0238h)=(l01d5h)
    ld hl,00001h	;   ;11e9
    ld (l01d3h),hl	;   ;11ec   (l01d3h)=1
    ld hl,00000h	;   ;11ef
    ld (l01d5h),hl	;   ;11f2   (l01d5h)=0
    jp p,l11aeh		;   ;11f5   if (l0234h) > 0 --> ...
    ld hl,(l0236h)	;   ;11f8   2a 36 02
    ld a,h		;   ;11fb   7c
    or l		;   ;11fc   b5
    ld hl,(l0238h)	;   ;11fd   2a 38 02
    or h		;   ;1200   b4
    or l		;   ;1201   b5
    ld hl,00000h	;   ;1202   hl=0
    jp nz,l1187h    ;---;   ;1205   if a.ne.0 --> ...
    call err_msg	;   ;1208   Warning (30)
    db 30		;   ;120b   Division by Zero
    jp l1187h	    ;---+   ;120c   --> ...
;*
;*
;*
s_120fh:
    ld a,(l0242h)	    ;120f
    push af		    ;1212 \ Save (l0242h)
    call s_51e9h	    ;1213   cd e9 51
    pop af		    ;1216 /
    ld (l0242h),a	    ;1217   Restore (l0242h)
    ret			    ;121a
;*
;*  Processing EQUIVALENCE EQUIVALENCE (nlist) [,(nlist)]...
;*
PrEquivalence:
    call g_n_chr	    ;121b +
    call s_5a15h	    ;121e + Check '('
    ld hl,00000h	    ;1221   hl=0
    ld (l027bh),hl	    ;1224   (l027bh)=0
l1227h:		    ;<----;
    call ChkVar		  ; ;1227   Check that the name refers to a variables
    ld hl,00000h	  ; ;122a   hl=0
    ld (l0287h),hl	  ; ;122d   (l0287h)=0
    ex de,hl		  ; ;1230   eb
    ld a,(KindID)	  ; ;1231
    cp 3		  ; ;1234
    jp z,l1259h	 ;----;	  ; ;1236   if (KindID).eq.3 (Variable) --> ...
    call DimDecl      ;	  ; ;1239   Processing Dimension declarators
    ld a,(NumDim)     ;	  ; ;123c
    cp 1	      ;	  ; ;123f
    jp z,l124fh	 ;--; ;	  ; ;1241   if (NumDim).eq.1 --> ...
    ld hl,l022dh    ; ;	  ; ;1244
    cp (hl)	    ; ;	  ; ;1247
    jp z,l124fh	 ;--; ;	  ; ;1248   if (l022dh).eq.0 --> Skip error message
    call err_msg    ; ;	  ; ;124b   Warning (5)
    db 5	    ; ;	  ; ;124e   Wrong Number of Subscripts
		    ; ;	  ;
l124fh:		;<--+ ;	  ;
    call s_46e9h      ;	  ; ;124f   cd e9 46
    call s_08d5h      ;	  ; ;1252   cd d5 08
    ld (l0287h),hl    ;	  ; ;1255   (l0287h)=
    ex de,hl	      ;	  ; ;1258   eb
l1259h:		;<----+	  ;
    ld hl,(l01cch)	  ; ;1259
    ld (l01c2h),hl	  ; ;125c   (l01c2h)=(l01cch)
    ld hl,(DataID)	  ; ;125f
    ex de,hl		  ; ;1262
    ld hl,(l0287h)	  ; ;1263
    call subHL_DE	  ; ;1266
    ld (l0289h),hl	  ; ;1269   (l0289h)=(l0287h)-(DataID)
    ld hl,(l027bh)	  ; ;126c
    ld a,h		  ; ;126f
    or l		  ; ;1270
    jp z,l129fh	  ;-----; ; ;1271   if (l027bh).eq.0 --> ...
l1274h:	      ;<------; ; ;
    ex de,hl	      ; ; ; ;1274
    ld hl,(l01cch)    ; ; ; ;1275
    call cmpHL_DE     ; ; ; ;1278   Compare HL with DE
    jp nz,l12abh  ;-; ; ; ; ;127b   if (l01cch).ne.(l027bh) --> ...
    ld hl,(l0289h)  ; ; ; ; ;127e
    ld a,h	    ; ; ; ; ;1281
    or l	    ; ; ; ; ;1282
    jp z,l128ah ;-; ; ; ; ; ;1283   if (l0289h).eq.0 --> Skip error message
    call err_msg  ; ; ; ; ; ;1286   Warning (6)
    db 6	  ; ; ; ; ; ;1289   Array Multiply EQUIVALENCEd within a Group
		  ; ; ; ; ;
l128ah:	       ;<-+ ; ; ; ;
    ld a,(l0298h)   ; ; ; ; ;128a
    cp ','	    ; ; ; ; ;128d   Test separator
    jp z,l1227h	 ;--)-)-)-+ ;128f   if (l0298h).eq.',' --> ...
    call s_4e59h    ; ; ;   ;1292   cd 59 4e
    ld a,(l0242h)   ; ; ;   ;1295
    or a	    ; ; ;   ;1298
    jp z,l09e4h	    ; ; ;   ;1299   if (l0242h).eq.0 --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    jp PrEquivalence; ; ;   ;129c   --> ...
		    ; ; ;
l129fh:		;<--)-)-+
    ld hl,(l01cch)  ; ;	    ;129f
    ld (l027bh),hl  ; ;	    ;12a2   (l027bh)=(l01cch)
    ld a,(ScopeID)  ; ;	    ;12a5
    ld (l028bh),a   ; ;	    ;12a8   (l028bh)=(ScopeID)
l12abh:	      ;<----+ ;
    ld a,(ScopeID)    ;	    ;12ab
    dec a	      ;	    ;12ae
    jp z,l12eeh	  ;-; ;	    ;12af   if (ScopeID).eq.1 --> ...
    ld hl,(l0289h)  ; ;	    ;12b2
    ex de,hl	    ; ;	    ;12b5
    ld hl,(DataID)  ; ;	    ;12b6
    add hl,de	    ; ;	    ;12b9
    ld (DataID),hl  ; ;	    ;12ba   (DataID)=(DataID)+(l0289h)
    ld a,(l028bh)   ; ;	    ;12bd
    cp 1	    ; ;	    ;12c0
    jp z,l132eh ;---)-)-;   ;12c2   if (l028bh).eq.1 --> ...
    ld (ScopeID),a  ; ; ;   ;12c5   (ScopeID)=(l028bh)
    call PutAttr    ; ; ;   ;12c8   Put Attributes in Symbol table
    call s_16b9h    ; ; ;   ;12cb   {call ExtAttr(EntryID); test hl=(l01c2h)-(EntryID)}
    ld hl,(l027bh)  ; ; ;   ;12ce   hl=(l027bh)
    jp nz,l1274h  ;-)-+ ;   ;12d1   if (l01c2h)-(EntryID).ne.0 --> ...
    dec hl	    ;	;   ;12d4   2b
    dec hl	    ;	;   ;12d5   2b
    dec hl	    ;	;   ;12d6   2b
    dec hl	    ;	;   ;12d7   2b
    ld b,(hl)	    ;	;   ;12d8   46
    dec hl	    ;	;   ;12d9   2b
    ld c,(hl)	    ;	;   ;12da   4e
    ex de,hl	    ;	;   ;12db   eb
    ld hl,(EntryID) ;	;   ;12dc   2a 74 01
    ex de,hl	    ;	;   ;12df   eb
    ld (hl),e	    ;	;   ;12e0   73
    inc hl	    ;	;   ;12e1   23
    ld (hl),d	    ;	;   ;12e2   72
    ld h,b	    ;	;   ;12e3
    ld l,c	    ;	;   ;12e4   hl=bc
    ld (EntryID),hl ;	;   ;12e5   (EntryID)=
    call PutAttr    ;	;   ;12e8   Put Attributes in Symbol table
    jp l128ah	    ;	;   ;12eb   --> ...
		    ;	;
l12eeh:		;<--+	;
    ld hl,(l0287h)	;   ;12ee
    ex de,hl		;   ;12f1
    ld hl,(DataID)	;   ;12f2
    add hl,de		;   ;12f5
    ld (l028dh),hl	;   ;12f6   (l028dh)=(DataID)+(l0287h)
    ld hl,(EntryID)	;   ;12f9
    ld (l028fh),hl	;   ;12fc   (l028fh)=(EntryID)
    ld hl,(l01cch)	;   ;12ff
    ex de,hl		;   ;1302
    ld hl,(l027bh)	;   ;1303
    call cmpHL_DE	;   ;1306   Compare HL with DE
    jp z,l128ah		;   ;1309   if (l027bh).eq.(l01cch) --> ...
    ld a,(l028bh)	;   ;130c
    dec a		;   ;130f
    jp nz,l131ah  ;-;	;   ;1310   if (l028bh).ne.1  --> Skip error message
    call err_msg    ;	;   ;1313   Warning (7)
    db 7	    ;	;   ;1316   Multiple EQUIVALENCE of COMMON
    jp l128ah	    ;	;   ;1317   --> ...
		    ;	;
l131ah:		;<--+	;
    ld a,1		;   ;131a
    ld (l028bh),a	;   ;131c   (l028bh)=1
    ld hl,(l027bh)	;   ;131f
    ld (l01c2h),hl	;   ;1322   (l01c2h)=(l027bh)
    call ExtAttr	;   ;1325   Extract Attributes from the symbol table
l1328h:		;<----; ;
    ld hl,00000h      ; ;   ;1328
    ld (l0289h),hl    ; ;   ;132b   (l0289h)=0
l132eh:		 ;<---)-+
    ld hl,(DataID)    ;	    ;132e
    ex de,hl	      ;	    ;1331
    ld hl,(l028dh)    ;	    ;1332
    call subHL_DE     ;	    ;1335
    ld (DataID),hl    ;	    ;1338   (DataID)=(l028dh)-(DataID)
    ld a,h	      ;	    ;133b
    or a	      ;	    ;133c
    jp p,l1344h	 ;--; ;	    ;133d   if (DataID) > 0 --> Skip error message
    call err_msg    ; ;	    ;1340   Warning (8)
    db 8	    ; ;	    ;1343   COMMON Base Lowered
l1344h:	       ;<---+ ;
    ld hl,(l0289h)    ;	    ;1344
    ex de,hl	      ;	    ;1347
    ld hl,(l028dh)    ;	    ;1348
    call subHL_DE     ;	    ;134b
    ld (l028dh),hl    ;	    ;134e   (l028dh)=(l028dh)-(l0289h)
    call s_5a24h      ;	    ;1351   cd 24 5a
    ex de,hl	      ;	    ;1354   eb
    ld hl,(DataID)    ;	    ;1355   2a 5d 01
    add hl,de	      ;	    ;1358   19
    ex de,hl	      ;	    ;1359   eb
    ld hl,(l028fh)    ;	    ;135a   2a 8f 02
l135dh:		;<--; ;
      dec hl	    ; ;	    ;135d   hl=hl-1
      ld a,(hl)	    ; ;	    ;135e   7e
      and 007h	    ; ;	    ;135f   00000111b
      cp 4	    ; ;	    ;1361   fe 04
      dec hl	    ; ;	    ;1363   hl=hl-1
      ld b,h	    ; ;	    ;1364
      ld c,l	    ; ;	    ;1365   bc=hl
      ld a,(hl)	    ; ;	    ;1366   7e
      dec hl	    ; ;	    ;1367   hl=hl-1
      ld l,(hl)	    ; ;	    ;1368   6e
      ld h,a	    ; ;	    ;1369   67
    jp z,l135dh	  ;-+ ;	    ;136a   ca 5d 13
    call cmpHL_DE     ;	    ;136d   Compare HL with DE
    jp nc,l1378h ;--; ;	    ;1370   if HL >= DE --> ...
    ld h,b	    ; ;	    ;1373
    ld l,c	    ; ;	    ;1374   hl=bc
    ld (hl),d	    ; ;	    ;1375   72
    dec hl	    ; ;	    ;1376   2b
    ld (hl),e	    ; ;	    ;1377   73
l1378h:		;<--+ ;
    ld hl,(l028fh)    ;	    ;1378   2a 8f 02
    ex de,hl	      ;	    ;137b   eb
    push de	      ;	    ;137c \ d5	------------------------------;
    ld hl,(EntryID)   ;	    ;137d				      ;
    push hl	      ;	    ;1380 \ Save (EntryID)    --------------; ;
    ld (l028fh),hl    ;	    ;1381   (l028fh)=(EntryID)		    ; ;
    ex de,hl	      ;	    ;1384   eb				    ; ;
    ld (EntryID),hl   ;	    ;1385   (EntryID)=			    ; ;
    ld a,1	      ;	    ;1388   a=1				    ; ;
    ld (ScopeID),a    ;	    ;138a   (ScopeID)=1			    ; ;
    call PutAttr      ;	    ;138d   Put Attributes in Symbol table  ; ;
    pop hl	      ;	    ;1390 / Restore (EntryID) <-------------+ ;
    ld (EntryID),hl   ;	    ;1391   (EntryID)=(EntryID)		      ;
    pop hl	      ;	    ;1394 / e1	<-----------------------------+
    ld (l028fh),hl    ;	    ;1395   (l028fh)=
    call s_16b9h      ;	    ;1398   {call ExtAttr(EntryID); test hl=(l01c2h)-(EntryID)}
    jp nz,l1328h ;----+	    ;139b   if (l01c2h)-(EntryID).ne.0 --> ...
    jp l128ah		    ;139e   --> ...
;*
;*  Print error message
;*
err_msg:
    ex (sp),hl		;13a1	Get callers address
    push af		;13a2
    push de		;13a3
    push bc		;13a4
    ld a,(hl)		;13a5	Fetch error_number
    inc hl		;13a6	23
    push hl		;13a7	e5
    cp 064h		;13a8	test 100
    push af		;13aa	Save error_number
    inc a		;13ab	a=a+1
    ld (conflg),a	;13ac	Set console
    call p_crlf		;13af	Put cr lf to console
    pop af		;13b2	Restore error_number
    push af		;13b3	Save error_number
    ld a,'?'		;13b4	a='?' mark error
    jp nc,l13bbh ;--;	;13b6	if error_number >= 100 skip '%'
    ld a,'%'	    ;	;13b9	a='%' mark warning
l13bbh:		;<--+
    call putchr		;13bb	Print mark
;
    ld hl,l0324h	;13be	hl="Line: "
    call PrStrg		;13c1	Print string
;
    ld a,(l0220h)	;13c4
    or a		;13c7
    jp nz,l13d4h  ;---; ;13c8	if (l0220h).ne.0 --> Skip Print number
    ld hl,(NumSrc)    ; ;13cb	Get line number source file
    call PrNumb	      ; ;13ce	Print number in HL as decimal number
    jp l13dah	 ;--; ; ;13d1	--> Skip Print string
		    ; ;
l13d4h:	      ;<----)-+
    ld hl,l0220h    ;	;13d4	21 20 02
    call PrStrg	    ;	;13d7	Print string
l13dah:		;<--+
    ld a,' '		;13da
    call putchr		;13dc	Print ' '
    pop af		;13df	Restore error_number
    push af		;13e0	Save error_number
    ld hl,WrnTab	;13e1	hl=Point to warning msg table
    jp c,l13ech	  ;-;	;13e4	if error_number < 100 - warning
    sub 064h	    ;	;13e7	a=a-100
    ld hl,ErrTab    ;	;13e9	hl=Point to error msg table
l13ech:		;<--+
    inc a		;13ec	a=a+1
    ld c,a		;13ed	4f
l13eeh:		;<--;
      ld a,(hl)	    ;	;13ee	7e
      or a	    ;	;13ef	b7
      inc hl	    ;	;13f0	hl=hl+1
      jp p,l13eeh ;-;	;13f1	if a > 0 --> ...
      dec c	    ;	;13f4	c=c-1
    jp nz,l13eeh  ;-+	;13f5	if c.ne.0 --> ...
    call PrStrg		;13f8	Print string error(warning) msg
    ld a,':'		;13fb
    call putchr		;13fd	print ':'
;*
;*  Print characters scanned at the time the error was detected
;*
    ld hl,l02b4h-1	;1400	21 b3 02
l1403h:		;<--;
      inc hl	    ;	;1403	hl=hl+1
      ld a,(hl)	    ;	;1404	Get character
      cp ' '	    ;	;1405
    jp z,l1403h	  ;-+	;1407	Skip space
;
l140ah:		   ;<-;
      ld a,(hl)	      ; ;140a	Get character
      cp cr	      ; ;140b	Test end of line (cr)
      jp z,l1417h ;-; ; ;140d	.. yeap
      call putchr   ; ; ;1410	Put character to console
      inc hl	    ; ; ;1413
    jp l140ah	;---)-+ ;1414	--> next character
		    ;
l1417h:	      ;<----+
    call p_crlf		;1417	Put cr lf to console
    xor a		;141a	a=0
    ld (conflg),a	;141b	(conflg)=0 clear console
    pop af		;141e	Restore error_number
    jp c,l1458h ;---;	;141f	if error_number < 100 --> skip error processing
    ld hl,(ErrCnt)  ;	;1422
    inc hl	    ;	;1425
    ld (ErrCnt),hl  ;	;1426	(ErrCnt)=(ErrCnt)+1
    ld hl,(TopMem)  ;	;1429	Load value Top of memory
    ld sp,hl	    ;	;142c	Set for stack
    ld hl,(l01a4h)  ;	;142d
    ld (HeapPtr),hl ;	;1430	(HeapPtr)=(l01a4h)
    ld hl,(l0206h)  ;	;1433
    ld (HeapEnd),hl ;	;1436	(HeapEnd)=(l0206h)
    ld b,a	    ;	;1439	Save error_number
    xor a	    ;	;143a
    ld (l0173h),a   ;	;143b	(l0173h)=0
    ld (l01ceh),a   ;	;143e	(l01ceh)=0
    ld a,b	    ;	;1441	Restore error_number
    cp 131	    ;	;1442
    jp z,l3bcbh	    ;	;1444	if error_number.eq.131 (Premature End Of File on Input Device) --> Completion compile the module
    call s_1b32h    ;	;1447	Clear buffer ^l02b4h length 20
l144ah:	      ;<--; ;
    ld a,(l0298h) ; ;	;144a
    cp cr	  ; ;	;144d
    jp z,Firstep  ; ;	;144f	if (l0298h).eq.cr --> First step of the compilation
    call s_19a2h  ; ;	;1452	Parsing source line
    jp l144ah ;---+ ;	;1455	--> ...
		    ;
l1458h:		;<--+
    ld hl,(WrnCnt)	;1458
    inc hl		;145b
    ld (WrnCnt),hl	;145c	(WrnCnt)=(WrnCnt)+1
    pop hl		;145f
    pop bc		;1460
    pop de		;1461
    pop af		;1462
    ex (sp),hl		;1463	fix return address
    ret			;1464
;*
;* Print *****
;*
s_1465h:
    ld hl,l37c3h	;1465 + hl="*****"
;*
;* Print stringn in ^HL
;*
PrStrg:
l1468h:		;<--;
      ld a,(hl)	    ;	;1468 + Get character
      inc hl	    ;	;1469 +
      call putchr   ;	;146a + Put character to console
      or a	    ;	;146d + Test end string
    jp p,l1468h ;---+	;146e + .. nope
    ret			;1471 +
;
s_1472h:
    xor a		    ;1472   a=0
;
;   ENTRY Reg A (0,6,7,11,20,23
;
s_1473h:
    push af		    ;1473 \ f5
    ld a,4		    ;1474   a=4
    call ChkMem		    ;1476   Test Allocate A bytes of memory
    ld hl,(l01cch)	    ;1479			      hl=(l01cch)
    inc hl		    ;147c			      hl=(l01cch)-1
    ld a,h		    ;147d
    or l		    ;147e
    jp z,l1490h	 ;--;	    ;147f   if (l01cch).eq.1 --> ...
    dec hl	    ;	    ;1482			      hl=(l01cch)
    ex de,hl	    ;	    ;1483					   de=(l01cch)
    ld hl,(l0206h)  ;	    ;1484			      hl=(l0206h)
    call cmpHL_DE   ;	    ;1487   Compare HL with DE
    jp nc,l14aeh ;--)-;	    ;148a   if (l0206h) >= (l01cch) --> ...
    call s_4647h    ; ;	    ;148d   Extract Attributes from the symbol table, entry (l01cch)
l1490h:	       ;<---+ ;
    pop af	      ;	    ;1490 / f1
l1491h:		;<----)-;
    ld b,a	      ; ;   ;1491   b=a
l1492h:	       ;<---+ ; ;
    ld a,(l02a2h)   ; ; ;   ;1492   3a a2 02
    rrca	    ; ; ;   ;1495   0f
    or b	    ; ; ;   ;1496   b0
    ld hl,(HeapEnd) ; ; ;   ;1497			      hl=(HeapEnd)
    ld (hl),a	    ; ; ;   ;149a   ((HeapEnd))=a
    ld a,(TypeID)   ; ; ;   ;149b
    dec hl	    ; ; ;   ;149e			      hl=((HeapEnd))-1
    ld (hl),a	    ; ; ;   ;149f   (hl)=(TypeID)
    ex de,hl	    ; ; ;   ;14a0					      de=((HeapEnd))-1
    ld hl,(l01cch)  ; ; ;   ;14a1			      hl=(l01cch)
    ex de,hl	    ; ; ;   ;14a4			      hl=((HeapEnd))-1	 de=(l01cch)
    dec hl	    ; ; ;   ;14a5			      hl=((HeapEnd))-2
    ld (hl),d	    ; ; ;   ;14a6   72
    dec hl	    ; ; ;   ;14a7   2b
    ld (hl),e	    ; ; ;   ;14a8   73
    dec hl	    ; ; ;   ;14a9   2b
    ld (HeapEnd),hl ; ; ;   ;14aa   (HeapEnd)=
    ret		    ; ; ;   ;14ad
		    ; ; ;
l14aeh:		 ;<-)-+ ;
    call subHL_DE   ;	;   ;14ae   hl=hl-de		      hl=(l0206h)-(l01cch)
    dec hl	    ;	;   ;14b1   hl=hl-1		      hl=(l0206h)-(l01cch)-1
    ld a,(hl)	    ;	;   ;14b2   7e
    ld (TypeID),a   ;	;   ;14b3   (TypeID)=
    pop af	    ;	;   ;14b6 / restore PAR
    or a	    ;	;   ;14b7   b7
    jp nz,l1491h ;--)---+   ;14b8   if PAR.ne.0 --> ...
    ld b,a	    ;	    ;14bb   b=a
    dec hl	    ;	    ;14bc			      hl=(l0206h)-(l01cch)-2
    ld a,(hl)	    ;	    ;14bd   7e
    and 01fh	    ;	    ;14be   00011111b
    cp 013h	    ;	    ;14c0
    jp z,l1492h ;---;	    ;14c2   if a.eq.13h --> ...
    ex de,hl	    ;	    ;14c5			      hl=(l01cch) de=(l0206h)-(l01cch)-2
    ld hl,(HeapEnd) ;	    ;14c6			      hl=(HeapEnd)
    inc hl	    ;	    ;14c9
    inc hl	    ;	    ;14ca
    inc hl	    ;	    ;14cb
    inc hl	    ;	    ;14cc			      hl=(HeapEnd)+4
    call cmpHL_DE   ;	    ;14cd   Compare HL with DE
    jp nz,l1492h ;--+	    ;14d0   if (HeapEnd)+4.ne.(l0206h)-(l01cch)-2 --> ...
    ret			    ;14d3
;*
;*  g_n_chr; (l0173h)=chr
;*
s_14d4h:
    call g_n_chr	  ;14d4 +
    ld (l0173h),a	  ;14d7 +   (l0173h)=chr
    ret			  ;14da +
;*
;*    ENTRY  Reg  A -
;*	0 -
;*	1 -
;*     -1 -
;*    EXIT
;*
s_14dbh:
    or a		    ;14db   Test BYTE
    push af		    ;14dc \ Save Carry status ------;
    ld (l01c1h),a	    ;14dd   (l01c1h)=BYTE	    ;
    xor a		    ;14e0   a=0			    ;
    ld (l024ch),a	    ;14e1   (l024ch)=0		    ;
    ld (l02a3h),a	    ;14e4   (l02a3h)=0		    ;
    ld h,a		    ;14e7			    ;
    ld l,a		    ;14e8			    ;
    ld (l0243h),hl	    ;14e9   (l0243h)=0		    ;
    call s_0e80h	    ;14ec   cd 80 0e		    ;
    pop af		    ;14ef / Restore Carry status <--+
    push af		    ;14f0 \ Save BYTE
    jp m,l165eh		    ;14f1   if BYTE < 0 --> ...
l14f4h:
    call s_1cb5h	    ;14f4   cd b5 1c
    or a		    ;14f7
    jp z,l166ah		    ;14f8   if (KindID).eq.0 --> ...
    dec a		    ;14fb
    jp nz,l1569h  ;-----;   ;14fc   if (KindID).ne.1 (Constant)--> ...
    ld a,(l01cbh)	;   ;14ff
    or a		;   ;1502
    jp z,l1569h	  ;-----;   ;1503   if (l01cbh).eq.0 --> ...
    ld a,(l024ch)	;   ;1506
    or a		;   ;1509
    jp z,l1557h	 ;----; ;   ;150a   if (l024ch).eq.0 --> ...
    ld hl,(DatSiz)    ; ;   ;150d   Load Data size
    ld bc,020bh	      ; ;   ;1510   Address modes DSEG (2), REL type - Set loading location counter (11)
    call s_56deh      ; ;   ;1513   cd de 56
    ld a,(l01d3h)     ; ;   ;1516
    ld d,a	      ; ;   ;1519   d=(l01d3h)
l151ah:	      ;<--;   ; ;
    call s_1a98h  ;   ; ;   ;151a   cd 98 1a
    jp z,l1526h ;-)-; ; ;   ;151d   if eq.0 --> ...
    call s_37a8h  ; ; ; ;   ;1520   Put constant byte in reg A to REL file
    jp l151ah ;---+ ; ; ;   ;1523   --> ...
		    ; ; ;
l1526h:	      ;<----+ ; ;
    ld hl,0483ah      ; ;   ;1526
    ld (l01d5h),hl    ; ;   ;1529   (l01d5h)=0483ah !!! ":H"
    ld hl,(l01c9h)    ; ;   ;152c
    inc hl	      ; ;   ;152f
    ld (l01c9h),hl    ; ;   ;1530   (l01c9h)=(l01c9h)+1
    ld (l01d3h),hl    ; ;   ;1533   (l01d3h)=(l01c9h)+1
    ld a,4	      ; ;   ;1536
    ld (SizeID),a     ; ;   ;1538   (SizeID)=4
    dec a	      ; ;   ;153b
    ld (KindID),a     ; ;   ;153c   (KindID)=3 (Variable)
    call s_055ah      ; ;   ;153f   cd 5a 05
    call s_0cf8h      ; ;   ;1542   cd f8 0c
    ld hl,(PrgSiz)    ; ;   ;1545
    ld (DatSiz),hl    ; ;   ;1548   (DatSiz)=(PrgSiz)
    ld hl,(l021bh)    ; ;   ;154b   hl=(l021bh)
    call s_56dbh      ; ;   ;154e   cd db 56
    call s_4888h      ; ;   ;1551   cd 88 48
    jp l1573h	;---; ; ;   ;1554   --> ...
		    ; ; ;
l1557h:	    ;<------)-+ ;
    call s_4ab1h    ;	;   ;1557   cd b1 4a
    ld hl,(l01d1h)  ;	;   ;155a
    ld (l01d5h),hl  ;	;   ;155d   (l01d5h)=(l01d1h)
    ld hl,(l01cfh)  ;	;   ;1560
    ld (l01d3h),hl  ;	;   ;1563   (l01d3h)=(l01cfh)
    call s_4888h    ;	;   ;1566   cd 88 48
l1569h:	      ;<----)---+
    call s_055ah    ;	    ;1569   cd 5a 05
    cp 4	    ;	    ;156c
    jp nc,l1633h    ;	    ;156e   if a >= 4 --> ...
    sbc a,a	    ;	    ;1571   9f
    ret pe	    ;	    ;1572   e8
l1573h:	    ;<------+
    call s_0e9dh	    ;1573   cd 9d 0e
    ld a,(l0242h)	    ;1576
    or a		    ;1579
    jp nz,l1589h ;--;	    ;157a   if (l0242h).ne.0  --> ...
    ld a,(l0298h)   ;	    ;157d
    cp cr	    ;	    ;1580
    jp z,l161ch	 ;--)-----; ;1582   if (l0298h).eq.cr --> ...
    call err_msg    ;	  ; ;1585   Error (118)
    db	118	    ;	  ; ;1588   Illegal Operator
		    ;	  ;
l1589h:	     ;<-----+	  ;
    cp 6		  ; ;1589
    jp z,l15bah ;-------; ; ;158b   if (l0242h).eq.6   --> ...
    cp 0ch		; ; ;158e
    jp z,l15e4h	 ;----; ; ; ;1590   if (l0242h).eq.0ch --> ...
    cp 7	      ; ; ; ;1593
    jp z,l15ach ;-;   ; ; ; ;1595   if (l0242h).eq.7   --> ...
    ld (l02a3h),a ;   ; ; ; ;1598   (l02a3h)=a
    cp 9	  ;   ; ; ; ;159b
    jp c,l14f4h	  ;   ; ; ; ;159d   if (l02a3h) < 9    --> ...
    cp 0bh	  ;   ; ; ; ;15a0
    jp z,l14f4h	  ;   ; ; ; ;15a2   if (l02a3h).eq.0bh --> ...
l15a5h:	    ;<----)-; ; ; ;
    xor a	  ; ; ; ; ; ;15a5   a=0
    ld (l02a3h),a ; ; ; ; ; ;15a6   (l02a3h)=0
    jp l14f4h	  ; ; ; ; ; ;15a9   --> ...
		  ; ; ; ; ;
l15ach:	     ;<---+ ; ; ; ;
    ld a,(l01c1h)   ; ; ; ; ;15ac
    or a	    ; ; ; ; ;15af   if (l01c1h).ne.0
    jp nz,err126    ; ; ; ; ;15b0      --> Error (126) Illegal Character for Syntax
    inc a	    ; ; ; ; ;15b3
    ld (l01c1h),a   ; ; ; ; ;15b4   (l01c1h)=1
    jp l15a5h ;-----+ ; ; ; ;15b7   --> ...
		    ; ; ; ;
l15bah:	       ;<---)-)-+ ;
    ld hl,(l0243h)  ; ;	  ; ;15ba
    ld a,h	    ; ;	  ; ;15bd
    or l	    ; ;	  ; ;15be
    jp nz,err119    ; ;	  ; ;15bf   if (l0243h).ne.0 --> Error (119) Mismatched Parenthesis
    ld a,(l024ch)   ; ;	  ; ;15c2
    or a	    ; ;	  ; ;15c5
    jp nz,l15ceh;-; ; ;	  ; ;15c6   if (l024ch).ne.0 --> ...
    pop af	  ; ; ;	  ; ;15c9 /
    jp p,err102	  ; ; ;	  ; ;15ca   if a > 0 --> Error (102) Illegal Statement Completion
    push af	  ; ; ;	  ; ;15cd \
l15ceh:	      ;<--+ ; ;	  ;
    call s_120fh    ; ;	  ; ;15ce   cd 0f 12
l15d1h:		    ; ;	  ;
    call s_0e9dh    ; ;	  ; ;15d1   cd 9d 0e
    call s_0e80h    ; ;	  ; ;15d4   cd 80 0e
    xor a	    ; ;	  ; ;15d7   a=0
    ld h,a	    ; ;	  ; ;15d8
    ld l,a	    ; ;	  ; ;15d9   hl=0
    ld (l0243h),hl  ; ;	  ; ;15da   (l0243h)=0
    jp l15a5h  ;----+ ;	  ; ;15dd   --> ...
		      ;	  ;
err119:		      ;	  ;
    call err_msg      ;	  ; ;15e0   Error (119)
    db 119	      ;	  ; ;15e3   Mismatched Parenthesis
		      ;	  ;
l15e4h:	    ;<--------+	  ;
    ld hl,(l0243h)	  ; ;15e4
    dec hl		  ; ;15e7
    ld (l0243h),hl	  ; ;15e8   (l0243h)=(l0243h)-1
    ld a,h		  ; ;15eb
    or a		  ; ;15ec
    jp p,l160fh	 ;--;	  ; ;15ed   if (l0243h) > 0  --> ...
    ld a,(l024ch)   ;	  ; ;15f0
    or a	    ;	  ; ;15f3
    jp z,l1615h ;---)-;	  ; ;15f4   if (l024ch).eq.0 --> ...
    dec a	    ; ;	  ; ;15f7
    ld (l024ch),a   ; ;	  ; ;15f8   (l024ch)=(l024ch)-1
    call s_4e59h    ; ;	  ; ;15fb   cd 59 4e
    call s_120fh    ; ;	  ; ;15fe   cd 0f 12
    pop af	    ; ;	  ; ;1601 / f1
    push af	    ; ;	  ; ;1602 \ ----------------------------;
    jp p,l1573h	    ; ;	  ; ;1603   if a > 0 --> ...		;
    ld a,(l024ch)   ; ;	  ; ;1606				;
    or a	    ; ;	  ; ;1609				;
    jp nz,l1573h    ; ;	  ; ;160a   if (l024ch).ne.0 --> ...	;
    pop af	    ; ;	  ; ;160d / <---------------------------+
    ret		    ; ;	  ; ;160e
		    ; ;	  ;
l160fh:		;<--+ ;	  ;
    call s_4e59h      ;	  ; ;160f   cd 59 4e
    jp l1573h	      ;	  ; ;1612   --> ...
		      ;	  ;
l1615h:	      ;<------+	  ;
    pop af		  ; ;1615 / f1
    jp z,err119		  ; ;1616   if a.eq.0 --> Error (119) Mismatched Parenthesis
    jp s_51e9h		  ; ;1619   --> ...
			  ;
l161ch:	    ;<------------+
    ld a,(l024ch)	    ;161c
    or a		    ;161f
    jp nz,err119	    ;1620   if (l024ch).ne.0 --> Error (119) Mismatched Parenthesis
    ld hl,(l0243h)	    ;1623
    ld a,h		    ;1626
    or l		    ;1627
    jp nz,err119	    ;1628   if (l0243h).ne.0) Error (119) Mismatched Parenthesis
    pop af		    ;162b / f1
    jp z,s_51e9h	    ;162c   if a.eq.0 --> ...
    call err_msg	    ;162f   Error (102)
    db 102		    ;1632   Illegal Statement Completion

l1633h:
    ld a,(l0298h)	    ;1633
    cp '('		    ;1636
    jp z,l164ch ;---;	    ;1638   if (l0298h).eq.'(' --> ...
    cp ','	    ;	    ;163b
    jp z,l1573h	    ;	    ;163d   if (l0298h).eq.',' --> ...
    cp ')'	    ;	    ;1640
    jp z,l1573h	    ;	    ;1642   if (l0298h).eq.')' --> ...
    call err_msg    ;	    ;1645   Warning (27)
    db 27	    ;	    ;1648   Invalid Operand Usage
    jp l1573h	    ;	    ;1649   --> ...
		    ;
l164ch:		;<--+
    ld a,(KindID)	    ;164c
    cp 5		    ;164f
    jp nc,l165eh ;--;	    ;1651   if (KindID) >= 5 (Routine) --> ...
    call s_4b20h    ;	    ;1654   cd 20 4b
    xor a	    ;	    ;1657
    ld (l022eh),a   ;	    ;1658   (l022eh)=0
    jp l1573h	    ;	    ;165b   --> ...
		    ;
l165eh:		;<--+
    ld a,6		    ;165e
    ld (l0242h),a	    ;1660   (l0242h)=6
    ld hl,l024ch	    ;1663
    inc (hl)		    ;1666   (l024ch)=(l024ch)+1
    jp l15d1h		    ;1667   --> ...
;
l166ah:
    ld a,(l0298h)	    ;166a
    cp '('		    ;166d
    jp z,l169ch	  ;---;	    ;166f   if (l0298h).eq.'(' --> ...
    ld hl,l02a3h      ;	    ;1672
    inc (hl)	      ;	    ;1675
    dec (hl)	      ;	    ;1676
    jp nz,err120 ;--; ;	    ;1677   if (l02a3h).ne.0 --> Error (120) Consecutive Operators
    inc (hl)	    ; ;	    ;167a   (l02a3h)=(l02a3h)+1
    ld a,(l0242h)   ; ;	    ;167b
    dec a	    ; ;	    ;167e
    jp z,l14f4h	    ; ;	    ;167f   if (l0242h).eq.1   --> ...
    ld hl,00000h    ; ;	    ;1682
    ld (l01cch),hl  ; ;	    ;1685   (l01cch)=0
    call s_0e9dh    ; ;	    ;1688   cd 9d 0e
    ld a,(l0242h)   ; ;	    ;168b
    cp 3	    ; ;	    ;168e
    jp z,l14f4h	    ; ;	    ;1690   if (l0242h).eq.3   --> ...
    cp 00bh	    ; ;	    ;1693
    jp z,l14f4h	    ; ;	    ;1695   if (l0242h).eq.0bh --> ...
err120:		;<--+ ;
    call err_msg      ;	    ;1698   Error (120)
    db 120	      ;	    ;169b   Consecutive Operators
		      ;
l169ch:		;<----+
    ld hl,(l0243h)	    ;169c
    ld (l01cch),hl	    ;169f   (l01cch)=(l0243h)
    inc hl		    ;16a2
    ld (l0243h),hl	    ;16a3   (l0243h)=(l0243h)+1
    call s_0e9dh	    ;16a6   cd 9d 0e
    xor a		    ;16a9
    ld (l02a3h),a	    ;16aa   (l02a3h)=0
    jp l14f4h		    ;16ad   --> ...
;*
;*  Processing EXTERNAL (EXTERNAL name1,...)
;*
PrExternal:
    call PrName		;16b0	Processing name
    call s_0a09h	;16b3	cd 09 0a
    jp l0928h		;16b6	--> Test continue processing statement
;*
;*  call ExtAttr(EntryID); Test hl=(l01c2h)-(EntryID)
;*
s_16b9h:
    ld hl,(EntryID)	;16b9
    push hl		;16bc \ Save (EntryID)
    call ExtAttr	;16bd	Extract Attributes from the symbol table
    pop de		;16c0 / de=(EntryID)
    ld hl,(l01c2h)	;16c1
    call subHL_DE	;16c4	hl=hl-de=(l01c2h)-(EntryID)
    ld a,h		;16c7
    or l		;16c8	Test (l01c2h)-(EntryID)
    ret			;16c9
;*
;*  Processing FORMAT
;*
PrFormat:
    ld hl,(l0263h)	;16ca
    ld a,h		;16cd
    or l		;16ce
    push af		;16cf \ Save Carry status
    call nz,ExtAttr	;16d0	if (l0263h).ne.0 --> Extract Attributes from the symbol table
    pop af		;16d3 / Resrore Carry status
    jp nz,l16deh ;--;	;16d4	if (l0263h).ne.0 --> Skip error message
    call err_msg    ;	;16d7	Warning (15)
    db	15	    ;	;16da	Missing Statement Number on FORMAT
    jp l170fh	  ;-)-; ;16db	--> ...
		    ; ;
l16deh:		;<--+ ;
    ld hl,00000h      ; ;16de	hl=0
    ld (DataID),hl    ; ;16e1	(DataID)=0
    call s_0e27h      ; ;16e4	cd 27 0e
    ld hl,(DatSiz)    ; ;16e7	Load Data size
    ld a,1	      ; ;16ea
    ld (l020bh),a     ; ;16ec	(l020bh)=1
    ld a,(l0261h)     ; ;16ef
    cp 5	      ; ;16f2
    jp c,l16feh ;-;   ; ;16f4	if (l0261h) < 5 --> ...
    ld a,(RomFlg) ;   ; ;16f7 +
    or a	  ;   ; ;16fa + Test /M
    jp z,l1709h ;-)-; ; ;16fb + if (RomFlg).ne.0 --> skip
l16feh:	    ;<----+ ; ;
    ld a,1	    ; ; ;16fe
    ld (RomFlg),a   ; ; ;1700	(RomFlg)=1
    call s_37ceh    ; ; ;1703	Put 'JP word' & word=0000 to REL file
    ld hl,(PrgSiz)  ; ; ;1706	Load Program size
l1709h:		;<--+ ;
    ld (DataID),hl    ; ;1709	(DataID)=
    call PutAttr      ; ;170c	Put Attributes in Symbol table
l170fh:		;<----+
    xor a		;170f	a=0
    push af		;1710	f5
    call g_n_chr	;1711 +
    call s_5a15h	;1714 + Check '('
    ld a,(RomFlg)	;1717 +
    or a		;171a + Test /M
    jp nz,l1727h ;--;	;171b + if (RomFlg).ne.0 --> skip
    ld hl,(DatSiz)  ;	;171e	Load Data size
    ld bc,020bh	    ;	;1721	Address modes DSEG (2), rel type - Set loading location counter (11)
    call s_56deh    ;	;1724	cd de 56
l1727h:	      ;<----+
    ld a,(l0298h)	;1727	a=(l0298h)
    call s_37a8h	;172a + Put constant byte in reg A to REL file
;*
;*  Spacing Specification & Scaling Factor FORMAT
;*
l172dh:
    call s_1818h	;172d	Convert decimal ASCII string to hex
    jp z,l178ch		;1730	ca 8c 17
    ld a,h		;1733	7c
    or l		;1734	b5
    jp nz,l173eh ;--;	;1735	if hl.ne.0 --> Processing FORMAT Field descriptors
    ld a,(l0298h)   ;	;1738	3a 98 02
    jp l17b7h	    ;	;173b	--> ...
		    ;
l173eh:		;<--+
;
;   Processing FORMAT Field descriptors
;
    ld a,(l0298h)	    ;173e
    cp 'H'		    ;1741
    jp z,l17cdh		    ;1743   if (l0298h).eq.'H' --> Hollerith Conversion
    cp 'X'		    ;1746
    jp z,l172dh		    ;1748   if (l0298h).eq.'X' --> Spacing Specification
    cp 'P'		    ;174b
    jp z,l172dh		    ;174d   if (l0298h).eq.'P' --> Scaling Factor
l1750h:
    cp '('		    ;1750
    jp z,l1809h		    ;1752   if a.eq.'(' --> ...
    cp 'E'		    ;1755
    jp z,l17bfh		    ;1757   if a.eq.'E' --> Numeric Conversion
    cp 'F'		    ;175a
    jp z,l17bfh		    ;175c   if a.eq.'F' --> Numeric Conversion
    cp 'A'		    ;175f
    jp z,l1789h ;---;	    ;1761   if a.eq.'A' --> A-Type Conversion
    cp 'I'	    ;	    ;1764
    jp z,l1789h ;---;	    ;1766   if a.eq.'I' --> I-Type Conversion
    cp 'G'	    ;	    ;1769
    jp z,l17bfh	    ;	    ;176b   if a.eq.'G' --> Numeric Conversion
    cp 'D'	    ;	    ;176e
    jp z,l17bfh	    ;	    ;1770   if a.eq.'D' --> Numeric Conversion
    cp 'L'	    ;	    ;1773
    jp z,l1789h ;---;	    ;1775   if a.eq.'L' --> Logical Conversion
l1778h:	      ;<----)-;
    ld a,(RomFlg)   ; ;	    ;1778
    or a	    ; ;	    ;177b   Test /M
    jp nz,l1785h;-; ; ;	    ;177c   if (RomFlg).ne.0 --> Error (126) Illegal Character for Syntax
    ld hl,(l021bh); ; ;	    ;177f   hl=(l021bh)
    call s_56dbh  ; ; ;	    ;1782   cd db 56
l1785h:	      ;<--+ ; ;
    call err_msg    ; ;	    ;1785   Error (126)
    db 126	    ; ;	    ;1788   Illegal Character for Syntax
		    ; ;
l1789h:		;<--+ ;
		      ;
;   Logical & A-Type Conversion FORMAT
		      ;
    call s_1840h      ;	    ;1789   Convert decimal ASCII string to hex
l178ch:	      ;<------)---;
    cp '-'	      ;	  ; ;178c   Test '-'
    jp z,l17b1h ;---; ;	  ; ;178e   ca b1 17
    cp ''''	    ; ;	  ; ;1791   Test ''''
    jp z,l17d1h	 ;--)-)-; ; ;1793   Literal string    trap_ms (017d1h) ***
    cp ','	    ; ; ; ; ;1796   Test ','
    jp z,l172dh	    ; ; ; ; ;1798   Spacing Specification & Scaling Factor
    cp '/'	    ; ; ; ; ;179b   Test '/'
    jp z,l172dh	    ; ; ; ; ;179d   Spacing Specification & Scaling Factor
    cp ')'	    ; ; ; ; ;17a0   Test ')'
    jp z,l17a8h ;-; ; ; ; ; ;17a2   ca a8 17
    jp l1750h	  ; ; ; ; ; ;17a5   --> ...
		  ; ; ; ; ;
l17a8h:	      ;<--+ ; ; ; ;
    pop af	    ; ; ; ; ;17a8 / f1
    dec a	    ; ; ; ; ;17a9   3d
    jp m,l1849h	    ; ; ; ; ;17aa   if < 0 --> ...
    push af	    ; ; ; ; ;17ad   f5
    jp l172dh	    ; ; ; ; ;17ae   --> Spacing Specification & Scaling Factor
		    ; ; ; ;
l17b1h:	      ;<----+ ; ; ;
    call s_1818h      ; ; ; ;17b1   Convert decimal ASCII string to hex
    jp z,l1778h	  ;---; ; ; ;17b4   ca 78 17
l17b7h:		      ; ; ;
    cp 'P'	      ; ; ; ;17b7
    jp nz,l1778h  ;---+ ; ; ;17b9   if end character.ne.'P' --> ...
    jp l172dh		; ; ;17bc   --> Spacing Specification & Scaling Factor
			; ;
;   Numeric Conversion FORMAT
			; ;
l17bfh:			; ;
    call s_1840h	; ; ;17bf   Convert decimal ASCII string to hex
    ld a,'.'		; ; ;17c2
    call ch_chr		; ; ;17c4   Check character (a character for check)
    call s_1840h	; ; ;17c7   Convert decimal ASCII string to hex
    jp nz,l178ch  ;-----)-+ ;17ca   if a.ne.0 --> ...
			;
;   Hollerith Conversion FORMAT
			;
l17cdh:			;
    ld a,1		;   ;17cd   a=1
    ld d,l		;   ;17cf   55				       ???
    db 01h		;   ;17d0   ld bc,0ff3eh (in the original)  trap_ms ***
l17d1h:	      ;<--------+
    ld a,0ffh		    ;17d1
    ld (l01cbh),a	    ;17d3   (l01cbh)=-1
l17d6h:		;<------;
    call s_1a98h	;   ;17d6   cd 98 1a
    jp nz,l17f0h  ;---; ;   ;17d9   c2 f0 17
    ld a,(l01cbh)     ; ;   ;17dc
    inc a	      ; ;   ;17df
    jp nz,l17e9h ;--; ; ;   ;17e0   if (l01cbh).ne.0ffh --> ...
    ld a,''''	    ; ; ;   ;17e3
    call s_37a8h    ; ; ;   ;17e5   Put constant byte in reg A to REL file
    xor a	    ; ; ;   ;17e8   a=0
l17e9h:		;<--+ ; ;
    inc a	      ; ;   ;17e9   a=a+1
    ld (l0173h),a     ; ;   ;17ea   (l0173h)=
    jp l172dh	      ; ;   ;17ed   --> Spacing Specification & Scaling Factor
		      ; ;
l17f0h:		;<----+ ;
    push af		;   ;17f0 \ Save a ---------------------------------;
    push de		;   ;17f1 \					    ;
    call s_37a8h	;   ;17f2   Put constant byte in reg A to REL file  ;
    pop de		;   ;17f5 /					    ;
    ld a,(l01cbh)	;   ;17f6					    ;
    inc a		;   ;17f9					    ;
    pop bc		;   ;17fa / b=a	   <--------------------------------+
    jp nz,l17d6h ;------;   ;17fb   if (l01cbh).ne.-1 --> ...
    ld a,b		;   ;17fe   78
    cp ''''		;   ;17ff
    push de		;   ;1801 \
    call z,s_37a8h	;   ;1802   if b.eq.'''' Put constant byte in reg A to REL file
    pop de		;   ;1805 /
    jp l17d6h	 ;------+   ;1806   --> ...
;
l1809h:
    pop af		    ;1809 / f1
    inc a		    ;180a   3c
    push af		    ;180b \ f5
    cp 3		    ;180c   fe 03
    jp c,l172dh		    ;180e   if < 3 --> Spacing Specification & Scaling Factor
    call err_msg	    ;1811   Warning (18)
    db 18		    ;1814   Format Nest Too Deep
    jp l172dh		    ;1815   --> Spacing Specification & Scaling Factor
;*
;*  Convert decimal ASCII string to hex
;*    EXIT  Reg HL holds number
;*    Accu holds non valid end character
;*
s_1818h:
    xor a		;1818	a=0
    ld b,a		;1819	b=0
    ld h,a		;181a
    ld l,a		;181b	hl=0
l181ch:		;<----;
      push bc	      ; ;181c +
      push hl	      ; ;181d +
      call g_n_chr    ; ;181e + a=chr
      push af	      ; ;1821 +
      call s_37a8h    ; ;1822 + Put constant byte in reg A to REL file
      pop af	      ; ;1825 +
      pop hl	      ; ;1826 +
      pop bc	      ; ;1827 +
      ld c,a	      ; ;1828 + c=chr
      jp p,l183ch ;-; ; ;1829 + if chr Special character or Letter --> exit from loop
      inc b	    ; ; ;182c + b=b+1
      ld d,h	    ; ; ;182d +
      ld e,l	    ; ; ;182e + de=hl
      add hl,hl	    ; ; ;182f + * 2
      add hl,hl	    ; ; ;1830 + * 4
      add hl,de	    ; ; ;1831 + * 5
      add hl,hl	    ; ; ;1832 + * 10
      sub '0'	    ; ; ;1833 + Make binary from ASCII
      ld e,a	    ; ; ;1835 +
      ld d,0	    ; ; ;1836 + de=a
      add hl,de	    ; ; ;1838 + 19  .
    jp l181ch	;---)-+ ;1839 + --> read next character
		    ;
l183ch:	     ;<-----+
    inc b		;183c + b=b+1
    dec b		;183d + b=b-1
    ld a,c		;183e + c=chr
    ret			;183f +
;*
;*  Convert decimal ASCII string to hex
;*
s_1840h:
    call s_1818h	;1840	Convert decimal ASCII string to hex
    ret nz		;1843	if ne 0 return
    call err_msg	;1844	Warning (17)
    db	17		;1847	Zero Format Value
    ret			;1848
;*
l1849h:
    ld a,(RomFlg)	;1849
    or a		;184c	Test /M
    jp nz,l185ch ;--;	;184d	if (RomFlg).ne.0 --> skip
    ld hl,(PrgSiz)  ;	;1850
    ld (DatSiz),hl  ;	;1853	(DatSiz)=(PrgSiz)
    ld hl,(l021bh)  ;	;1856	hl=(l021bh)
    call s_56dbh    ;	;1859	cd db 56
l185ch:		;<--+
    call g_n_chr	;185c +
    ld a,1		;185f	a=1 (DO_Flg)
    jp l259fh		;1861	--> Save (DO_Flg) -> Ending parsing statement
;*
;*  Creation variable T:xxx in a symbol table
;*    ENTRY  Reg  a - (TypeID)
;*
s_1864h:
    ld (TypeID),a	;1864	(TypeID)=
    push af		;1867 \ Save (TypeID)
    ld c,a		;1868
    ld (l01d2h),a	;1869	(l01d2h)=(TypeID)
    ld b,0		;186c	bc=(TypeID)
    ld hl,l543ah	;186e
    ld (l01d5h),hl	;1871	(l01d5h)=":T"
    ld hl,l029ch	;1874
    add hl,bc		;1877	hl=l029ch+(TypeID)
    ld a,(hl)		;1878
    inc (hl)		;1879	(l029ch+(TypeID))=(l029ch+(TypeID))+1
    ld h,a		;187a	67
    ld a,(l029ah)	;187b	3a 9a 02
    ld l,a		;187e	6f
    ld (l01d3h),hl	;187f	(l01d3h)=

    ld a,3		;1882
    ld (KindID),a	;1884	(KindID)=3 (Variable)
    ld a,5		;1887
    ld (SizeID),a	;1889	(SizeID)=5
    call s_055ah	;188c	cd 5a 05
    pop af		;188f / Restore (TypeID)
    ld (TypeID),a	;1890	(TypeID)=
    ld a,2		;1893
    ld (ScopeID),a	;1895	(ScopeID)=2
    jp PutAttr		;1898	--> Put Attributes in Symbol table
;*
;*  Processing PAUSE n, STOP n
;*
PrPause:
    ld hl,l022bh	;189b	Load Pointer to location 1 and 2 bytes statement
    ld c,(hl)		;189e + Loading second character statement
    inc hl		;189f + hl=hl+1
    ld b,(hl)		;18a0 + Loading first character statement
    push bc		;18a1 \ Save first character
    call CrBuilt	;18a2 + Creating built-in routine
    call s_094ah	;18a5 + Initialization field l01d7h 8-byte character ' '
;*
;*  Processing a text string up to 6 characters
;*
    ld b,6		;18a8 + b=6 Length string
    ld hl,l01deh	;18aa + Address of the buffer to hold the string
l18adh:	       ;<---;
      push hl	    ;	;18ad +
      push bc	    ;	;18ae +
      call g_n_chr  ;	;18af +
      pop bc	    ;	;18b2 +
      pop hl	    ;	;18b3 +
      cp cr	    ;	;18b4 +
      jp z,l18c2h ;-)-; ;18b6 + if chr.eq.cr --> exit from loop
      ld (hl),a	    ; ; ;18b9 + (hl)=chr
      dec hl	    ; ; ;18ba + hl=hl-1
      dec b	    ; ; ;18bb + b=b-1
    jp nz,l18adh ;--+ ; ;18bc + if b.ne.0 --> read next character
    call g_n_chr      ; ;18bf +
l18c2h:		 ;<---+
    ld a,(NoCode)	;18c2 +
    or a		;18c5 + Test /N
    jp nz,l18d7h ;--;	;18c6 + if (NoCode).ne.0  --> skip output
    call s_4f46h    ;	;18c9 + if (Column).ne.0 Put cr lf to console
    call s_1465h    ;	;18cc + Print "*****"
    call s_3a70h    ;	;18cf + Put addres DATA' to console
    ld a,tab	    ;	;18d2 +
    call putchr	    ;	;18d4 + Put tab to console
l18d7h:		;<--+
    ld hl,l01dfh	;18d7	21 df 01
    ld b,6		;18da	b=6
l18dch:		;<--;
      dec hl	    ;	;18dc	hl=hl-1
      push hl	    ;	;18dd
      push bc	    ;	;18de
      ld a,(hl)	    ;	;18df	a=(hl)
      call p_byte   ;	;18e0	Put byte in reg A to REL file
      pop bc	    ;	;18e3
      pop hl	    ;	;18e4
      dec b	    ;	;18e5	b=b-1
    jp nz,l18dch ;--+	;18e6	if b.ne.0 --> ...
    pop af		;18e9 / Restore first character
    cp 'P'		;18ea
    jp z,l1b3fh		;18ec + if chr.eq.'P' --> Clear (l0299h) Set (DO_Flg) -> Ending parsing statement
    jp l259ah		;18ef	--> Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*  Reading string length A characters
;*    ENTRY  Reg  a - Number of read characters
;*    EXIT   Reg  a - Last character in the string
;*	     Reg hl - Pointer to last character
;*
GetStr:
    push af		;18f2 + Save # of characters
    ld hl,l01deh	;18f3 + Address of the buffer to hold the string
    push hl		;18f6 +
    call s_094ah	;18f7 + Initialization field l01d7h 8-byte character ' '
l18fah:		;<--;
      call g_n_chr  ;	;18fa +
      pop hl	    ;	;18fd +
      pop bc	    ;	;18fe + Restore # of characters on Reg B
      ld (hl),a	    ;	;18ff + Save read character
      ret c	    ;	;1900 + if chr Special character Return
      dec b	    ;	;1901 + b=b-1
      ret z	    ;	;1902 + if b.eq.0 Return
      dec hl	    ;	;1903 + hl=hl-1
      push bc	    ;	;1904 +
      push hl	    ;	;1905 +
    jp l18fah	;---+	;1906 + --> Read next character
;*
;*  Processing of actual parameters subprogram
;*
s_1909h:
    ld a,(l0298h)	;1909
    sub cr		;190c
    ret z		;190e	if(l0298h).eq.cr Return
    call s_5a15h	;190f	Check '('
    ld b,0		;1912	b=0
    ld hl,(DatSiz)	;1914
    ld (l0295h),hl	;1917	(l0295h)=(DatSiz)
l191ah:		;<----;
      inc b	      ; ;191a	b=b+1
      push bc	      ; ;191b \ Save b ---------------------------;
      push hl	      ; ;191c \ ----------------;		  ;
      call PrName     ; ;191d	Processing name ;		  ;
      pop hl	      ; ;1920 / <---------------+		  ;
      ld (DataID),hl  ; ;1921	(DataID)=			  ;
      inc hl	      ; ;1924					  ;
      inc hl	      ; ;1925					  ;
      push hl	      ; ;1926 \ hl=(DataID)+2 ------------------; ;
      ld a,3	      ; ;1927					; ;
      ld (ScopeID),a  ; ;1929	(ScopeID)=3			; ;
      ld (KindID),a   ; ;192c	(KindID)=3 (Variable)		; ;
      ld hl,(l01cch)  ; ;192f					; ;
      ld (EntryID),hl ; ;1932	(EntryID)=(l01cch)		; ;
      call PutAttr    ; ;1935	Put Attributes in Symbol table	; ;
      ld a,(l0298h)   ; ;1938					; ;
      cp ','	      ; ;193b	Test separator ','		; ;
      pop hl	      ; ;193d / Restore hl    <-----------------+ ;
      pop bc	      ; ;193e / Restore b <-----------------------+
    jp z,l191ah	 ;----+ ;193f	if (l0298h).eq.',' Found next argument
    push bc		;1942 \ ----------------;
    ld (DatSiz),hl	;1943	Save Data size	;
    call s_4e59h	;1946	cd 59 4e	;
    pop af		;1949 / <---------------+
    ld (NumArg),a	;194a	Save Number of arguments to transfer
    ret			;194d
;*
;*  Get next chatacter
;*
g_n_chr:
    ld a,(l0173h)	;194e +
    or a		;1951 +
    ld a,(l0298h)	;1952 ? load character
    jp nz,l196fh ;----; ;1955 + if (l0173h).ne.0 skip convert to upper case
l1958h:	      ;<----; ;
      call s_19a2h  ; ; ;1958 + Parsing source line
      cp ' '	    ; ; ;195b +
    jp z,l1958h ;---+ ; ;195d + Skip blank
		      ;
;   Convert character to upper case
		      ;
    cp 'a'	      ; ;1960 + Test range
    jp c,l196fh	 ;----; ;1962 + if < 'a'
    cp 'z'+1	      ; ;1965 +
    jp nc,l196fh ;----; ;1967 + if >= "{"
    sub 'a'-'A'	      ; ;196a + Convert to upper case
    ld (l0298h),a     ; ;196c + Saving the converted character
		      ;
l196fh:		;<----+

;   Test valid letter

    cp '$'		;196f	Test $
    jp z,l198fh ;-----; ;1971	if a.eq.'$'		trap_ms2 (0198fh) ***
    cp 'A'	      ; ;1974	Test start A..Z
    jp c,l197eh ;-;   ; ;1976	if a < 'A'
    cp 'Z'+1	  ;   ; ;1979	Verify letter
    jp c,l198fh ;-)---; ;197b	if a < 'Z'+1		trap_ms2 (0198fh) ***
l197eh:	      ;<--+   ;
    cp '0'	      ; ;197e	Test special characters
    jp c,l1988h ;---; ; ;1980	if a < '0'		trap_ms2 (01988h) ***
    cp '9'+1	    ; ; ;1983	Test digits
    jp c,l198ch ;-; ; ; ;1985	if a < '9'+1		trap_ms2 (0198ch) ***
;		  ; ; ;
; Char A..Z, $	  ; ; ;
l1988h:	      ;<--)-+ ;			  Equivalent  Original
    xor a	  ;   ; ;1988		    xor a	xor a
    inc a	  ;   ; ;1989	a=1	    inc a	inc a
    scf		  ;   ; ;198a	Set carry   scf		scf
    db 1	  ;   ; ;198b ;-----------  jp t1990h	ld bc,03dafh	trap_ms2
l198ch:	    ;<----+   ;	      ;
    xor a	      ; ;198c ;		    xor a
    dec a	      ; ;198d ; a=-1	    dec a
    db 6	      ; ;198e ;-----------  jp t1990h	ld b,0afh	trap_ms2
l198fh:		;<----+	      ;
    xor a		;198f ; a=0	    xor a
t1990h:	    ;<----------------+
    ld a,(l0298h)	;1990	Load character
    ld b,a		;1993	Save value
    push af		;1994 \
    ld hl,l0173h	;1995
    ld a,(hl)		;1998	a=(l0173h)
    ld (hl),0		;1999	(l0173h)=0
    or a		;199b
    ld a,b		;199c	Restore value
    call z,s_4aa2h	;199d	if((l0173h).eq.0) Move 19 bytes from l02b5h to l02b4h
    pop af		;19a0 /
    ret			;19a1
;*
;*  Parsing source line
;*
s_19a2h:
l19a2h:		 ;<----;
    ld hl,PosStm       ; ;19a2
    ld e,(hl)	       ; ;19a5
    inc (hl)	       ; ;19a6	(PosStm)=(PosStm)+1
    ld hl,l0108h       ; ;19a7	Point to source line
    ld d,0	       ; ;19aa
    add hl,de	       ; ;19ac
    ld a,(hl)	       ; ;19ad
    cp cr	       ; ;19ae	Test end of line
    jp z,l19b7h ;--;   ; ;19b0	if (l0108h+(PosStm)).eq.cr --> ...
l19b3h:	     ;<----)-; ;
    ld (l0298h),a  ; ; ; ;19b3	(l0298h)=(l0108h+(PosStm)) or 0dh(cr) or 2fh('/')
    ret		   ; ; ; ;19b6
		   ; ; ;
l19b7h:	      ;<---+ ; ;
    ld a,(l01ceh)    ; ; ;19b7
    or a	     ; ; ;19ba
    ld a,'/'	     ; ; ;19bb
    jp nz,l19b3h ;---+ ; ;19bd	if (l01ceh).ne.0 { a='/' --> ...}
s_19c0h:	     ; ;
l19c0h:	       ;<--; ; ;
    call s_4e64h   ; ; ; ;19c0	Print source line
    ld de,l0108h   ; ; ; ;19c3	Point to source line
    ld a,(de)	   ; ; ; ;19c6
    cp 'C'	   ; ; ; ;19c7
    jp z,l19c0h	 ;-; ; ; ;19c9	if (l0108h).eq.'C' --> ...
    cp 'c'	   ; ; ; ;19cc
    jp z,l19c0h	 ;-+ ; ; ;19ce	if (l0108h).eq.'c' --> ...
    ld hl,PosStm     ; ; ;19d1
    ld (hl),6	     ; ; ;19d4	(PosStm)=6
    ld de,l010dh     ; ; ;19d6	Point to Continuation character field
    ld a,(de)	     ; ; ;19d9	Load character
    and 0efh	     ; ; ;19da	11101111b
    cp ' '	     ; ; ;19dc	Test valid Continuation character
    jp nz,l19a2h  ;--)-+ ;19de	if (l010dh).ne.(' '.or.'0') Found chr Continuation Line
    ld (hl),0	     ;	 ;19e1	(PosStm)=0
    ld a,cr	     ;	 ;19e3	a=cr
    jp l19b3h	;----+	 ;19e5	--> ...
;*
;*  Processing subscript an array
;*
s_19e8h:
    ld a,(KindID)	;19e8
    cp 3		;19eb
    jp z,l19f4h ;---;	;19ed	if (KindID).eq.3 (Variable) --> Skip error message
    call err_msg    ;	;19f0	Warning (3)
    db 3	    ;	;19f3	Array Name Misuse
l19f4h:		;<--+
    ld hl,(l01cch)	;19f4
    push hl		;19f7 \ Save (l01cch)
    call DimDecl	;19f8	Processing Dimension declarators
    ld a,1		;19fb
    ld (KindID),a	;19fd	(KindID)=1 (Constant)
    ld a,7		;1a00	a=7
    ld (TypeID),a	;1a02	(TypeID)=7
    ld a,(NumDim)	;1a05
    ld (ScopeID),a	;1a08	(ScopeID)=(NumDim)
    rlca		;1a0b	Multiply by 2
    ld (SizeID),a	;1a0c	(SizeID)=(ScopeID)*2
    ld hl,(l026fh)	;1a0f
    ld (l01d5h),hl	;1a12	(l01d5h)=(l026fh)
    ld hl,(l0271h)	;1a15
    ld (l01d3h),hl	;1a18	(l01d3h)=(l0271h)
    ld hl,(l0273h)	;1a1b
    ld (l01d1h),hl	;1a1e	(l01d1h)=(l0273h)
    ld hl,(l0206h)	;1a21
    ld (l021dh),hl	;1a24	(l021dh)=(l0206h)
    ld (l01cch),hl	;1a27	(l01cch)=(l0206h)
    call s_04e9h	;1a2a	cd e9 04
    call PutAttr	;1a2d	Put Attributes in Symbol table
    pop hl		;1a30 / hl=(l01cch)
    call ExtAttr	;1a31	Extract Attributes from the symbol table
    ld a,4		;1a34
    ld (KindID),a	;1a36	(KindID)=4 (Array)
    call PutAttr	;1a39	Put Attributes in Symbol table
    jp s_4647h		;1a3c	--> Extract Attributes from the symbol table, entry (l01cch)
;*
;*  Processing IF(e) m1,m2,m3 or IF(u) s
;*
PrIf:
    ld a,1		;1a3f	a=1
    call s_14dbh	;1a41	cd db 14
    call s_1472h	;1a44	cd 72 14
    call g_n_chr	;1a47
    ld hl,PosStm	;1a4a
    jp m,l1a68h	  ;---; ;1a4d	if chr Digit --> Arithmetic IF
		      ;
;   Logical IF	      ;
		      ;
    dec (hl)	      ; ;1a50	(PosStm)=(PosStm)-1
    ld a,020h	      ; ;1a51
    ld (l02c7h),a     ; ;1a53	(l02c7h)=020h
    ld a,(l021fh)     ; ;1a56
    or a	      ; ;1a59
    jp z,l1a61h ;---; ; ;1a5a	if (l021fh).eq.0 --> Skip error message
    call err_msg    ; ; ;1a5d	Error (135)
    db 135	    ; ; ;1a60	Illegal Statement Following Logical IF
l1a61h:		;<--+ ;
    inc a	      ; ;1a61
    ld (l021fh),a     ; ;1a62	(l021fh)=(l021fh)+1
    jp l58beh	      ; ;1a65	--> ...
		      ;
;   Arithmetic IF     ;
		      ;
l1a68h:	       ;<-----+
    dec (hl)		;1a68	(PosStm)=(PosStm)-1
    ld a,020h		;1a69
    ld (l02c7h),a	;1a6b	(l02c7h)=20h
    call s_3169h	;1a6e	cd 69 31
    call s_3725h	;1a71	cd 25 37
    call s_218ch	;1a74	Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cch)	;1a77
    ld (l020ch),hl	;1a7a	(l020ch)=(l01cch)
    call ChComma	;1a7d	Check ','
    call s_218ch	;1a80	Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cch)	;1a83
    ld (l020eh),hl	;1a86	(l020eh)=(l01cch)
    call ChComma	;1a89	Check ','
    call s_218ch	;1a8c	Processing label & Test (TypeID).eq.INTEGER
    ld hl,(l01cch)	;1a8f
    ld (l0210h),hl	;1a92	(l0210h)=(l01cch)
    jp l259ah		;1a95	--> Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_1a98h:
    ld a,(l01cbh)	;1a98
    dec a		;1a9b
    jp nz,l1aa4h ;--;	;1a9c	if (l01cbh).ne.1 --> ...
    or d	    ;	;1a9f	b2
    jp z,l1ad3h ;---)-; ;1aa0	ca d3 1a
    dec d	    ; ; ;1aa3	15
l1aa4h:		;<--+ ;
    push de	      ; ;1aa4 \
    call s_19a2h      ; ;1aa5	Parsing source line
    call s_4aa2h      ; ;1aa8	Move 19 bytes from l02b5h to l02b4h
    pop de	      ; ;1aab /
    cp cr	      ; ;1aac
    jp z,err123	      ; ;1aae	if cr --> Error (123) Illegal Hollerith Construction
    sub ''''	      ; ;1ab1
    jp z,l1ab9h ;-;   ; ;1ab3	if eq '''' --> ...
l1ab6h:	     ;<---)-; ;
    ld a,c	  ; ; ; ;1ab6	79
    or a	  ; ; ; ;1ab7	b7
    ret		  ; ; ; ;1ab8
		  ; ; ;
l1ab9h:	      ;<--+ ; ;
    ld a,(l01cbh)   ; ; ;1ab9
    dec a	    ; ; ;1abc
    jp z,l1ab6h ;---; ; ;1abd	if (l01cbh).eq.0ffh --> ...
    push de	    ; ; ;1ac0 \
    call s_19a2h    ; ; ;1ac1	Parsing source line
    call s_4aa2h    ; ; ;1ac4	Move 19 bytes from l02b5h to l02b4h
    pop de	    ; ; ;1ac7 /
    sub ''''	    ; ; ;1ac8
    jp z,l1ab6h ;---+ ; ;1aca	if eq '''' --> ...
    ld a,c	      ; ;1acd
    sub 20h	      ; ;1ace
    jp nz,l1ad8h ;--; ; ;1ad0	if c.ne.' ' --> ...
l1ad3h:	      ;<----)-+
    push de	    ;	;1ad3 \
    call g_n_chr    ;	;1ad4	Get next character
    pop de	    ;	;1ad7 /
l1ad8h:		;<--+
    xor a		;1ad8	a=0
    ret			;1ad9
;
err123:
    call err_msg	;1ada	Error (123)
    db 123		;1add	Illegal Hollerith Construction
;
;
;
s_1adeh:
    xor a			;1ade	a=0
    push af			;1adf \
l1ae0h:			;<--;
      call g_n_chr	    ;	;1ae0 +
      jp p,l1b11h ;-----;   ;	;1ae3 + if chr Special character or Letter --> ...
      sub '0'		;   ;	;1ae6 + Make binary from ASCII
l1ae8h:		    ;<--)-; ;
      ld e,a		; ; ;	;1ae8	5f
      ld a,(l01d6h)	; ; ;	;1ae9	3a d6 01
      and 0f0h		; ; ;	;1aec	11110000b
      jp z,l1affh ;---; ; ; ;	;1aee	ca ff 1a
      pop af	      ; ; ; ;	;1af1 /
      jp nz,l1afeh;-; ; ; ; ;	;1af2	c2 fe 1a			trap_ms (01afeh) ***
      inc a	    ; ; ; ; ;	;1af5	a=a+1
      push af	    ; ; ; ; ;	;1af6 \ f5
      push de	    ; ; ; ; ;	;1af7 \ ------------------------;
      call err_msg  ; ; ; ; ;	;1af8	Warning (29)		;
      db 29	    ; ; ; ; ;	;1afb	Hex Constant Overflow	;
      pop de	    ; ; ; ; ;	;1afc / <-----------------------+
      db 6	    ; ; ; ; ;	;1afd	ld b,0f5h (in the original)	trap_ms ***
l1afeh:		;<--+ ; ; ; ;
      push af	      ; ; ; ;	;1afe \
l1affh:	      ;<------+ ; ; ;
      ld d,4		; ; ;	;1aff	d=4
l1b01h:		  ;<-;	; ; ;
	call s_208bh ;	; ; ;	;1b01	cd 8b 20
	dec d	     ;	; ; ;	;1b04	d=d-1
      jp nz,l1b01h ;-+	; ; ;	;1b05	if d.ne.0 next step
      ld hl,l01cfh	; ; ;	;1b08	21 cf 01
      ld a,(hl)		; ; ;	;1b0b	7e
      or e		; ; ;	;1b0c	b3
      ld (hl),a		; ; ;	;1b0d	77
    jp l1ae0h	;-------)-)-+	;1b0e	--> get hext character
;			; ;
l1b11h:	     ;<---------+ ;
    cp 'A'		  ;	;1b11	Test start A..Z
    jp c,l1b1dh ;---;	  ;	;1b13	if < 'A' --> ...
    sub 037h	    ;	  ;	;1b16	d6 37
    cp 16	    ;	  ;	;1b18	fe 10
    jp c,l1ae8h	  ;-)-----+	1b1a	if < 16 --> ...
l1b1dh:		;<--+
    pop af			;1b1d / f1
    ld a,''''			;1b1e
    call ch_chr			;1b20	Check character (a character for check)
    jp g_n_chr			;1b23 + --> ...
;
;   Processing integer constant with test (KindID)=Constant
;
s_1b26h:
    call s_2593h	;1b26	Processing integer constant with error checking
    ld a,(KindID)	;1b29
    dec a		;1b2c
    ret z		;1b2d	if (KindID).eq.1 (Constant) Return
    call err_msg	;1b2e	Error (109)
    db 109		;1b31	Incorrect Integer Constant
;
;+  Clear buffer ^l02b4h length 20
;
s_1b32h:
    ld a,014h		;1b32 + a=20 - Length cleaned area
    ld hl,l02b4h	;1b34 + Starting address buffer
l1b37h:		  ;<--;
      ld (hl),' '     ; ;1b37 + (hl)=' '
      inc hl	      ; ;1b39 + hl=hl+1
      dec a	      ; ;1b3a + a=a-1
    jp nz,l1b37h ;----+ ;1b3b + if a.ne.0 --> clear next cell
    ret			;1b3e +
;
;+  Clear (l0299h) Set (DO_Flg) -> Ending parsing statement
;
l1b3fh:
    xor a		;1b3f +
    ld (l0299h),a	;1b40 + (l0299h)=0
    inc a		;1b43 + a=1 (DO_Flg)
    jp l259fh		;1b44 + --> Save (DO_Flg) -> Ending parsing statement
;
;   Processing IMPLICIT (IMPLICIT type(range),...)
;
PrImpicit:
    call s_1beah	 ;1b47 + Parsing type definitions from IMPLICIT
    push af		 ;1b4a + Save ID_Type variable
    call g_n_chr	 ;1b4b +
    call s_5a15h	 ;1b4e + Check '('
;
;   Pprocessing a single or range alphabetic characters (for example, A or W-Z)
;
l1b51h:
    call g_n_chr	 ;1b51 +
    jp m,err126		 ;1b57 + if chr Digit --> Error (126) Illegal Character for Syntax
    jp c,l1b9dh	 ;-----; ;1b57 + if chr Special character --> Expected symbol ')'
    sub 'A'	       ; ;1b5a + Calculation of the index
    ld c,a	       ; ;1b5c +
    ld b,0	       ; ;1b5d + bc=a
    ld hl,tTypDef      ; ;1b5f + hl=Pointer table type definitions variables
    add hl,bc	       ; ;1b62 + Calculation position in the table
    push hl	       ; ;1b63 \ Save position in the table
    call g_n_chr       ; ;1b64 +
    cp '-'	       ; ;1b67 + Test delimiter range
    pop de	       ; ;1b69 / Restore position in the table in DE
    ld h,d	       ; ;1b6a +
    ld l,e	       ; ;1b6b + hl=de
    jp nz,l1b8bh ;---; ; ;1b6c + if chr.ne.'-' --> Delimiter range not found
    push de	     ; ; ;1b6f \ save de
    call g_n_chr     ; ; ;1b70 +
    jp nz,err126     ; ; ;1b73 + if chr Special character or Digit --> Error (126) Illegal Character for Syntax
    push af	     ; ; ;1b76 \
    call g_n_chr     ; ; ;1b77 ? Skip chr
    pop af	     ; ; ;1b7a /
    sub 'A'	     ; ; ;1b7b + Calculation of the index from previous chr
    ld c,a	     ; ; ;1b7d +
    ld b,0	     ; ; ;1b7e + bc=a
    ld hl,tTypDef    ; ; ;1b80 + hl=Pointer table type definitions variables
    add hl,bc	     ; ; ;1b83 + Calculation position in the table
    pop de	     ; ; ;1b84 / Restore de
    call cmpHL_DE    ; ; ;1b85 + Compare HL with DE
    jp c,err126	     ; ; ;1b88 + if HL < DE --> Error (126) Illegal Character for Syntax
l1b8bh:		;<---+ ;
t1b8bh:		;<---; ;
      pop af	     ; ; ;1b8b / Restore ID_Type
      ld (de),a	     ; ; ;1b8c + (de)=ID_Type
      push af	     ; ; ;1b8d \ Save ID_Type
      call cmpHL_DE  ; ; ;1b8e + Compare HL with DE
      inc de	     ; ; ;1b91 + de=de+1
    jp nz,t1b8bh ;---+ ; ;1b92 + if HL.ne.DE --> Next step
    ld a,(l0298h)      ; ;1b95 ?
    cp ','	       ; ;1b98 +
    jp z,l1b51h	       ; ;1b9a + if (l0298h).eq.',' (found separator) --> Pprocessing next a single or range alphabetic characters
l1b9dh:		   ;<--+	 Expected symbol ')'
    cp ')'		 ;1b9d +
    jp nz,err126	 ;1b9f + if (l0298h).ne.')' --> Error (126) Illegal Character for Syntax
    pop af		 ;1ba2 + balance stack after exit from loop
    call g_n_chr	 ;1ba3 +
    cp ','		 ;1ba6 + Test separator
    jp z,PrImpicit	 ;1ba8 + if chr.eq.',' (found separator) --> Processing next IMPLICIT
    ld hl,(l031ch)	 ;1bab	 hl=[fa66]
    call ExtAttr	 ;1bae	 Extract Attributes from the symbol table
l1bb1h:		;<-----;
    cp 3	       ; ;1bb1
    jp c,l1bcfh ;----; ; ;1bb3	 if a < 3 --> ...
    ld a,(ScopeID)   ; ; ;1bb6
    cp 2	     ; ; ;1bb9
    jp z,l1bc3h ;--; ; ; ;1bbb	 if (ScopeID).eq.2 --> ...
    cp 3	   ; ; ; ;1bbe
    jp nz,l1bcfh ;-)-; ; ;1bc0	 if (ScopeID).ne.3 --> ...
l1bc3h:	      ;<---+ ; ;
    ld a,(l01d6h)    ; ; ;1bc3	 3a d6 01
    call GetTypV     ; ; ;1bc6	 Get value type variables
    ld (TypeID),a    ; ; ;1bc9	 Save value type variable
    call PutAttr     ; ; ;1bcc	 Put Attributes in Symbol table
l1bcfh:		;<---+ ;
    call s_59f4h       ; ;1bcf	 Calculate address next symbol in the Symbols table; if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp nc,l1bb1h ;-----+ ;1bd2	 if (l0206h) < (l01cch) --> ...
    jp l09e4h		 ;1bd5 + --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;
;+  Get value type definitions variables
;     ENTRY Reg A first character of the name
;     EXIT  Reg A value type definitions variables
;
GetTypV:
    cp '$'		 ;1bd8 + Test '$' (indication System variable names)
    jp nz,FrTable ;----; ;1bda + if a.ne.'$' Get value from table
    xor a	       ; ;1bdd + a=0 (INTEGER)
    ret		       ; ;1bde +
		       ;
; Get value from table ;
		       ;
FrTable:	 ;<----+
    ld hl,tTypDef	 ;1bdf + hl=Pointer table type definitions variables
    sub 'A'		 ;1be2 + Calculation of the index
    ld e,a		 ;1be4 +
    ld d,0		 ;1be5 + de=a
    add hl,de		 ;1be7 + Calculation position in the table
    ld a,(hl)		 ;1be8 + Get value
    ret			 ;1be9 +
;
;+  Parsing type definitions from IMPLICIT
;
;     EXIT Reg A - ID_Type:
;	0 - INTEGER, INTEGER*2 or System variable names
;	1 - REAL, REAL*4
;	2 - LOGICAL, BYTE
;	3 - DOUBLE PRECISION, REAL*8
;	4 - INTEGER*4
;
s_1beah:
    call g_n_chr	;1bea +
    jp nz,err126	;1bed + if chr Special character or Digit --> Error (126) Illegal Character for Syntax
    cp 'B'		;1bf0 + test 'B'
    ld hl,l02efh	;1bf2 + hl=bYTE
    jp z,l1c18h	 ;--;	;1bf5 + .. yeap
    ld hl,l02f4h    ;	;1bf8 + hl=iNTEGER
    cp 'I'	    ;	;1bfb + test 'I'
    jp z,l1c18h	 ;--;	;1bfd + .. yeap
    ld hl,l02fch    ;	;1c00 + hl=dOUBLEPRECISION
    cp 'D'	    ;	;1c03 + test 'D'
    jp z,l1c18h	 ;--;	;1c05 + .. yeap
    ld hl,l030ch    ;	;1c08 + hl=lOGICAL
    cp 'L'	    ;	;1c0b + test 'L'
    jp z,l1c18h	 ;--;	;1c0d + .. yeap
    cp 'R'	    ;	;1c10 + test 'R'
    jp nz,err126    ;	;1c12 + .. nope --> Error (126) Illegal Character for Syntax
    ld hl,l0314h    ;	;1c15 + .. yeap hl=rEAL
		    ;
;   Found types BYTE, INTEGER, DOUBLE PRECISION, REAL, LOGICAL or REAL
		    ;
l1c18h:		;<--+
    ld b,(hl)		;1c18 + Load Length string
    inc hl		;1c19 + Update pointer
l1c1ah:		;<--;
      push bc	    ;	;1c1a +
      push hl	    ;	;1c1b +
      call g_n_chr  ;	;1c1c +
      pop hl	    ;	;1c1f +
      pop bc	    ;	;1c20 +
      cp (hl)	    ;	;1c21
      jp nz,err126  ;	;1c22 + if chr.ne.byte from string --> Error (126) Illegal Character for Syntax
      inc hl	    ;	;1c25 + hl=hl+1
      dec b	    ;	;1c26 + b=b-1
    jp nz,l1c1ah ;--+	;1c27 + if b.ne.0 --> Get next character
    ld a,(hl)		;1c2a + Load ID_Type
    cp 3		;1c2b +
    ret z		;1c2d + if ID_Type.eq.3 (DOUBLE PRECISION, REAL*8) Return
    push af		;1c2e \ Save ID_Type
    call g_n_chr	;1c2f +
    cp '*'		;1c32 +
    jp z,l1c3ch	 ;--;	;1c34 + if chr.eq.'*' --> Processing size specifier
    ld (l0173h),a   ;	;1c37 + (l0173h)=chr
    pop af	    ;	;1c3a / Restore ID_Type
    ret		    ;	;1c3b
l1c3ch:		;<--+		Processing size specifier
    call g_n_chr	;1c3c +
    jp p,err126		;1c3f + if chr Special character or Letter --> Error (126) Illegal Character for Syntax
    sub '0'		;1c42	Make binary Size_storage in bytes variable or array element
    ld b,a		;1c44 + Save value Size_storage
    pop af		;1c45 / Restore ID_Type
    dec a		;1c46
    ld a,b		;1c47 + Restore value Size_storage
    jp z,l1c5bh ;---;	;1c48 + if ID_Type.eq.1 (REAL) --> ...
    dec a	    ;	;1c4b +
    jp z,l1c58h ;-; ;	;1c4c	if Size_storage.eq.1 --> ...
    dec a	  ; ;	;1c4f +
    ret z	  ; ;	;1c50	if Size_storage.eq.2 Return (a=0 INTEGER, INTEGER*2)
    ld a,b	  ; ;	;1c51 + restore value Size_storage
    cp 4	  ; ;	;1c52 +
    ret z	  ; ;	;1c54	if Size_storage.eq.4 return (a=4 INTEGER*4)
    jp err126	  ; ;	;1c55 + --> Error (126) Illegal Character for Syntax
l1c58h:	    ;<----+ ;
    ld a,2	    ;	;1c58 + a=2 (LOGICAL, BYTE)
    ret		    ;	;1c5a + Return
l1c5bh:		;<--+
    cp 4		;1c5b +
    ld a,1		;1c5d + a=1 (REAL)
    ret z		;1c5f + if Size_storage.eq.4 Return
    ld a,b		;1c60 + Restore value Size_storage
    cp 8		;1c61 +
    ld a,3		;1c63 + a=3 (DOUBLE PRECISION, REAL*8)
    ret z		;1c65 + if Size_storage.eq.8 Return
    jp err126		;1c66 + --> Error (126) Illegal Character for Syntax
;
;   Processing INCLUDE <filename>
;
PrInclude:
    ld a,1		;1c69	a=1
    ld (inclfl),a	;1c6b	(l01ceh)=1 Set include flag
    ld hl,IncBuf	;1c6e	21 7b 01
    ld b,028h		;1c71	06 28
l1c73h:		;<--;
      push bc	    ;	;1c73 +
      push hl	    ;	;1c74 +
      call g_n_chr  ;	;1c75 +
      pop hl	    ;	;1c78 +
      pop bc	    ;	;1c79 +
      cp '/'	    ;	;1c7a
      jp z,l1c85h ;-)-; ;1c7c	if chr.eq '/' --> ...
      ld (hl),a	    ; ; ;1c7f	77
      inc hl	    ; ; ;1c80	hl=hl+1
      dec b	    ; ; ;1c81	b=b-1
    jp nz,l1c73h ;--+ ; ;1c82	c2 73 1c
l1c85h:		;<----+
    ld (hl),020h	;1c85	36 20
    ld hl,IncBuf	;1c87	21 7b 01
    call s_669ah	;1c8a	call ret  (?Prepare include file?)
    or a		;1c8d		  (?Test success?)
    jp nz,err137	;1c8e	if a.ne.0 --> Error: File Not Found
    xor a		;1c91
    ld (inclfl),a	;1c92	(l01ceh)=0 Clear include flag
    inc a		;1c95
    ld (incflg),a	;1c96	(incflg)=1
    call s_19c0h	;1c99	cd c0 19
    jp l09e4h		;1c9c	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*  Processing name
;*
PrName:
    call s_1ca9h	;1c9f	cd a9 1c
    cp 3		;1ca2
    ret nc		;1ca4	if (KindID) > 3 (Variable) Return
    call err_msg	;1ca5	Error (105)
    db 105		;1ca8	Missing Name
;*
;*  EXIT reg A:
;*    0 - ?
;*    1 - Constant
;*    2 - Label
;*    3 - Variable
;*    4 - Array Name
;*
s_1ca9h:
    call s_1cb5h	;1ca9	cd b5 1c
s_1cach:
    or a		;1cac	b7
    call nz,s_055ah	;1cad	c4 5a 05
    ld a,(KindID)	;1cb0
    or a		;1cb3	Test (KindID)
    ret			;1cb4
;
;
;
s_1cb5h:
    xor a		    ;1cb5   a=0
    ld (KindID),a	    ;1cb6   (KindID)=0
    ld (l0242h),a	    ;1cb9   (l0242h)=0
    ld (l01cbh),a	    ;1cbc   (l01cbh)=0
    ld l,a		    ;1cbf
    ld h,a		    ;1cc0   hl=0
    ld (l0277h),hl	    ;1cc1   (l0277h)=0
    ld (l0279h),hl	    ;1cc4   (l0279h)=0
    call s_093ah	    ;1cc7   (l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
l1ccah:
    xor a		    ;1cca
    ld (TypeID),a	    ;1ccb   (TypeID)=0 (INTEGER)
l1cceh:		;<------;
    call g_n_chr	;   ;1cce +
    jp m,l1dd7h		;   ;1cd1 + if Digit --> ...
    ld c,a		;   ;1cd4 + Save chr
    rra			;   ;1cd5   1f
    ld b,a		;   ;1cd6   47
    ld a,(TypeID)	;   ;1cd7
    or a		;   ;1cda
    jp nz,l1e08h ;------)-; ;1cdb   if (TypeID).ne.0 (INTEGER) --> ...
    ld (l0279h),a	; ; ;1cde   (l0279h)=(TypeID)
    inc a		; ; ;1ce1
    ld (TypeID),a	; ; ;1ce2   (TypeID)=(TypeID)+1 (REAL)
    ld a,4		; ; ;1ce5
    ld (SizeID),a	; ; ;1ce7   (SizeID)=4
    ld a,c		; ; ;1cea + Restore chr
    cp '.'		; ; ;1ceb
    jp z,l1eb3h		; ; ;1ced   if chr.eq.'.' --> ...
    ld a,(KindID)	; ; ;1cf0
    or a		; ; ;1cf3
    jp nz,l1f21h	; ; ;1cf4   if (KindID).ne.0  --> ...
    ld a,c		; ; ;1cf7 + Restore chr
    sub 027h		; ; ;1cf8
    jp nz,l1d0ah ;--;	; ; ;1cfa   if chr.ne.'''' --> ...
    ld (TypeID),a   ;	; ; ;1cfd   Save value type variable
    dec a	    ;	; ; ;1d00   a=a-1
    ld (l01cbh),a   ;	; ; ;1d01   (l01cbh)=(TypeID)-1
    ld a,1	    ;	; ; ;1d04
    ld (KindID),a   ;	; ; ;1d06   (KindID)=1 (Constant)
    ret		    ;	; ; ;1d09
		    ;	; ;
l1d0ah:		;<--+	; ;
    ld a,(l0277h)	; ; ;1d0a
    or a		; ; ;1d0d
    jp nz,l1dcbh	; ; ;1d0e   if (l0277h).ne.0 --> ...
    ld a,(l0259h)	; ; ;1d11
    or a		; ; ;1d14
    jp z,l1d23h	 ;--;	; ; ;1d15   if (l0259h).eq.0 --> ...
    ld a,c	    ;	; ; ;1d18   Restore chr
    cp '+'	    ;	; ; ;1d19
    jp z,l1dc5h	    ;	; ; ;1d1b   if chr.eq.'+' --> ...
    cp '-'	    ;	; ; ;1d1e
    jp z,l1dc5h	    ;	; ; ;1d20   if chr.eq.'-' --> ...
l1d23h:		;<--+	; ;
    ld a,b		; ; ;1d23   78
    rla			; ; ;1d24   17
    jp c,l1d99h		; ; ;1d25   da 99 1d
    ld a,c		; ; ;1d28   Restore chr
    cp 'Z'		; ; ;1d29
    jp z,l1d33h	 ;--;	; ; ;1d2b   if chr.eq.'Z' --> ...
    cp 'X'	    ;	; ; ;1d2e
    jp nz,l1d6ch ;--)-; ; ; ;1d30   if chr.ne.'X' --> ...
l1d33h:		;<--+ ; ; ;
    push bc	      ; ; ; ;1d33 \
    call g_n_chr      ; ; ; ;1d34 +
    pop bc	      ; ; ; ;1d37 /
    cp ''''	      ; ; ; ;1d38
    jp nz,l1d69h ;--; ; ; ; ;1d3a   if chr.ne.'''' --> ...
    call s_1adeh    ; ; ; ; ;1d3d   cd de 1a
    ld hl,(l01d3h)  ; ; ; ; ;1d40   2a d3 01
    ld a,h	    ; ; ; ; ;1d43   7c
    or l	    ; ; ; ; ;1d44   b5
    ld hl,(l01d5h)  ; ; ; ; ;1d45   2a d5 01
    or h	    ; ; ; ; ;1d48   b4
    or l	    ; ; ; ; ;1d49   b5
    jp nz,l1e22h    ; ; ; ; ;1d4a   c2 22 1e
    ld hl,(l01cfh)  ; ; ; ; ;1d4d
    ld (l01d3h),hl  ; ; ; ; ;1d50   (l01d3h)=(l01cfh)
    ld hl,(l01d1h)  ; ; ; ; ;1d53
    ld (l01d5h),hl  ; ; ; ; ;1d56   (l01d5h)=(l01d1h)
    xor a	    ; ; ; ; ;1d59
    ld (TypeID),a   ; ; ; ; ;1d5a   (TypeID)=0 (INTEGER)
    inc a	    ; ; ; ; ;1d5d
    ld (KindID),a   ; ; ; ; ;1d5e   (KindID)=1 (Constant)
    ld a,4	    ; ; ; ; ;1d61
    ld (SizeID),a   ; ; ; ; ;1d63   (SizeID)=4
    jp l1d99h	    ; ; ; ; ;1d66   --> ...
		    ; ; ; ;
l1d69h:		 ;<-+ ; ; ;
    ld (l0173h),a     ; ; ; ;1d69   (l0173h)=
l1d6ch:	     ;<-------+ ; ;
    ld a,c		; ; ;1d6c   79
    call GetTypV	; ; ;1d6d   Get value type variables
    ld (TypeID),a	; ; ;1d70   Save value type variable
    ld a,3		; ; ;1d73
    ld (KindID),a	; ; ;1d75   (KindID)=3 (Variable)
    ld b,-7		; ; ;1d78 + b = -7
    ld hl,l01d6h	; ; ;1d7a + 21 d6 01
    ld a,c		; ; ;1d7d   79
l1d7eh:		;<---;	; ;
      inc b	     ;	; ; ;1d7e + b=b+1
      jp z,err117    ;	; ; ;1d7f + if b.eq.0 --> Error (117) Identifier Too Long
      ld (hl),a	     ;	; ; ;1d82 + 77
      dec hl	     ;	; ; ;1d83 + hl=hl-1
      push hl	     ;	; ; ;1d84 \
      push bc	     ;	; ; ;1d85 \
      call g_n_chr   ;	; ; ;1d86 +
      pop bc	     ;	; ; ;1d89 /
      pop hl	     ;	; ; ;1d8a /
      jp nc,l1d7eh ;-;	; ; ;1d8b + if chr Letter or Digit --> ...
      cp '$'	     ;	; ; ;1d8e +
    jp z,l1d7eh ;----+	; ; ;1d90 + if chr.eq.'$' --> ...
    ld a,7		; ; ;1d93   a=7
    add a,b		; ; ;1d95
    ld (SizeID),a	; ; ;1d96   (SizeID)=b+7
l1d99h:			; ;
    call s_4888h	; ; ;1d99   cd 88 48
l1d9ch:			; ;
    ld a,(KindID)	; ; ;1d9c
    dec a		; ; ;1d9f
    jp nz,l1dbdh ;--;	; ; ;1da0   if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)   ;	; ; ;1da3
    or a	    ;	; ; ;1da6
    jp nz,l1dbdh ;--;	; ; ;1da7   if (TypeID).ne.0 (INTEGER)	--> ...
    ld hl,(l01d5h)  ;	; ; ;1daa
    ld a,h	    ;	; ; ;1dad
    or l	    ;	; ; ;1dae
    jp z,l1dbdh	 ;--;	; ; ;1daf   if (l01d5h).eq.0 --> ...
    inc hl	    ;	; ; ;1db2
    ld a,h	    ;	; ; ;1db3
    or l	    ;	; ; ;1db4
    jp z,l1dbdh	 ;--;	; ; ;1db5   if (l01d5h).eq.1 --> ...
    ld a,4	    ;	; ; ;1db8
    ld (TypeID),a   ;	; ; ;1dba   (TypeID)=4 (INTEGER*4)
l1dbdh:	      ;<----+	; ;
    ld a,(KindID)	; ; ;1dbd   3a 08 02
    ret			; ; ;1dc0
			; ;
err117:			; ;
    call err_msg	; ; ;1dc1   Error (117)
    db 075h		; ; ;1dc4   Identifier Too Long
			; ;
l1dc5h:			; ;
    ld (l0277h),a	; ; ;1dc5   (l0277h)=chr
    jp l1ccah		; ; ;1dc8   --> ...
			; ;
l1dcbh:			; ;
    ld a,(l0277h)	; ; ;1dcb
    ld (l0298h),a	; ; ;1dce   (l0298h)=(l0277h)
    ld (l0173h),a	; ; ;1dd1   (l0173h)=(l0277h)
    jp l1d99h		; ; ;1dd4   --> ...
			; ;
l1dd7h:			; ;
    ld hl,KindID	; ; ;1dd7
    ld (hl),1		; ; ;1dda   (KindID)=1 (Constant)
    ld a,(l01d6h)	; ; ;1ddc   3a d6 01
    and 0f0h		; ; ;1ddf   11110000b
    jp nz,l1cceh  ;-----; ; ;1de1   if ((l01d6h).and.11110000b).ne.0 --> ...
    ld hl,l0279h	; ; ;1de4
    inc (hl)		; ; ;1de7   (l0279h)=(l0279h)+1
    call s_209ah	; ; ;1de8   cd 9a 20
    xor a		; ; ;1deb   a=0
    call s_094ch	; ; ;1dec   Initialization field l01d7h 8-byte character null
    ld a,(l0298h)	; ; ;1def   3a 98 02
    sub '0'		; ; ;1df2   Make binary from ASCII
    ld (l01d7h),a	; ; ;1df4   (l01d7h)=
    call s_2078h	; ; ;1df7   cd 78 20
    jp nc,l1cceh  ;-----; ; ;1dfa   d2 ce 1c
    call s_2069h	; ; ;1dfd   cd 69 20
    ld a,080h		; ; ;1e00
    ld (l01d6h),a	; ; ;1e02   (l01d6h)=80h
    jp l1cceh	  ;-----+ ; ;1e05   --> ...
			  ;
l1e08h:	    ;<------------+
    ld a,b		    ;1e08   78
    rla			    ;1e09   17
    jp c,l1f99h		    ;1e0a   da 99 1f
l1e0dh:
    ld a,(l0298h)	    ;1e0d
    cp 'E'		    ;1e10
    jp z,l1e37h ;---;	    ;1e12   if (l0298h).eq.'E' --> ...
    cp 'D'	    ;	    ;1e15
    jp z,l1e2dh ;-; ;	    ;1e17   if (l0298h).eq.'D' --> ...
    ld a,0ffh	  ; ;	    ;1e1a
    ld (l0242h),a ; ;	    ;1e1c   (l0242h)=0ffh
    jp l1e6eh ;---)-)-;	    ;1e1f   --> ...
		  ; ; ;
l1e22h:		  ; ; ;
    ld a,(l01ceh) ; ; ;	    ;1e22
    or a	  ; ; ;	    ;1e25
    jp nz,l5666h  ; ; ;	    ;1e26   if (l01ceh).ne.0 --> Search statement
    call err_msg  ; ; ;	    ;1e29   Error (104)
    db 104	  ; ; ;	    ;1e2c   Illegal Data Constant
		  ; ; ;
l1e2dh:	    ;<----+ ; ;
    ld a,3	    ; ;	    ;1e2d
    ld (TypeID),a   ; ;	    ;1e2f   (TypeID)=3 (DOUBLE)
    ld a,8	    ; ;	    ;1e32
    ld (SizeID),a   ; ;	    ;1e34   (SizeID)=8
l1e37h:		;<--+ ;
    call g_n_chr      ;	    ;1e37 +
    jp m,l1f70h	      ;	    ;1e3a + if chr Digit --> ...
    cp '-'	      ;	    ;1e3d +
    jp z,l1f66h	      ;	    ;1e3f + if chr.eq.'-' --> ...
    cp '+'	      ;	    ;1e42 +
    jp z,l1f6ah	      ;	    ;1e44 + if chr.eq.'+' --> ...
    ld a,(TypeID)     ;	    ;1e47
    cp 3	      ;	    ;1e4a
    jp z,l1e22h	      ;	    ;1e4c   if (TypeID).eq.3 (DOUBLE) --> ...
    ld (l0173h),a     ;	    ;1e4f   (l0173h)=(TypeID)
    ld a,(l0242h)     ;	    ;1e52
    or a	      ;	    ;1e55
    jp z,l1e22h	      ;	    ;1e56   if (l0242h).eq.0 --> ...
    call g_n_chr      ;	    ;1e59 +
    cp 'Q'	      ;	    ;1e5c
    jp nz,l1e22h      ;	    ;1e5e   if chr.ne.'Q' --> ...
    call g_n_chr      ;	    ;1e61 +
    cp '.'	      ;	    ;1e64
    jp nz,l1e22h      ;	    ;1e66   if chr.ne.'.' --> ...
    ld a,9	      ;	    ;1e69
    ld (l01b4h),a     ;	    ;1e6b   (l01b4h)=9
l1e6eh:	      ;<------+
    xor a		    ;1e6e
    ld (TypeID),a	    ;1e6f   (TypeID)=0 (INTEGER)
    ld a,4		    ;1e72
    ld (SizeID),a	    ;1e74   (SizeID)=4
    ld hl,(l01d5h)	    ;1e77   2a d5 01
    ld a,h		    ;1e7a   7c
    or l		    ;1e7b   b5
    ld hl,(l01d3h)	    ;1e7c   2a d3 01
    or h		    ;1e7f   b4
    or l		    ;1e80   b5
    jp nz,l1e22h	    ;1e81   c2 22 1e
    ld hl,(l01d1h)	    ;1e84
    ld a,h		    ;1e87
    or a		    ;1e88
    jp m,l1e22h		    ;1e89   if (l01d1h) < 0 --> ...
    ld (l01d5h),hl	    ;1e8c   (l01d5h)=(l01d1h)
    ld hl,(l01cfh)	    ;1e8f
    ld (l01d3h),hl	    ;1e92   (l01d3h)=(l01cfh)
    ld a,(l0277h)	    ;1e95
    cp '-'		    ;1e98
    ld hl,l01d3h	    ;1e9a   21 d3 01
    call z,s_20d9h	    ;1e9d   if (l0277h).eq.'-' Negate integer*4 ^hl=-^hl
l1ea0h:
    ld a,(l0242h)	    ;1ea0
    or a		    ;1ea3
    jp z,l1d99h		    ;1ea4   if (l0242h).eq.0 --> ...
    jp p,l1d9ch		    ;1ea7   if (l0242h).>.0  --> ...
    ld (l0173h),a	    ;1eaa   (l0173h)=(l0242h)
l1eadh:		;<--;
    call s_48bbh    ;	    ;1ead   Parsing Logical operation
    jp l1d9ch	    ;	    ;1eb0   --> ...
		    ;
l1eb3h:		    ;
    call g_n_chr    ;	    ;1eb3 +
    jp m,l1dd7h	    ;	    ;1eb6 + if chr Digit --> ...
    jp c,l1f99h	    ;	    ;1eb9 + if chr Special character --> ...
    ld a,012h	    ;	    ;1ebc
    ld (l0242h),a   ;	    ;1ebe   (l0242h)=012h
    ld a,(KindID)   ;	    ;1ec1
    or a	    ;	    ;1ec4
    jp nz,l1e0dh    ;	    ;1ec5   if (KindID).ne.0 --> ...
    inc a	    ;	    ;1ec8
    ld (l0173h),a   ;	    ;1ec9   (l0173h)=(KindID)+1 [=1] (Constant)
    ld a,(l0298h)   ;	    ;1ecc
    cp 'N'	    ;	    ;1ecf
    jp z,l1eadh ;---+	    ;1ed1   if (l0298h).eq.'N' --> ...
    ld a,5		    ;1ed4   a=5
    call GetStr		    ;1ed6   Reading string length 5 characters
    ld hl,l01dah	    ;1ed9   21 da 01
    ld de,l02c9h	    ;1edc   de="FALSE"
    ld b,5		    ;1edf   b=5
    call cmpstr		    ;1ee1   Compare strings ^HL:^DE with length in B
    jp z,l1f16h	 ;----;	    ;1ee4   strings eq --> ...
    ld hl,l01dah      ;	    ;1ee7   21 da 01
    ld de,l02ceh      ;	    ;1eea   hl="TRUE."
    ld b,5	      ;	    ;1eed   b=5
    call cmpstr	      ;	    ;1eef   Compare strings ^HL:^DE with length in B
    jp nz,l1e22h      ;	    ;1ef2   if strings ne --> ...
		      ;
;   found "TRUE."     ;
		      ;
    ld a,0ffh	      ;	    ;1ef5
    ld (l01d5h),a     ;	    ;1ef7   (l01d5h)=ffh
    ld (l01d6h),a     ;	    ;1efa   (l01d6h)=ffh
    ld (l01d3h),a     ;	    ;1efd   (l01d3h)=ffh
    ld (l01d4h),a     ;	    ;1f00   (l01d4h)=ffh
l1f03h:	     ;<-----; ;
    ld a,2	    ; ;	    ;1f03
    ld (SizeID),a   ; ;	    ;1f05   (SizeID)=2
    dec a	    ; ;	    ;1f08
    ld (KindID),a   ; ;	    ;1f09   (KindID)=1 (Constant)
    inc a	    ; ;	    ;1f0c
    ld (TypeID),a   ; ;	    ;1f0d   (TypeID)=2 (BYTE)
    call g_n_chr    ; ;	    ;1f10 +
    jp l1d99h	    ; ;	    ;1f13   --> ...
		    ; ;
;   found "FALSE"   ; ;
		    ; ;
l1f16h:	      ;<----)-+
    call g_n_chr    ;	    ;1f16 +
    cp '.'	    ;	    ;1f19
    jp z,l1f03h ;---+	    ;1f1b   if chr.eq.'.' --> ...
    jp l1e22h		    ;1f1e   --> ...
;
l1f21h:
    ld a,b		    ;1f21   78
    rla			    ;1f22   17
    jp c,l1e6eh		    ;1f23   da 6e 1e
    ld a,c		    ;1f26   79
    sub 048h		    ;1f27   'H'
    jp nz,l1e0dh	    ;1f29   c2 0d 1e
    ld (TypeID),a	    ;1f2c   Save value type variable
    ld a,4		    ;1f2f
    ld (SizeID),a	    ;1f31   (SizeID)=4
    ld a,1		    ;1f34
    ld (l01cbh),a	    ;1f36   (l01cbh)=1
    ld hl,(l01d5h)	    ;1f39   2a d5 01
    ld a,h		    ;1f3c   7c
    or l		    ;1f3d   b5
    ld hl,(l01d3h)	    ;1f3e   2a d3 01
    or h		    ;1f41   b4
    or l		    ;1f42   b5
    jp nz,l1e22h	    ;1f43   c2 22 1e
    ld hl,(l01d1h)	    ;1f46
    ld a,h		    ;1f49
    or a		    ;1f4a
    jp nz,l1e22h	    ;1f4b   if (l01d1h).ne.0 --> ...
    ld (l01d5h),hl	    ;1f4e   (l01d5h)=(l01d1h)
    ld hl,(l01cfh)	    ;1f51
    ld (l01d3h),hl	    ;1f54   (l01d3h)=(l01cfh)
    ld a,(l0277h)	    ;1f57
    cp 02dh		    ;1f5a   '-'
    jp nz,l1d9ch	    ;1f5c   if (l0277h).ne.02dh --> ...
    call err_msg	    ;1f5f   Error (109)
    db 109		   ;1f62    Incorrect Integer Constant
    jp l1d9ch		    ;1f63   --> ...
;
l1f66h:
    ld hl,l0278h	    ;1f66
    inc (hl)		    ;1f69   (l0278h)=(l0278h)+1
l1f6ah:
    call g_n_chr	    ;1f6a +
    jp p,l1e22h		    ;1f6d + if Special character or Letter --> ...
l1f70h:	       ;<---;
    ld hl,l027ah    ;	    ;1f70
    ld a,(hl)	    ;	    ;1f73
    add a,a	    ;	    ;1f74				*2
    add a,a	    ;	    ;1f75				*4
    jp c,l1e22h	    ;	    ;1f76   if (l027ah)*4 < 0  --> ...
    add a,(hl)	    ;	    ;1f79				*5
    jp c,l1e22h	    ;	    ;1f7a   if (l027ah)*5 < 0  --> ...
    rla		    ;	    ;1f7d				*10
    jp c,l1e22h	    ;	    ;1f7e   if (l027ah)*10 < 0 --> ...
    ld (hl),a	    ;	    ;1f81   (l027ah)=(l027ah)*10
    ld a,(l0298h)   ;	    ;1f82
    sub '0'	    ;	    ;1f85   Make binary from ASCII
    add a,(hl)	    ;	    ;1f87
    jp c,l1e22h	    ;	    ;1f88   if (l0298h)-'0'+(l027ah) < 0 --> ...
    jp m,l1e22h	    ;	    ;1f8b   if (l0298h)-'0'+(l027ah) < 0 --> ...
    ld (hl),a	    ;	    ;1f8e   (l027ah)=(l0298h)-'0'+(l027ah)
    call g_n_chr    ;	    ;1f8f +
    jp m,l1f70h ;---+	    ;1f92 + if chr Digit --> ...
    ld a,(l0278h)	    ;1f95   3a 78 02
    or a		    ;1f98   b7
l1f99h:
    ld hl,l027ah	    ;1f99
    ld a,(hl)		    ;1f9c
    jp z,l1fa2h	 ;--;	    ;1f9d   if (l027ah).eq.0 --> ...
    cpl		    ;	    ;1fa0   2f
    inc a	    ;	    ;1fa1   3c
l1fa2h:		;<--+
    ex de,hl		    ;1fa2   eb
    ld hl,l0279h	    ;1fa3   21 79 02
    sub (hl)		    ;1fa6   96
    ld (de),a		    ;1fa7   12
    xor a		    ;1fa8
    ld (l0242h),a	    ;1fa9   (l0242h)=0
    xor a		    ;1fac   a=0
    ld hl,l01cfh	    ;1fad   21 cf 01
    ld b,8		    ;1fb0   b=8
l1fb2h:	       ;<---;
      or (hl)	    ;	    ;1fb2   b6
      inc hl	    ;	    ;1fb3   hl=hl+1
      dec b	    ;	    ;1fb4   b=b-1
    jp nz,l1fb2h ;--+	    ;1fb5   c2 b2 1f
    or a		    ;1fb8   b7
    jp z,l1d99h		    ;1fb9   ca 99 1d
    ld a,0c0h		    ;1fbc
    ld (l0279h),a	    ;1fbe   (l0279h)=0c0h
l1fc1h:	     ;<------;
    ld a,(l01d6h)    ;	    ;1fc1
    or a	     ;	    ;1fc4
    jp m,l1fd5h ;--; ;	    ;1fc5   if (l01d6h) < 0 --> ...
    ld hl,l0279h   ; ;	    ;1fc8
    dec (hl)	   ; ;	    ;1fcb   (l0279h)=(l0279h)-1
    jp z,l2063h ;--)-)---;  ;1fcc   if (l0279h).eq.0 --> ...
    call s_208bh   ; ;	 ;  ;1fcf   cd 8b 20
    jp l1fc1h  ;---)-;	 ;  ;1fd2   --> ...
		   ; ;	 ;
l1fd5h:	    ;<-----+ ;	 ;
    ld hl,l027ah     ;	 ;  ;1fd5
    ld a,(hl)	     ;	 ;  ;1fd8
    or a	     ;	 ;  ;1fd9
    jp z,l2027h ;----)-; ;  ;1fda   if (l027ah).eq.0 --> ...
    jp m,l1ffdh ;--; ; ; ;  ;1fdd   if (l027ah) < 0 --> ...
    dec (hl)	   ; ; ; ;  ;1fe0   (l027ah)=(l027ah)-1
    call s_2069h   ; ; ; ;  ;1fe1   cd 69 20
    call s_4860h   ; ; ; ;  ;1fe4   Move 8 bytes from ^l01cfh to ^l01d7h
    call s_2069h   ; ; ; ;  ;1fe7   cd 69 20
    call s_2069h   ; ; ; ;  ;1fea   cd 69 20
    call s_2078h   ; ; ; ;  ;1fed   cd 78 20
    ld hl,l0279h   ; ; ; ;  ;1ff0
    ld a,4	   ; ; ; ;  ;1ff3
    add a,(hl)	   ; ; ; ;  ;1ff5
    ld (hl),a	   ; ; ; ;  ;1ff6   (l0279h)=(l0279h)+4
    jp nc,l1fc1h ;-)-; ; ;  ;1ff7   if (l0279h)+4 >= 0	--> ...
    jp l1e22h	   ; ; ; ;  ;1ffa   --> ...
		   ; ; ; ;
l1ffdh:	    ;<-----+ ; ; ;
    inc (hl)	     ; ; ;  ;1ffd   (l027ah)=(l027ah)+1
    call s_2069h     ; ; ;  ;1ffe   cd 69 20
    call s_4860h     ; ; ;  ;2001   Move 8 bytes from ^l01cfh to ^l01d7h
    call s_2069h     ; ; ;  ;2004   cd 69 20
    call s_2078h     ; ; ;  ;2007   cd 78 20
    call s_4860h     ; ; ;  ;200a   Move 8 bytes from ^l01cfh to ^l01d7h
    ld a,15	     ; ; ;  ;200d   a=15
l200fh:	     ;<----; ; ; ;
      push af	   ; ; ; ;  ;200f \
      call s_20a9h ; ; ; ;  ;2010   cd a9 20
      call s_2078h ; ; ; ;  ;2013   cd 78 20
      pop af	   ; ; ; ;  ;2016 /
      dec a	   ; ; ; ;  ;2017   a=a-1
    jp nz,l200fh ;-+ ; ; ;  ;2018   if a.ne.0 --> ...
    call s_2069h     ; ; ;  ;201b   cd 69 20
    call s_2069h     ; ; ;  ;201e   cd 69 20
    call s_2069h     ; ; ;  ;2021   cd 69 20
    jp l1fc1h	;----+ ; ;  ;2024   --> ...
		       ; ;
l2027h:	    ;<---------+ ;
    xor a		 ;  ;2027   a=0
    call s_094ch	 ;  ;2028   Initialization field l01d7h 8-byte character null
    ld a,080h		 ;  ;202b
    ld (l01d7h),a	 ;  ;202d   (l01d7h)=80h
    call s_2078h	 ;  ;2030   cd 78 20
    jp nc,l2042h ;--;	 ;  ;2033   d2 42 20
    ld a,080h	    ;	 ;  ;2036
    ld (l01d6h),a   ;	 ;  ;2038   (l01d6h)=80h
    ld hl,l0279h    ;	 ;  ;203b
    inc (hl)	    ;	 ;  ;203e   (l0279h)=(l0279h)+1
    jp z,l1e22h	    ;	 ;  ;203f   if (l0279h).eq.0 --> ...
l2042h:	    ;<------+	 ;
    ld hl,l01d0h	 ;  ;2042   21 d0 01
    ld de,l01cfh	 ;  ;2045   Destination address
    ld b,6		 ;  ;2048   b=6
    call s_085ch	 ;  ;204a   Move B bytes from ^HL to ^DE
    ld a,(l0277h)	 ;  ;204d   3a 77 02
    cp 02dh		 ;  ;2050   fe 2d   '-'
    ccf			 ;  ;2052   3f
    ld a,(l01d6h)	 ;  ;2053   3a d6 01
    rla			 ;  ;2056   17
    rrca		 ;  ;2057   0f
    ld l,a		 ;  ;2058   6f
    ld a,(l0279h)	 ;  ;2059   3a 79 02
    ld h,a		 ;  ;205c   67
    ld (l01d5h),hl	 ;  ;205d   22 d5 01
    jp l1ea0h		 ;  ;2060   --> ...
			 ;
l2063h:		;<-------+
    call s_093ah	    ;2063   (l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
    jp l1ea0h		    ;2066   --> ...
;
;
;
s_2069h:
    ld b,8		;2069	b=8
    ld hl,l01d6h	;206b	21 d6 01
    or a		;206e	b7
l206fh:		;<--;
      ld a,(hl)	    ;	;206f	7e
      rra	    ;	;2070	1f
      ld (hl),a	    ;	;2071	77
      dec hl	    ;	;2072	hl=hl-1
      dec b	    ;	;2073	b=b-1
    jp nz,l206fh ;--+	;2074	if b.ne.0 --> ...
    ret			;2077
;
;
;
s_2078h:
    ld de,l01d7h	;2078	11 d7 01
    ld hl,l01cfh	;207b	21 cf 01
    ld b,8		;207e	b=8
    xor a		;2080	a=0
l2081h:		;<--;
      ld a,(de)	    ;	;2081
      adc a,(hl)    ;	;2082
      ld (hl),a	    ;	;2083	(hl)=(de)+(hl)+Carry
      inc hl	    ;	;2084	hl=hl+1
      inc de	    ;	;2085	de=de+1
      dec b	    ;	;2086	b=b-1
    jp nz,l2081h ;--+	;2087	if b.ne.0 --> ...
    ret			;208a
;
;
;
s_208bh:
    ld b,8		;208b	b=8
    ld hl,l01cfh	;208d	21 cf 01
    xor a		;2090	a=0
l2091h:		;<--;
      ld a,(hl)	    ;	;2091	7e
      rla	    ;	;2092	17
      ld (hl),a	    ;	;2093	77
      inc hl	    ;	;2094	hl=hl+1
      dec b	    ;	;2095	b=b-1
    jp nz,l2091h ;--+	;2096	if b.ne.0 --> ...
    ret			;2099
;
;
;
s_209ah:
    call s_4860h	;209a	Move 8 bytes from ^l01cfh to ^l01d7h
    call s_208bh	;209d	cd 8b 20
    call s_208bh	;20a0	cd 8b 20
    call s_2078h	;20a3	cd 78 20
    jp s_208bh		;20a6	--> ...
;
;
;
s_20a9h:
    ld c,4		;20a9	0e 04
l20abh:		;<----;
      ld b,8	      ; ;20ab	06 08
      ld hl,l01deh    ; ;20ad	21 de 01
      or a	      ; ;20b0	reset Carry
l20b1h:		 ;<-; ;
	ld a,(hl)   ; ; ;20b1	7e
	rra	    ; ; ;20b2	1f
	ld (hl),a   ; ; ;20b3	77
	dec hl	    ; ; ;20b4	hl=hl-1
	dec b	    ; ; ;20b5	b=b-1
      jp nz,l20b1h;-+ ; ;20b6	c2 b1 20
      dec c	      ; ;20b9	c=c-1
    jp nz,l20abh ;----+ ;20ba	c2 ab 20
    ret			;20bd
;*
;*  Addition integer*4 ^hl=^de+^hl
;*  ENTRY:
;*    hl points to Num1 (stored little-endian)
;*    de points to Num2 (stored little-endian)
;*
s_20beh:
    ld b,4		;20be	b=4
    or a		;20c0	reset Carry
l20c1h:		;<--;
      ld a,(de)	    ;	;20c1
      adc a,(hl)    ;	;20c2
      ld (hl),a	    ;	;20c3	(hl)=(de)+(hl)+Carry
      inc hl	    ;	;20c4	hl=hl+1
      inc de	    ;	;20c5	de=de+1
      dec b	    ;	;20c6	b=b-1
    jp nz,l20c1h ;--+	;20c7	if b.ne.0 --> ...
    ret			;20ca
;*
;*  Subtraction integer*4 ^de=^hl-^de
;*  ENTRY:
;*    hl points to Num1 (stored little-endian)
;*    de points to Num2 (stored little-endian)
;*
s_20cbh:
    ld b,4		;20cb	b=4
    or a		;20cd	reset Carry
    ex de,hl		;20ce	eb
l20cfh:		;<--;
      ld a,(de)	    ;	;20cf
      sbc a,(hl)    ;	;20d0
      ld (de),a	    ;	;20d1	(de)=(de)-(hl)-Carry
      inc hl	    ;	;20d2	hl=hl+1
      inc de	    ;	;20d3	de=de+1
      dec b	    ;	;20d4	b=b-1
    jp nz,l20cfh ;--+	;20d5	if b.ne.0 --> ...
    ret			;20d8
;*
;*  Negate integer*4 ^hl=-^hl
;*  ENTRY:
;*    hl points to Num (stored little-endian)
;*
s_20d9h:
    ld b,4		;20d9	b=4
    or a		;20db	reset Carry
l20dch:		;<--;
      ld a,0	    ;	;20dc	a=0
      sbc a,(hl)    ;	;20de	a=a-(hl)-Carry
      ld (hl),a	    ;	;20df	(hl)=a
      inc hl	    ;	;20e0	hl=hl+1
      dec b	    ;	;20e1	b=b-1
    jp nz,l20dch ;--+	;20e2	if b.ne.0 --> ...
    ret			;20e5
;*
;*  Multiplication integer*4 ^hl=^de+^hl
;*    ENTRY:
;*	hl - points to Num1
;*	de - points to Num2
;*
s_20e6h:
    push hl		 ;20e6 \ Save points to Num1
    ld hl,00000h	 ;20e7
    ld (l015fh),hl	 ;20ea	 (l015fh)=0
    ld (l0161h),hl	 ;20ed	 (l0161h)=0
    pop hl		 ;20f0 / Restore points to Num1
    ld b,020h		 ;20f1	 b=32
l20f3h:		   ;<--;
      call s_2111h     ; ;20f3	 cd 11 21
      call s_211ah     ; ;20f6	 cd 1a 21
      jp nc,l20ffh ;-; ; ;20f9	 d2 ff 20
      call s_212ah   ; ; ;20fc	 ^l015fh=^de+^l015fh
l20ffh:		;<---+ ;
      dec b	       ; ;20ff	 b=b-1
    jp nz,l20f3h  ;----+ ;2100	 if b.ne.0 --> ...
    push de		 ;2103
    push hl		 ;2104
    ex de,hl		 ;2105	 eb
    ld hl,l015fh	 ;2106	 hl=l015fh
    ld b,4		 ;2109	 b=4
    call s_085ch	 ;210b	 Move B bytes from ^HL to ^DE
    pop hl		 ;210e
    pop de		 ;210f
    ret			 ;2110
;*
;*
;*
s_2111h:
    push hl		;2111
    ld hl,l015fh	;2112	hl=l015fh
    call s_211ah	;2115	cd 1a 21
    pop hl		;2118
    ret			;2119
;*
;*
;*
s_211ah:
    or a		;211a	reset Carry
s_211bh:
    push hl		;211b
    push bc		;211c
    ld b,4		;211d	b=4
l211fh:		;<--;
      ld a,(hl)	    ;	;211f	7e
      rla	    ;	;2120	17
      ld (hl),a	    ;	;2121	77
      inc hl	    ;	;2122	hl=hl+1
      dec b	    ;	;2123	b=b-1
    jp nz,l211fh ;--+	;2124	if b.ne.0 --> ...
    pop bc		;2127
    pop hl		;2128
    ret			;2129
;*
;*  ^l015fh=^de+^l015fh
;*
s_212ah:
    push hl		;212a
    push de		;212b
    push bc		;212c
    ld hl,l015fh	;212d	hl=l015fh
    call s_20beh	;2130	Addition integer*4 ^hl=^de+^hl
    pop bc		;2133
    pop de		;2134
    pop hl		;2135
    ret			;2136
;*
;*  Division integer*4 ^hl=^de+^hl
;*    ENTRY:
;*	hl - points to Num1
;*	de - points to Num2
s_2137h:
    push hl		;2137 \ Save points to Num1
    ld hl,00000h	;2138
    ld (l015fh),hl	;213b	(l015fh)=0
    ld (l0161h),hl	;213e	(l0161h)=0
    pop hl		;2141 / Restore points to Num1
    ld b,021h		;2142	b=33
    or a		;2144	Clears carry flag
    jp l216bh	;---;	;2145	--> ...
		    ;
l2148h:	    ;<------)-;
    push hl	    ; ; ;2148 \ e5
    ld hl,(l015fh)  ; ; ;2149	hl=(l015fh)
    ex (sp),hl	    ; ; ;214c	e3
    push hl	    ; ; ;214d \ e5
    ld hl,(l0161h)  ; ; ;214e	hl=(l0161h)
    ex (sp),hl	    ; ; ;2151	e3
    call s_2176h    ; ; ;2152	cd 76 21
    jp c,l2160h ;-; ; ; ;2155	da 60 21
    ex (sp),hl	  ; ; ; ;2158	e3
    pop hl	  ; ; ; ;2159 / e1
    ex (sp),hl	  ; ; ; ;215a	e3
    pop hl	  ; ; ; ;215b / e1
    scf		  ; ; ; ;215c	Set carry
    jp l216bh ;---)-; ; ;215d	--> ...
		  ; ; ;
l2160h:	   ;<-----+ ; ;
    ex (sp),hl	    ; ; ;2160	e3
    ld (l0161h),hl  ; ; ;2161	(l0161h)=
    pop hl	    ; ; ;2164 / e1
    ex (sp),hl	    ; ; ;2165	e3
    ld (l015fh),hl  ; ; ;2166	(l015fh)=
    pop hl	    ; ; ;2169 / e1
    or a	    ; ; ;216a	Clears carry flag
l216bh:		;<--+ ;
    call s_211bh      ; ;216b	cd 1b 21
    call s_2183h      ; ;216e	cd 83 21
    dec b	      ; ;2171	b=b-1
    jp nz,l2148h  ;---+ ;2172	if b.ne.0 --> ...
    ret			;2175
;*
;*
;*
s_2176h:
    push hl		    ;2176
    push de		    ;2177
    push bc		    ;2178
    ld hl,l015fh	    ;2179   hl=l015fh
    call s_20cbh	    ;217c   Subtraction integer*4 ^de=^hl-^de
    pop bc		    ;217f
    pop de		    ;2180
    pop hl		    ;2181
    ret			    ;2182
;*
;*
;*
s_2183h:
    push hl		    ;2183
    ld hl,l015fh	    ;2184   hl=l015fh
    call s_211bh	    ;2187   cd 1b 21
    pop hl		    ;218a
    ret			    ;218b
;*
;*  Processing label & Test (TypeID).eq.INTEGER
;*
s_218ch:
    call PrLabel	    ;218c   Processing label
    ld a,(TypeID)	    ;218f
    or a		    ;2192
    ret z		    ;2193   if (TypeID).eq.0 (INTEGER) Return
    call err_msg	    ;2194   Warning (20)
    db 20		    ;2197   Invalid Statement Number Usage
    ret			    ;2198
;*
;*  Check that the name refers to a variables
;*
ChkVar:
    call PrName		    ;2199   Processing name
    cp 5		    ;219c
    jp nc,err111 ;--;	    ;219e   if (KindID) >= 5 (Routine) --> Not a Variable Name
    ld a,(ScopeID)  ;	    ;21a1
    cp 3	    ;	    ;21a4
    ret nz	    ;	    ;21a6   if (ScopeID).ne.3 Return
err111:	      ;<----+
    call err_msg	    ;21a7   Error (111)
    db 111		    ;21aa   Not a Variable Name
;
;   Processing READ(, WRITE(
;	READ (LUN, Label, ERR=L1, END=L2) k - Formatted statement
;	READ (LUN, ERR=L1, END=L2) k	- Unformatted statement
;
PrRead:
    call s_257ch	    ;21ab   Processing integer constant (LUN)
l21aeh:
    xor a		    ;21ae
    ld (NumIO),a	    ;21af   (NumIO)=0 Clear Number of parameters statement READ or WRITE
    ld (l0286h),a	    ;21b2   (l0286h)=0
    call s_2ec9h	    ;21b5   cd c9 2e
    ld hl,(l02b0h)	    ;21b8
    ld (l0284h),hl	    ;21bb   (l0284h)=(l02b0h)
    ld (l0282h),hl	    ;21be   (l0282h)=(l02b0h)
    ld (l024eh),hl	    ;21c1   (l024eh)=(l02b0h)
    ld (l01cch),hl	    ;21c4   (l01cch)=(l02b0h)
    ld hl,00000h	    ;21c7   hl=0
    ld a,(l0298h)	    ;21ca
    cp ','		    ;21cd
    jp nz,l220ah ;----;	    ;21cf   if (l0298h).ne.',' --> ...
    call s_14d4h      ;	    ;21d2 + g_n_chr; (l0173h)=chr
    jp p,l21e1h ;-;   ;	    ;21d5 + if Special character or Letter --> ...
    call PrLabel  ;   ;	    ;21d8 + Processing label
    call s_0e27h  ;   ;	    ;21db   cd 27 0e
    jp l2207h ;---)-; ;	    ;21de   --> ...
		  ; ; ;
l21e1h:	      ;<--+ ; ;
    call s_1cb5h    ; ;	    ;21e1   cd b5 1c
    ld a,(l0298h)   ; ;	    ;21e4
    cp '='	    ; ;	    ;21e7
    jp nz,l21fch;-; ; ;	    ;21e9   if (l0298h).ne.'=' --> ...
    ld (l01d3h),a ; ; ;	    ;21ec   (l01d3h)=
    call s_4860h  ; ; ;	    ;21ef   Move 8 bytes from ^l01cfh to ^l01d7h
    xor a	  ; ; ;	    ;21f2   a=0
    ld h,a	  ; ; ;	    ;21f3
    ld l,a	  ; ; ;	    ;21f4   hl=0
    push hl	  ; ; ;	    ;21f5
    call s_2ec9h  ; ; ;	    ;21f6   cd c9 2e
    jp TstERR  ;--)-)-)-;   ;21f9   --> Test parameter "END=", "ERR=" or "REC="
		  ; ; ; ;
l21fch:	     ;<---+ ; ; ;
    ld a,(KindID)   ; ; ;   ;21fc   3a 08 02
    call s_1cach    ; ; ;   ;21ff   cd ac 1c
    cp 4	    ; ; ;   ;2202
    jp nz,err128    ; ; ;   ;2204   if (KindID).ne.4 (Array)--> Error (128) Missing Integer Quantity
l2207h:	   ;<-------+ ; ;
    ld hl,(l01cch)    ; ;   ;2207   2a cc 01
l220ah:	       ;<-----+ ;
    push hl		;   ;220a \ e5
    xor a		;   ;220b   a=0
    call s_2ec9h	;   ;220c   cd c9 2e
			;
ExpPar:		 ;<--;	;	    Expected separator (,) & string length 4 characters
    ld a,(l0298h)    ;	;   ;220f
    cp ','	     ;	;   ;2212   Test separator
    jp nz,l2266h  ;--)--)-; ;2214   if(l0298h).ne.',' (parameters have ended) --> Continue processing operator
    ld a,4	     ;	; ; ;2217   a=4
    call GetStr	     ;	; ; ;2219   Reading string length 4 characters
		     ;	; ;
TstERR:	       ;<----)--+ ;
    ld hl,l02d9h     ;	  ; ;221c   hl="ERR="
    call CmpSt4	     ;	  ; ;221f   Compare strings length 4 characters
    jp nz,TstEND ;-; ;	  ; ;2222   if not equal --> Test parameter "END="
		   ; ;	  ;
;   Foubd "ERR="   ; ;	  ;	    Processing (ERR=label)
		   ; ;	  ;
    ld hl,NumIO	   ; ;	  ; ;2225
    inc (hl)	   ; ;	  ; ;2228   (NumIO)=(NumIO)+1
    call PrLabel   ; ;	  ; ;2229   Processing label
    ld (l0284h),hl ; ;	  ; ;222c   (l0284h)=Address labels corresponding to the parameter "ERR="
    jp ExpPar	;--)-;	  ; ;222f   --> Expected next parameter
		   ; ;	  ;
TstEND:	       ;<--+ ;	  ;
    ld hl,l02ddh     ;	  ; ;2232   hl="END="
    call CmpSt4	     ;	  ; ;2235   Compare strings length 4 characters
    jp nz,TstREC ;-; ;	  ; ;2238   if not equal --> Test parameter "REC="
		   ; ;	  ;
;   Found "END="   ; ;	  ;	    Processing (END=label)
		   ; ;	  ;
    ld hl,NumIO	   ; ;	  ; ;223b
    inc (hl)	   ; ;	  ; ;223e   (NumIO)=(NumIO)+1
    call PrLabel   ; ;	  ; ;223f   Processing label
    ld (l0282h),hl ; ;	  ; ;2242   (l0282h)=Address labels corresponding to the parameter "END="
    jp ExpPar	;--)-;	  ; ;2245   --> Expected next parameter
		   ; ;	  ;
TstREC:	       ;<--+ ;	  ;
    ld hl,l02e1h     ;	  ; ;2248   hl="REC="
    call CmpSt4	     ;	  ; ;224b   Compare strings length 4 characters
    jp nz,err115     ;	  ; ;224e   if not equal --> Error (115) Invalid Data List Element in I/O
		     ;	  ;
;   Found "REC="     ;	  ;	    Processing (REC=constant)
		     ;	  ;
    ld hl,NumIO	     ;	  ; ;2251
    inc (hl)	     ;	  ; ;2254   (NumIO)=(NumIO)+1
    call s_2593h     ;	  ; ;2255   Processing integer constant with error checking
    ld (l024eh),hl   ;	  ; ;2258   (l024eh)=Address constant corresponding to the parameter "REC="
    jp ExpPar	;----+	  ; ;225b   --> Expected next parameter
;			  ;
;   Compare strings length 4 characters
;			  ;
CmpSt4:			  ;
    ld de,l01dbh	  ; ;225e   Pointer to source string
    ld b,4		  ; ;2261   b=4
    jp cmpstr		  ; ;2263   --> Compare strings ^HL:^DE with length in B
			  ;
l2266h:		;<--------+	    Continue processing statement
    ld a,(NumIO)	    ;2266
    or a		    ;2269
    jp z,PrMnIO	 ;---;	    ;226a   if (NumIO).eq.0 (missing optional parameters) --> Skip their processing
    ld hl,(l0284h)   ;	    ;226d   hl=Address labels corresponding to the parameter "ERR="
    xor a	     ;	    ;2270   a=0
    call s_2ec6h     ;	    ;2271   cd c6 2e
    ld hl,(l0282h)   ;	    ;2274   hl=Address labels corresponding to the parameter "END="
    xor a	     ;	    ;2277   a=0
    call s_2ec6h     ;	    ;2278   cd c6 2e
    ld hl,(l024eh)   ;	    ;227b   hl=Address constant corresponding to the parameter "REC="
    xor a	     ;	    ;227e   a=0
    call s_2ec6h     ;	    ;227f   cd c6 2e
		     ;
PrMnIO:		;<---+
;   Preparation of mnemonics built-in routine Input/Output
;
;   For statement READ or WRITE
;     First byte (in Reg B) indicates:
;	"R" - Read operation
;	"W" - Write operation
;     Second byte (in Reg C) indicates routine:
;	"2" - with two parameters (LUN & Label)
;	"5" - with two parameters (LUN, Label & optional parameters)
;
    ld hl,(l022bh)	    ;2282   Load 1 and 2 bytes statement
    ld b,h		    ;2285   Load in Reg B first character source statement for setup first byte built-in routine
    ld c,l		    ;2286
    ld a,b		    ;2287   a=b
    cp 'R'		    ;2288   Test 'R' - indicates Read operation
    jp z,StatRW ;---;	    ;228a   .. yeap
    cp 'W'	    ;	    ;228d   Test 'W' - indicates Write operation
    jp nz,StatED  ;-)-----; ;228f   .. nope
		    ;	  ;
StatRW:	       ;<---+	  ;	    Statement READ or WRITE
    ld c,'2'		  ; ;2292   Set built-in routine with two parameters
    ld a,(NumIO)	  ; ;2294
    or a		  ; ;2297   if (NumIO).eq.0 (missing optional parameters)
    jp z,CreaIO	    ;---; ; ;2298      --> Creating built-in routine I/O
    ld c,'5'		; ; ;229b   Set built-in routine with five parameters
    jp CreaIO	    ;---; ; ;229d   --> Creating built-in routine I/O
			; ;
StatED:		;<------)-+	    Statement ENCODE or DECODE (can not have optional parameters)
    ld a,(NumIO)	;   ;22a0
    or a		;   ;22a3   if (NumIO).eq.0 (missing optional parameters)
    jp z,BuilED	  ;---; ;   ;22a4	--> skip error message
    call err_msg      ; ;   ;22a7   Warning (33)
    db	33	      ; ;   ;22aa   Illegal Argument to ENCODE/DECODE
		      ; ;
;   For ENCODE/DECODE ; ;
;     First byte: "O" ; ; Second byte:	"D" - Decode, "E" - Encode
BuilED:	      ;<------+ ;
    ld c,b		;   ;22ab   Build second byte "E" or "D"
    ld b,'O'		;   ;22ac   Build first byte "O"
CreaIO:		;<------+
    call CrBuilt	    ;22ae   Creating built-in routine
    xor a		    ;22b1
    ld (l024bh),a	    ;22b2   (l024bh)=0
    ld hl,0ffffh	    ;22b5
    ld a,h		    ;22b8
    ld (l0284h),a	    ;22b9   (l0284h)=0ffh
    ld (l027fh),hl	    ;22bc   (l027fh)=0ffffh
    ld (l0282h),hl	    ;22bf   (l0282h)=0ffffh
    call s_4e59h	    ;22c2   cd 59 4e
;
    ld a,(l0298h)	    ;22c5
l22c8h:		;<--;
    cp ','	    ;	    ;22c8
    jp nz,l22d3h  ;-)-;	    ;22ca   if (l0298h).ne.',' --> ...
    call g_n_chr    ; ;	    ;22cd +
    jp l22c8h	;---+ ;	    ;22d0
		      ;
l22d3h:		;<----+
    cp cr		    ;22d3
    pop hl		    ;22d5 / e1
    jp nz,l2305h  ;---;	    ;22d6   if (l0298h).ne.cr --> ...
    ld a,h	      ;	    ;22d9
    or l	      ;	    ;22da
    jp nz,l22f8h ;--; ;	    ;22db   if(hl.ne.0) --> ...
    call err_msg    ; ;	    ;22de   Warning (10)
    db 10	    ; ;	    ;22e1   Empty List for Unformatted WRITE
    jp l22f8h	 ;--; ;	    ;22e2   --> ...
		    ; ;
l22e5h:	    ;<------)-)---;
    ld hl,(l0282h)  ; ;	  ; ;22e5
    inc hl	    ; ;	  ; ;22e8
    ld a,h	    ; ;	  ; ;22e9
    or l	    ; ;	  ; ;22ea
    jp nz,err116    ; ;	  ; ;22eb   if (l0282h).ne.1 --> Error (116) Unbalanced DO Nest
    ld a,(l0286h)   ; ;	  ; ;22ee
    or a	    ; ;	  ; ;22f1
    jp nz,err116    ; ;	  ; ;22f2   if (l0286h).ne.0 --> Error (116) Unbalanced DO Nest
    call s_3169h    ; ;	  ; ;22f5   cd 69 31
l22f8h:		;<--+ ;	  ;
    ld bc,'ND'	      ;	  ; ;22f8   $ND - Terminate I/O process
    call CrBuilt      ;	  ; ;22fb   Creating built-in routine
    jp l09e4h	      ;	  ; ;22fe   --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
		      ;	  ;
err115:		      ;	  ;
    call err_msg      ;	  ; ;2301   Error (115)
    db 115	      ;	  ; ;2304   Invalid Data List Element in I/O
		      ;	  ;
l2305h:	       ;<-----+	  ;
    ld a,1		  ;	;2305	a=1
    ld (l0173h),a	  ;	;2307	(l0173h)=1
l230ah:	       ;<-------; ;
    call s_1ca9h	; ;	;230a	cd a9 1c
    jp nz,l235ah ;----; ; ;	;230d	if (KindID).ne.0 --> ...
    ld a,'('	      ; ; ;	;2310 + a='('
    call ch_chr	      ; ; ;	;2312 + Check character (a character for check)
    ld hl,l0286h      ; ; ;	;2315
    inc (hl)	      ; ; ;	;2318	(l0286h)=(l0286h)+1
    ld hl,(HeapEnd)   ; ; ;	;2319
    ex de,hl	      ; ; ;	;231c
    ld hl,(l0206h)    ; ; ;	;231d
    push hl	      ; ; ;	;2320 \
    call subHL_DE     ; ; ;	;2321	hl=hl-de=(l0206h)-(HeapEnd)
    ex (sp),hl	      ; ; ;	;2324	e3
    pop bc	      ; ; ;	;2325 / bc=(l0206h)
l2326h:		      ; ; ;
      ld a,b	      ; ; ;	;2326
      or c	      ; ; ;	;2327
      jp z,l233ah ;-; ; ; ;	;2328	if bc.eq.0 -->
      ld a,(hl)	    ; ; ; ;	;232b	7e
      or 80h	    ; ; ; ;	;232c	f6 80
      ld (hl),a	    ; ; ; ;	;232e	77
      dec hl	    ; ; ; ;	;232f
      dec hl	    ; ; ; ;	;2330
      dec hl	    ; ; ; ;	;2331	hl=hl-4
      dec hl	    ; ; ; ;	;2332
      dec bc	    ; ; ; ;	;2333
      dec bc	    ; ; ; ;	;2334
      dec bc	    ; ; ; ;	;2335	bc=bc-4
      dec bc	    ; ; ; ;	;2336
    jp l2326h	    ; ; ; ;	;2337	--> ...
		    ; ; ; ;
l233ah:		;<--+ ; ; ;
    ld hl,(l0282h)    ; ; ;	;233a
    ld (l01cch),hl    ; ; ;	;233d	(l01cch)=(l0282h)
    ld hl,(HeapEnd)   ; ; ;	;2340
    ex de,hl	      ; ; ;	;2343
    ld hl,(l0206h)    ; ; ;	;2344
    call subHL_DE     ; ; ;	;2347	hl=hl-de
    ld (l0282h),hl    ; ; ;	;234a	(l0282h)=(l0206h)-(HeapEnd)
    ld a,0bh	      ; ; ;	;234d	a=0bh
    call s_1473h      ; ; ;	;234f	cd 73 14
    ld a,0ffh	      ; ; ;	;2352
    ld (l0284h),a     ; ; ;	;2354	(l0284h)=0ffh
    jp l230ah	 ;----)-; ;	;2357	--> ...
		      ; ; ;
l235ah:	   ;<---------+ ; ;
    sub 3		; ;	;235a	d6 03
    jp z,l2367h ;---;	; ;	;235c	ca 67 23
    dec a	    ;	; ;	;235f	3d
    jp z,l2389h ;-; ;	; ;	;2360	ca 89 23
    call err_msg  ; ;	; ;	;2363	Error (115)
    db 115	  ; ;	; ;	;2366	Invalid Data List Element in I/O
l2367h:	       ;<-)-+	; ;
    ld a,(l0298h) ;	; ;	    ;2367
    cp '='	  ;	; ;	    ;236a
    jp z,l2415h ;-)-----)-)-------; ;236c   if (l0298h).eq.'=' --> ...
l236fh:	     ;<---)-----)-)-----+ ;
    ld de,00001h  ;	; ;	! ; ;236f   de=1
l2372h:	     ;<---)-----)-)----.! ;
    call s_2466h  ;	; ;    .! ; ;2372   cd 66 24
l2375h:	     ;<---)-----)-)---;.! ;
    ld a,(l0298h) ;	; ;   ;.! ; ;2375
    cp ','	  ;	; ;   ;.! ; ;2378
    jp z,l230ah ;-)-----+ ;   ;.! ; ;237a   if (l0298h).eq.',' --> ...
    ld hl,(l0282h);	  ;   ;.! ; ;237d
    inc hl	  ;	  ;   ;.! ; ;2380
    ld a,h	  ;	  ;   ;.! ; ;2381
    or l	  ;	  ;   ;.! ; ;2382
    jp nz,l2439h  ;	  ;   ;.! ; ;2383   if (l0282h).ne.0ffh --> ...
    jp l22e5h ;---)-------+   ;.! ; ;2386   --> ...
		  ;	      ;.! ;
l2389h:	       ;<-+	      ;.! ;
    ld a,(l0298h)	      ;.! ; ;2389
    cp '('		      ;.! ; ;238c
    jp z,l240ah	      ;-----; ;.! ; ;238e   if (l0298h).eq.'(' --> ...
    ld a,(ScopeID)	    ; ;.! ; ;2391
    cp 3		    ; ;.! ; ;2394
    jp nz,l2404h   ;------; ! ;.! ; ;2396   if (ScopeID).eq.3 --> ...
    call s_46e9h	  ; ! ;.! ; ;2399   cd e9 46
    ld a,(l022dh)	  ; ! ;.! ; ;239c
    ld b,a		  ; ! ;.! ; ;239f   b=(l022dh)
    ld a,(l0275h)	  ; ! ;.! ; ;23a0
    or a		  ; ! ;.! ; ;23a3
    jp z,l2404h	   ;------; ! ;.! ; ;23a4   if (l0275h).eq.0 --> ...
    ld c,a		  ; ! ;.! ; ;23a7   c=(l0275h)
    ld hl,l23fch	  ; ! ;.! ; ;23a8
    push hl		  ; ! ;.! ; ;23ab \ Save l23fch
    ld hl,(l01cch)	  ; ! ;.! ; ;23ac
    push hl		  ; ! ;.! ; ;23af \ Save (l01cch)
    ld a,(TypeID)	  ; ! ;.! ; ;23b0
    push af		  ; ! ;.! ; ;23b3 \ Save (TypeID)
    ld hl,(l0269h)	  ; ! ;.! ; ;23b4
    ld (l0234h),hl	  ; ! ;.! ; ;23b7   (l0234h)=(l0269h)
    dec b		  ; ! ;.! ; ;23ba
    jp z,l23eeh ;-------; ; ! ;.! ; ;23bb   if (l022dh).eq.1 --> ...
    ld a,2		; ; ! ;.! ; ;23be
    ld (l0242h),a	; ; ! ;.! ; ;23c0   (l0242h)=2
    ld hl,(l026bh)	; ; ! ;.! ; ;23c3   2a 6b 02
    dec b		; ; ! ;.! ; ;23c6
    jp nz,l23dbh ;--;	; ; ! ;.! ; ;23c7   if (l022dh).ne.2 --> ...
    ld a,c	    ;	; ; ! ;.! ; ;23ca
    rra		    ;	; ; ! ;.! ; ;23cb
    jp c,l23d2h ;-; ;	; ; ! ;.! ; ;23cc   if (l0275h) ?? --> ...
l23cfh:	      ;<==)=)=I ; ; ! ;.! ;
    call s_0523h  ; ; I ; ; ! ;.! ; ;23cf   (l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
	     ;<---+ ; I ; ; ! ;.! ;
l23d2h:	     ;<---; ; I ; ; ! ;.! ;
    ld (l0236h),hl; ; I ; ; ! ;.! ; ;23d2   (l0236h)=
    call s_0ec6h  ; ; I ; ; ! ;.! ; ;23d5   cd c6 0e
    jp l23eeh  ;--)-)-)-; ; ! ;.! ; ;23d8   --> ...
		  ; ; I ; ; ! ;.! ;
l23dbh:	     ;<---)-+ I ; ; ! ;.! ;
    ld (l0236h),hl;   I ; ; ! ;.! ; ;23db   (l0236h)=
    push bc	  ;   I ; ; ! ;.! ; ;23de \
    call s_0ec6h  ;   I ; ; ! ;.! ; ;23df   cd c6 0e
    pop bc	  ;   I ; ; ! ;.! ; ;23e2 /
    ld a,c	  ;   I ; ; ! ;.! ; ;23e3   79
    rra		  ;   I ; ; ! ;.! ; ;23e4   1f
    ld hl,(l026dh);   I ; ; ! ;.! ; ;23e5   hl=(l026dh)
    jp c,l23d2h ;-+   I ; ; ! ;.! ; ;23e8   if a ? --> ...
    jp l23cfh ;=======+ ; ; ! ;.! ; ;23eb   --> ...
			; ; ! ;.! ;
l23eeh:		;<------+ ; ! ;.! ;
    ld hl,(l0234h)	  ; ! ;.! ; ;23ee
    ld (l01cch),hl	  ; ! ;.! ; ;23f1   (l01cch)=(l0234h)
    pop af		  ; ! ;.! ; ;23f4 / Restore (TypeID)
    push af		  ; ! ;.! ; ;23f5 \ f5
    ld (l0284h),a	  ; ! ;.! ; ;23f6   (l0284h)=
    jp l247fh	 ;----;	  ; ! ;.! ; ;23f9   --> ...
		      ;	  ; ! ;.! ;
l23fch:		      ;	  ; ! ;.! ;
    ld hl,l0284h      ;	  ; ! ;.! ; ;23fc
    ld (hl),0ffh      ;	  ; ! ;.! ; ;23ff   (l0284h)=0ffh
    jp l2375h	    ;-;---)-)-+.! ; ;2401   --> ...
		      ;	  ; ! ;.! ;
l2404h:		   ;--)---+ ! ;.! ;
    call s_5a24h      ;	    ! ;.! ; ;2404   cd 24 5a
    jp l2372h	   ;--;-----)-)+! ; ;2407   --> ...
		      ;	    ! ; ! ;
l240ah:		;<----)-----+ ; ! ;
    call s_4b20h      ;	      ; ! ; ;240a   cd 20 4b
    ld hl,l0284h      ;	      ; ! ; ;240d
    ld (hl),0ffh      ;	      ; ! ; ;2410   (l0284h)=0ffh
    jp l236fh	;-----)-------)-+ ; ;2412   --> ...
;		      ;	      ;	  ;
l2415h:	    ;<--------)-------)---+
    ld hl,l0286h      ;	      ;	    ;2415
    dec (hl)	      ;	      ;	    ;2418   (l0286h)=(l0286h)-1
    ld hl,(l0282h)    ;	      ;	    ;2419
    inc hl	      ;	      ;	    ;241c
    ld a,h	      ;	      ;	    ;241d
    or l	      ;	      ;	    ;241e
    jp nz,l2426h ;--; ;	      ;	    ;241f   if (l0282h).eq.1 --> skip error message
err116:		    ; ;	      ;
    call err_msg    ; ;	      ;	    ;2422   Error (116)
    db 116	    ; ;	      ;	    ;2425   Unbalanced DO Nest
		    ; ;	      ;
l2426h:		;<--+ ;	      ;
    ld a,(TypeID)     ;	      ;	    ;2426
    or a	      ;	      ;	    ;2429
    jp z,l2436h	 ;--; ;	      ;	    ;242a   if (TypeID).eq.0 (INTEGER)	 --> skip error message
    cp 2	    ; ;	      ;	    ;242d
    jp z,l2436h	 ;--; ;	      ;	    ;242f   if (TypeID).eq.2 (INTEGER*4) --> skip error message
    call err_msg    ; ;	      ;	    ;2432   Error (128)
    db 128	    ; ;	      ;	    ;2435   Missing Integer Quantity
		    ; ;	      ;
l2436h:	      ;<----+ ;	      ;
    call s_0d75h      ;	      ;	    ;2436   Processing DO loop parameters m1,m2, m3
l2439h:		      ;	      ;
    ld hl,(l01b0h)    ;	      ;	    ;2439
    ld (l01cch),hl    ;	      ;	    ;243c   (l01cch)=(l01b0h)
    ld b,h	      ;	      ;	    ;243f
    ld c,l	      ;	      ;	    ;2440   bc=hl=(l01b0h)
    ld hl,(l0282h)    ;	      ;	    ;2441
    ex de,hl	      ;	      ;	    ;2444
    ld hl,(l0206h)    ;	      ;	    ;2445
    call subHL_DE     ;	      ;	    ;2448   hl=hl-de=(l0206h)-(l0282h)
    dec hl	      ;	      ;	    ;244b
    dec hl	      ;	      ;	    ;244c   hl=(l0206h)-(l0282h)-2
    ld d,(hl)	      ;	      ;	    ;244d   56
    ld (hl),b	      ;	      ;	    ;244e   70
    dec hl	      ;	      ;	    ;244f   2b
    ld e,(hl)	      ;	      ;	    ;2450   5e
    ld (hl),c	      ;	      ;	    ;2451   71
    ex de,hl	      ;	      ;	    ;2452   eb
    ld (l0282h),hl    ;	      ;	    ;2453   (l0282h)=
    ld a,014h	      ;	      ;	    ;2456   3e 14
    call s_1473h      ;	      ;	    ;2458   cd 73 14
    call s_4e59h      ;	      ;	    ;245b   cd 59 4e
    ld hl,l0284h      ;	      ;	    ;245e
    ld (hl),0ffh      ;	      ;	    ;2461   (l0284h)=0ffh
    jp l2375h	 ;----)-------+	    ;2463   --> ...
;*		      ;
;*   ENTRY Reg DE=PAR ;
;*		      ;
s_2466h:	      ;
    ld a,(l0284h)     ;	    ;2466
    or a	      ;	    ;2469
    jp p,l2494h	 ;--; ;	    ;246a   if (l0284h) > 0 --> ...
l246dh:	      ;<----)-)-;
    ld a,(TypeID)   ; ; ;   ;246d
    ld (l0284h),a   ; ; ;   ;2470   (l0284h)=(TypeID)
    ld hl,(l01cch)  ; ; ;   ;2473   2a cc 01
    push hl	    ; ; ;   ;2476 \ Save (l01cch)
    push af	    ; ; ;   ;2477 \ Save (l0284h)
    ex de,hl	    ; ; ;   ;2478   hl=PAR	de=(l01cch)
    ld (l027fh),hl  ; ; ;   ;2479   (l027fh)=PAR
    call s_0523h    ; ; ;   ;247c   (l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
l247fh:	       ;<---)-+ ;
    call s_24a7h    ;	;   ;247f   Make call $Ix
    pop af	    ;	;   ;2482 / Restore (l0284h)
    ld (l0284h),a   ;	;   ;2483   (l0284h)=a
    ld a,6	    ;	;   ;2486   a=6
    call s_1473h    ;	;   ;2488   cd 73 14
    pop hl	    ;	;   ;248b / Restore (l01cch)
    call ExtAttr    ;	;   ;248c   Extract Attributes from the symbol table
l248fh:	   ;<-------)-; ;
    ld a,6	    ; ; ;   ;248f   a=6
    jp s_1473h	    ; ; ;   ;2491   --> ...
		    ; ; ;
l2494h:	      ;<----+ ; ;
    ld hl,TypeID      ; ;   ;2494
    cp (hl)	      ; ;   ;2497
    jp nz,l246dh   ;--)-;   ;2498   if (l0284h).ne.(TypeID) --> ...
    ld hl,(l027fh)    ; ;   ;249b   2a 7f 02
    call cmpHL_DE     ; ;   ;249e   Compare HL with DE
    jp z,l248fh	 ;----+ ;   ;24a1   if HL.eq.DE --> ...
    jp l246dh ;---------+   ;24a4   --> ...
;*
;*  Make call $Ix
;*
s_24a7h:
    ld a,(l0284h)	    ;24a7   a=(l0284h)
    ld hl,(l01cch)	    ;24aa
    push hl		    ;24ad \ Save (l01cch)
    ld hl,l01d6h	    ;24ae
    ld (hl),'$'		    ;24b1   (l01d6h)='$'
    dec hl		    ;24b3
    ld (hl),'I'		    ;24b4   (l01d5h)='I'
    dec hl		    ;24b6
    add a,'0'		    ;24b7   Convert binary decimal to ASCII from (l0284h)
    ld (hl),a		    ;24b9   (l01d4h)=ASCII from (l0284h)
    ld a,3		    ;24ba
    ld (SizeID),a	    ;24bc   (SizeID)=3
    ld a,5		    ;24bf
    ld (KindID),a	    ;24c1   (KindID)=5 (Routine)
    ld a,(l0298h)	    ;24c4
    push af		    ;24c7 \ Save (l0298h)
    ld a,028h		    ;24c8
    ld (l0298h),a	    ;24ca   (l0298h)=028h or "("
    call s_055ah	    ;24cd   cd 5a 05
    call s_1472h	    ;24d0   cd 72 14
    pop af		    ;24d3 / Restore (l0298h)
    ld (l0298h),a	    ;24d4
    ld a,0ffh		    ;24d7
    ld (l0284h),a	    ;24d9   (l0284h)=0ffh
    pop hl		    ;24dc / Restore (l01cch)
    jp ExtAttr		    ;24dd   --> Extract Attributes from the symbol table
;*
;*  Processing Dimension declarators
;*
DimDecl:
    ld hl,(l01cch)	    ;24e0
    push hl		    ;24e3 \ Save (l01cch)
    xor a		    ;24e4
    ld (NumDim),a	    ;24e5   (NumDim)=0 Clear Number of Dimension declarators
    ld a,'('		    ;24e8   a='('
    call ch_chr		    ;24ea   Check character (a character for check)
    ld a,(ScopeID)	    ;24ed
    ld (l0218h),a	    ;24f0   (l0218h)=(ScopeID)
    ld hl,l026fh	    ;24f3   21 6f 02
l24f6h:		;<----;
    push hl	      ;	    ;24f6 \ Save hl
    ld a,(l0267h)     ;	    ;24f7
    or a	      ;	    ;24fa
    jp z,l250ch	 ;--; ;	    ;24fb   if (l0267h).eq.0 --> ...
    ld a,(l0218h)   ; ;	    ;24fe
    cp 3	    ; ;	    ;2501
    jp nz,l250ch ;--; ;	    ;2503   if (l0218h).ne.3 --> ...
    call s_257ch    ; ;	    ;2506   Processing integer constant
    jp l250fh  ;--; ; ;	    ;2509   --> ...
		  ; ; ;
l250ch:	      ;<--)-+ ;
    call s_1b26h  ;   ;	    ;250c   Processing integer constant with test (KindID)=Constant
l250fh:	    ;<----+   ;
    ex de,hl	      ;	    ;250f   de=Addres declarator
    pop hl	      ;	    ;2510 / Restore hl
    ld (hl),e	      ;	    ;2511
    inc hl	      ;	    ;2512   hl=hl+1
    ld (hl),d	      ;	    ;2513   (hl)=Addres declarator
    inc hl	      ;	    ;2514   hl=hl+1
    ld a,(NumDim)     ;	    ;2515
    inc a	      ;	    ;2518
    ld (NumDim),a     ;	    ;2519   (NumDim)=(NumDim)+1
    cp 3	      ;	    ;251c
    jp z,l2529h	  ;-; ;	    ;251e   if (NumDim).eq.3 --> Processing is complete, permitted 3 declarator
    ld a,(l0298h)   ; ;	    ;2521
    cp ','	    ; ;	    ;2524   Test separator
    jp z,l24f6h	  ;-)-+	    ;2526   if (l0298h).eq.',' --> Processing next Dimension declarators
		    ;
l2529h:		;<--+
    call s_4e59h	    ;2529   cd 59 4e
    pop hl		    ;252c / hl=(l01cch)
    jp ExtAttr		    ;252d   --> Extract Attributes from the symbol table
;*
;*  Processing label
;*
PrLabel:
    call s_093ah	    ;2530 + (l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
l2533h:		 ;<-;
    call g_n_chr    ;	    ;2533 +
    jp p,err110	  ;-)---;   ;2536 + if chr.eq.Special character or Letter --> Error (110) Invalid Statement Number
    cp '0'	    ;	;   ;2539 +
    jp z,l2533h	 ;--+	;   ;253b + if chr.eq.'0'  skip leading 0
			;
    ld hl,l01d6h	;   ;253e   Pointer
    ld b,-5		;   ;2541 + Length label
l2543h:	     ;<-----;	;
      ld (hl),a	    ;	;   ;2543   (hl)=chr
      dec hl	    ;	;   ;2544 + hl=hl-1
      push bc	    ;	;   ;2545 +
      push hl	    ;	;   ;2546 +
      call g_n_chr  ;	;   ;2547 +
      pop hl	    ;	;   ;254a +
      pop bc	    ;	;   ;254b +
      jp p,l2557h ;-)-; ;   ;254c + if chr.eq.Special character or Letter --> Found chr not related to label
      inc b	    ; ; ;   ;254f + b=b+1
    jp m,l2543h ;---+ ; ;   ;2550 + if b<0 next char
		      ; ;
err110:	     ;<-------)-+
    call err_msg      ;	    ;2553 + Error (110)
    db 110	      ;	    ;2556 + Invalid Statement Number
		      ;
l2557h:		;<----+		  + Found chr not related to label
    xor a		    ;2557 +
    ld (TypeID),a	    ;2558 + (TypeID)=0 (INTEGER)
    ld a,2		    ;255b +
    ld (KindID),a	    ;255d + (KindID)=2 (Label)
    ld a,6		    ;2560
    add a,b		    ;2562
    ld (SizeID),a	    ;2563   (SizeID)=b+6
    jp s_055ah		    ;2566   --> ...
;*
;*  Processing integer constant & Test (KindID).ne.1
;*
s_2569h:
    call s_257ch	    ;2569   Processing integer constant
l256ch:	      ;<----;
    ld a,(KindID)   ;	    ;256c
    dec a	    ;	    ;256f
    ret nz	    ;	    ;2570   if (KindID).ne.1 (Constant) return
    call err_msg    ;	    ;2571   Warning (14)
    db 14	    ;	    ;2574   Missing Integer Variable
    ret		    ;	    ;2575
;		    ;
;   Processing integer constant with error checking & Test (KindID).ne.1
;		    ;
s_2576h:	    ;
    call s_2593h    ;	    ;2576   Processing integer constant with error checking
    jp l256ch	;---+	    ;2579   --> ...
;*
;*  Processing integer constant
;*
s_257ch:
    call s_1ca9h	    ;257c   cd a9 1c
    dec a		    ;257f
    jp z,l2588h	 ;---;	    ;2580   if (KindID).eq.1 (Constant) --> ...
    dec a	     ;	    ;2583
    dec a	     ;	    ;2584
    jp nz,err128 ;-; ;	    ;2585   if (KindID).ne.3 (Variable) --> Error (128) Missing Integer Quantity
l2588h:	      ;<---)-+
    ld a,(TypeID)  ;	    ;2588
    dec a	   ;	    ;258b
    ret m	   ;	    ;258c   if (TypeID) < 1 Return
    dec a	   ;	    ;258d
    ret z	   ;	    ;258e   if (TypeID).eq.2 (BYTE) Return
err128:	    ;<-----+
    call err_msg	    ;258f + Error (128)
    db 128		    ;2592 + Missing Integer Quantity
;*
;*  Processing integer constant with error checking
;*
s_2593h:
    call s_257ch	    ;2593   Processing integer constant
    jp z,err128		    ;2596   --> Error (128) Missing Integer Quantity
    ret			    ;2599
;
;+  Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
;
l259ah:
    ld a,1		    ;259a + a=1
;
;+  Save (l0299h) & (DO_Flg) -> Ending parsing statement
;
l259ch:
    ld (l0299h),a	    ;259c +
;
;+  Save (DO_Flg) -> Ending parsing statement
;
l259fh:
    ld (DO_Flg),a	    ;259f +
    jp l5763h		    ;25a2 + --> Ending parsing statement

;#################
;# END MODULE	 #
;#################

;#################
;# START MODULE	 #
;#################
;
;   'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'
;
s_25a5h:
    push bc		;25a5
    ld a,06fh		;25a6	'LD L,A'
    call PutOpc		;25a8
    ld a,017h		;25ab	'RLA'
    call PutOpc		;25ad
    ld a,09fh		;25b0	'SBC A,A'
    call PutOpc		;25b2
    ld a,067h		;25b5	'LD H,A'
    call PutOpc		;25b7
    xor a		;25ba	a=0
    pop bc		;25bb
    ret			;25bc
;
;
;
s_25bdh:
    call s_4788h	    ;25bd   cd 88 47
    ld hl,(l01aeh)	    ;25c0   2a ae 01
    call ExtAttr	    ;25c3   Extract Attributes from the symbol table
    call s_2dech	    ;25c6   cd ec 2d
    ld a,(TypeID)	    ;25c9
    cp 2		    ;25cc
    jp z,l2688h	 ;------;   ;25ce   if (TypeID).eq.2 (BYTE) --> ...
    ld hl,(l01a8h)	;   ;25d1   2a a8 01
    call ExtAttr	;   ;25d4   Extract Attributes from the symbol table
    xor a		;   ;25d7
    ld (TypeID),a	;   ;25d8   (TypeID)=0 (INTEGER)
    ld a,1		;   ;25db   a=1
    call s_294ah	;   ;25dd   cd 4a 29
    ld hl,(l01a6h)	;   ;25e0   2a a6 01
    call ExtAttr	;   ;25e3   Extract Attributes from the symbol table
    dec a		;   ;25e6
    jp nz,l260dh ;--;	;   ;25e7   if (KindID).ne.1 (Constant) --> ...
    ld a,03eh	    ;	;   ;25ea   'LD A,byte'
    call PutOpc	    ;	;   ;25ec
    ld a,(l01d3h)   ;	;   ;25ef   3a d3 01
    call p_byte	    ;	;   ;25f2   Put byte in reg A to REL file
    ld a,095h	    ;	;   ;25f5   'SUB L'
    call PutOpc	    ;	;   ;25f7
    ld a,03eh	    ;	;   ;25fa   'LD A,byte'
    call PutOpc	    ;	;   ;25fc
    ld a,(l01d4h)   ;	;   ;25ff   3a d4 01
    call p_byte	    ;	;   ;2602   Put byte in reg A to REL file
    ld a,09ch	    ;	;   ;2605   'SBC A,H'
    call PutOpc	    ;	;   ;2607
    jp l2635h	;---)-; ;   ;260a   --> ...
		    ; ; ;
l260dh:		;<--+ ; ;
    ld a,0ebh	      ; ;   ;260d   'EX DE,HL'
    call PutOpc	      ; ;   ;260f
    call s_2dech      ; ;   ;2612   cd ec 2d
    ld a,(i_Type)     ; ;   ;2615
    or a	      ; ;   ;2618
    call nz,s_25a5h   ; ;   ;2619   if (i_Type).eq.0 (INTEGER) {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld a,0ebh	      ; ;   ;261c   'EX DE,HL'
    call PutOpc	      ; ;   ;261e
    ld a,07bh	      ; ;   ;2621   'LD A,E'
    call PutOpc	      ; ;   ;2623
    ld a,095h	      ; ;   ;2626   'SUB L'
    call PutOpc	      ; ;   ;2628
    ld a,07ah	      ; ;   ;262b   'LD A,D'
    call PutOpc	      ; ;   ;262d
    ld a,09ch	      ; ;   ;2630   'SBC A,H'
    call PutOpc	      ; ;   ;2632
l2635h:		;<----; ;
    ld a,0f2h	      ; ;   ;2635   'JP P,word'
l2637h:	     ;<-------)-)-;
    push af	      ; ; ; ;2637 \ Save opcode ------------;
    ld hl,(l01aah)    ; ; ; ;2638			    ;
    ld (DataID),hl    ; ; ; ;263b   (DataID)=(l01aah)	    ;
    ld a,2	      ; ; ; ;263e			    ;
    ld (ScopeID),a    ; ; ; ;2640   (ScopeID)=2		    ;
    dec a	      ; ; ; ;2643			    ;
    ld (KindID),a     ; ; ; ;2644   (KindID)=1 (Constant)   ;
    ld hl,0ffffh      ; ; ; ;2647   21 ff ff		    ;
    pop af	      ; ; ; ;264a / Restore opcode <--------+
    call s_2ec6h      ; ; ; ;264b   cd c6 2e
    ld hl,(l01a4h)    ; ; ; ;264e
    ex de,hl	      ; ; ; ;2651
    ld hl,(HeapPtr)   ; ; ; ;2652
    call subHL_DE     ; ; ; ;2655
    ld b,h	      ; ; ; ;2658
    ld c,l	      ; ; ; ;2659   bc=(HeapPtr)-(l01a4h)
    push de	      ; ; ; ;265a \ Save (l01a4h)      -----+
    ld hl,-10	      ; ; ; ;265b			    ;
    push hl	      ; ; ; ;265e \ Save -10		    ;
    add hl,de	      ; ; ; ;265f			    ;
    ld (l01a4h),hl    ; ; ; ;2660   (l01a4h)=(l01a4h)-10    ;
    pop de	      ; ; ; ;2663 / Restore -10		    ;
    push hl	      ; ; ; ;2664 \ Save (l01a4h)      ---+ ;
    ld hl,(l0214h)    ; ; ; ;2665			  ; ;
    add hl,de	      ; ; ; ;2668			  ; ;
    ld (l0214h),hl    ; ; ; ;2669  (l0214h)=(l0214h)-10	  ; ;
    pop hl	      ; ; ; ;266c / hl=(l01a4h)-10     <--+ ;
    pop de	      ; ; ; ;266d / de=(l01a4h)	       <----+
;		      ; ; ;	    bc=(HeapPtr)-(l01a4h)
    ld a,b	      ; ; ; ;266e
    or c	      ; ; ; ;266f
    jp z,l267eh	 ;--; ; ; ; ;2670   if (HeapPtr)-(l01a4h).eq.0 --> ...
l2673h:	     ;<---; ; ; ; ;
      ld a,(de)	  ; ; ; ; ; ;2673
      ld (hl),a	  ; ; ; ; ; ;2674   (hl)=(de)
      inc hl	  ; ; ; ; ; ;2675   hl=hl+1
      inc de	  ; ; ; ; ; ;2676   de=de+1
      dec bc	  ; ; ; ; ; ;2677   bc=bc-1
      ld a,b	  ; ; ; ; ; ;2678
      or c	  ; ; ; ; ; ;2679
    jp nz,l2673h;-+ ; ; ; ; ;267a   if bc.ne.0 --> ...
    ex de,hl	    ; ; ; ; ;267d   eb
l267eh:		;<--+ ; ; ;
    ld (HeapPtr),hl   ; ; ; ;267e   (HeapPtr)=
l2681h:		      ; ; ;
    ld hl,00000h      ; ; ; ;2681   hl=0
    ld (l0250h),hl    ; ; ; ;2684   (l0250h)=0
    ret		      ; ; ; ;2687
		      ; ; ;
l2688h:		;<----)-+ ;
    ld hl,(l01a6h)    ;	  ; ;2688   hl=(l01a6h)
    call ExtAttr      ;	  ; ;268b   Extract Attributes from the symbol table
    ld a,(KindID)     ;	  ; ;268e
    dec a	      ;	  ; ;2691
    push af	      ;	  ; ;2692 \ Save value ------------------------------;
    ld hl,(l01a8h)    ;	  ; ;2693   hl=(l01a8h)				     ;
    call ExtAttr      ;	  ; ;2696   Extract Attributes from the symbol table ;
    ld a,2	      ;	  ; ;2699   a=2					     ;
    ld (TypeID),a     ;	  ; ;269b   (TypeID)=2 (BYTE)			     ;
    pop af	      ;	  ; ;269e / Restore value <--------------------------+
    jp nz,l26beh ;--; ;	  ; ;269f   if (KindID).ne.1 (Constant) --> ...
    ld a,1	    ; ;	  ; ;26a2   a=1
    call s_294ah    ; ;	  ; ;26a4   cd 4a 29
    ld a,0feh	    ; ;	  ; ;26a7   'CP byte'
    call PutOpc	    ; ;	  ; ;26a9
    ld hl,(l01a6h)  ; ;	  ; ;26ac   hl=(l01a6h)
    call ExtAttr    ; ;	  ; ;26af   Extract Attributes from the symbol table
    ld a,(l01d3h)   ; ;	  ; ;26b2
    inc a	    ; ;	  ; ;26b5   a=(l01d3h)+1
    call p_byte	    ; ;	  ; ;26b6   Put byte in reg A to REL file
    ld a,0fah	    ; ;	  ; ;26b9   'JP M,word'
    jp l2637h	 ;--)-)---; ;26bb   --> ...
		    ; ;	  ;
l26beh:	     ;<-----+ ;	  ;
    ld a,(KindID)     ;	  ; ;26be
    dec a	      ;	  ; ;26c1
    jp z,l26eah ;---; ;	  ; ;26c2   if (KindID).eq.1 (Constant) --> ...
l26c5h:	      ;<--; ; ;	  ;
    ld a,1	  ; ; ;	  ; ;26c5   a=1
    call s_294ah  ; ; ;	  ; ;26c7   cd 4a 29
    ld a,047h	  ; ; ;	  ; ;26ca   'LD B,A'
    call PutOpc	  ; ; ;	  ; ;26cc
    ld hl,(l01a6h); ; ;	  ; ;26cf   hl=(l01a6h)
    call ExtAttr  ; ; ;	  ; ;26d2   Extract Attributes from the symbol table
    ld a,2	  ; ; ;	  ; ;26d5   a=2
    ld (TypeID),a ; ; ;	  ; ;26d7   (TypeID)=2 (BYTE)
    call s_2dech  ; ; ;	  ; ;26da   cd ec 2d
    ld a,0b8h	  ; ; ;	  ; ;26dd   'CP B'
    call PutOpc	  ; ; ;	  ; ;26df
    ld a,078h	  ; ; ;	  ; ;26e2   'LD A,B'
    call PutOpc	  ; ; ;	  ; ;26e4
    jp l2635h	;-)-)-+	  ; ;26e7   --> ...
		  ; ;	  ;
l26eah:	    ;<----)-+	  ;
    ld a,(l01d3h) ;	  ; ;26ea
    dec a	  ;	  ; ;26ed
    jp nz,l26c5h;-+	  ; ;26ee   if (l01d3h).ne.1 --> ...
    ld hl,(l01a6h)	  ; ;26f1   hl=(l01a6h)
    call ExtAttr	  ; ;26f4   Extract Attributes from the symbol table
    call s_2ebbh	  ; ;26f7   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    ld a,0beh		  ; ;26fa   'CP (HL)'
    call PutOpc		  ; ;26fc
    ld hl,(l01a8h)	  ; ;26ff   hl=(l01a8h)
    call ExtAttr	  ; ;2702   Extract Attributes from the symbol table
    ld a,2		  ; ;2705   a=2
    ld (TypeID),a	  ; ;2707   (TypeID)=2 (BYTE)
    dec a		  ; ;270a   a=1
    call s_294ah	  ; ;270b   cd 4a 29
    ld a,0dah		  ; ;270e   'JP C,word'
    jp l2637h	;---------+ ;2710   --> ...
;
;   Processing GOTO
;
PrGoto:
    call s_14d4h	;2713 + g_n_chr; (l0173h)=chr
    ld hl,00000h	;2716	hl=0
    ld (l01cch),hl	;2719	(l01cch)=0
    jp p,l2745h	  ;---; ;271c + if chr Special character or Letter --> ...ASSIGNED GO TO
    call s_3169h      ; ;271f	cd 69 31
    call s_218ch      ; ;2722	Processing label & Test (TypeID).eq.INTEGER
    ld a,(l021fh)     ; ;2725
    or a	      ; ;2728
    jp nz,l273bh ;--; ; ;2729	if (l021fh).ne.0 --> ...
    ld hl,(l01cch)  ; ; ;272c
    ld (l020ch),hl  ; ; ;272f	(l020ch)=(l01cch)
    ld (l020eh),hl  ; ; ;2732	(l020eh)=(l01cch)
    ld (l0210h),hl  ; ; ;2735	(l0210h)=(l01cch)
    jp l259ah	    ; ; ;2738	--> Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
		    ; ;
l273bh:		;<--+ ;
    call s_30a9h      ; ;273b	cd a9 30
    xor a	      ; ;273e
    ld (l021fh),a     ; ;273f	(l021fh)=0
    jp l09e4h	      ; ;2742	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
		      ;
; ...ASSIGNED GO TO   ;
		      ;
l2745h:		;<----+
    push af		;2745 \ Save chr
    ld a,(l021fh)	;2746
    or a		;2749
    jp z,l2758h ;---;	;274a	if (l021fh).eq.0 --> ...
    call s_3169h    ;	;274d	cd 69 31
    call s_3725h    ;	;2750	cd 25 37
    ld a,0cah	    ;	;2753	'JP Z,word'
    call s_37d0h    ;	;2755	Put opcode & word=0000 to REL file
l2758h:		;<--+
    pop af		;2758 / f1
    jp nz,l2781h ;--;	;2759	c2 81 27
    call s_2576h    ;	;275c	Processing integer constant with error checking & Test (KindID).ne.1
    call s_1472h    ;	;275f	cd 72 14
    call s_3169h    ;	;2762	cd 69 31
    ld a,0e9h	    ;	;2765	'JP (HL)'
    call PutOpc	    ;	;2767
    ld a,1	    ;	;276a	a=1
    ld (l0275h),a   ;	;276c	(l0275h)=1
    ld a,(l0298h)   ;	;276f
    cp ','	    ;	;2772
    jp z,l278fh ;---)-; ;2774	if (l0298h).eq.',' --> ...
l2777h:		    ; ;
    ld a,(l021fh)   ; ; ;2777
    or a	    ; ; ;277a
    jp z,l259ah	    ; ; ;277b	if (l021fh).eq.0 --> Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
    jp l09e4h	    ; ; ;277e	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;		    ; ;
l2781h:		;<--+ ;
    call s_3169h      ; ;2781	cd 69 31
    xor a	      ; ;2784	a=0
    ld (l0275h),a     ; ;2785	(l0275h)=0
    ld h,a	      ; ;2788
    ld l,a	      ; ;2789	hl=0
    add hl,sp	      ; ;278a	hl=SP
    ld (l028fh),hl    ; ;278b	(l028fh)=SP
    push af	      ; ;278e \ f5
l278fh:		;<----+
    call g_n_chr	;278f +
    ld a,'('		;2792 + a='('
    call ch_chr		;2794 + Check character (a character for check)
l2797h:		;<----;
    call s_218ch      ; ;2797	Processing label & Test (TypeID).eq.INTEGER
    ld a,(l0275h)     ; ;279a
    or a	      ; ;279d
    jp nz,l27afh ;--; ; ;279e	if (l0275h).ne.0 --> ...
    call ChkStack   ; ; ;27a1	Check the stack
    ld hl,(l01cch)  ; ; ;27a4	2a cc 01
    ex (sp),hl	    ; ; ;27a7	e3
    inc h	    ; ; ;27a8	24
    xor a	    ; ; ;27a9	a=0
    or h	    ; ; ;27aa	b4
    jp z,l283bh	    ; ; ;27ab	if ??? --> Error (126) Illegal Character for Syntax ***
    push hl	    ; ; ;27ae \ e5
l27afh:		;<--+ ;
    ld a,(l0298h)     ; ;27af
    cp ','	      ; ;27b2
    jp z,l2797h	  ;---+ ;27b4	if (l0298h).eq.',' --> ...
    call s_4e59h	;27b7	cd 59 4e
    ld a,(l0275h)	;27ba
    or a		;27bd
    jp nz,l2777h	;27be	if (l0275h).ne.0 --> ...
    call ChComma	;27c1	Check ','
    call s_2569h	;27c4	Processing integer constant & Test (KindID).ne.1
    call s_2dech	;27c7	cd ec 2d
    ld a,(i_Type)	;27ca
    or a		;27cd
    jp z,l27d7h ;---;	;27ce	if (i_Type).eq.0 (INTEGER) --> ...
    call s_25a5h    ;	;27d1	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ;	;27d4	(i_Type)=0 (INTEGER)
l27d7h:		;<--+
    ld bc,'CG'		;27d7	$CG - Computed GOTO processor
    call CrBuilt	;27da	Creating built-in routine
;
;   (hl)=index value, other parameters
;   are passed inline: no. of labels - 1 byte
;   addres of lavel 1 -- 2 bytes
;   addres of lavel 2 -- 2 bytes
;   ...
;   addres of lavel n -- 2 bytes
;
    ld a,(NoCode)	;27dd
    or a		;27e0	test /N
    jp nz,l27f3h ;---;	;27e1	if (NoCode).ne.0  --> skip output
    call s_4f46h     ;	;27e4	if (Column).ne.0 Put cr lf to console
    call s_1465h     ;	;27e7	Print *****
    call s_3a70h     ;	;27ea	Put addres DATA' to console
    ld hl,l2842h     ;	;27ed	hl="DB"
    call PrStrg	     ;	;27f0	Print string
l27f3h:		;<---+
    pop af		;27f3 / f1
    push af		;27f4 \ f5
    call p_byte		;27f5	Put byte in reg A to REL file
    ld hl,(l028fh)	;27f8	2a 8f 02
    dec hl		;27fb	2b
l27fch:		;<----;
    ld d,(hl)	      ; ;27fc	56
    dec hl	      ; ;27fd	2b
    ld e,(hl)	      ; ;27fe	5e
    dec hl	      ; ;27ff	2b
    ex (sp),hl	      ; ;2800	e3
    push hl	      ; ;2801 \ e5
    ex de,hl	      ; ;2802	eb
    call ExtAttr      ; ;2803	Extract Attributes from the symbol table
    ld a,(NoCode)     ; ;2806
    or a	      ; ;2809	Test /N
    jp nz,l281fh ;--; ; ;280a	if (NoCode).ne.0  --> skip output
    call s_4f46h    ; ; ;280d	if (Column).ne.0 Put cr lf to console
    call s_1465h    ; ; ;2810	Print *****
    call s_3a70h    ; ; ;2813	Put addres DATA' to console
    ld hl,l283fh    ; ; ;2816	hl="DW"
    call PrStrg	    ; ; ;2819	Print string
    call s_3ae8h    ; ; ;281c	cd e8 3a
l281fh:		;<--+ ;
    call s_2ef2h      ; ;281f	cd f2 2e
    pop af	      ; ;2822 / f1
    dec a	      ; ;2823	3d
    ld h,a	      ; ;2824	67
    ex (sp),hl	      ; ;2825	e3
    jp nz,l27fch  ;---+ ;2826	c2 fc 27
    ld hl,(l028fh)	;2829	2a 8f 02
    ld sp,hl		;282c	Set for stack
    ld a,(l021fh)	;282d
    or a		;2830
    jp nz,l09e4h	;2831	if (l021fh).ne.0 --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
    ld (l0299h),a	;2834	(l0299h)=0
    inc a		;2837	a=1 (DO_Flg)
    jp l259fh		;2838	--> Save (DO_Flg) -> Ending parsing statement
;
l283bh:
    call err_msg	;283b + Error (126)
    db 07eh		;283e + Illegal Character for Syntax
;
l283fh:
    db tab
    dc 'DW'		;283f
;
l2842h:
    db tab,'DB',_tab	;2842
;
;
;
s_2846h:
    ld hl,(l020ch)	  ;2846
    ld a,h		  ;2849
    or l		  ;284a
    ret z		  ;284b if(l020ch).eq.0 Return
    ex de,hl		  ;284c
    ld hl,(l020eh)	  ;284d
    call cmpHL_DE	  ;2850 Compare HL with DE
    jp nz,l2880h  ;---;	  ;2853 if (l020eh).ne.(l020ch) --> ...
    ld hl,(l0210h)    ;	  ;2856
    call cmpHL_DE     ;	  ;2859 Compare HL with DE
    jp z,l2873h	  ;-; ;	  ;285c if (l0210h).eq.(l020ch) --> ...
    ld (l020ch),hl  ; ;	  ;285f 22 0c 02
    ex de,hl	    ; ;	  ;2862 eb
    ld (l0210h),hl  ; ;	  ;2863 22 10 02
    ld a,02fh	    ; ;	  ;2866 'CPL'
    call PutOpc	    ; ;	  ;2868
    ld a,03ch	    ; ;	  ;286b 'INC A'
    call PutOpc	    ; ;	  ;286d
    jp l28bbh	;---)-)-; ;2870 --> ...
		    ; ; ;
l2873h:	      ;<----+ ; ;
    ld hl,(l0263h)    ; ; ;2873 2a 63 02
    call cmpHL_DE     ; ; ;2876 Compare HL with DE
    ret z	      ; ; ;2879 if HL eq DE return
    ex de,hl	      ; ; ;287a eb
l287bh:		      ; ;
    ld a,0c3h	      ; ; ;287b 'JP word'
    jp s_2ec6h	      ; ; ;287d --> ...
		      ; ;
l2880h:		;<----+ ;
    ld hl,(l0210h)	; ;2880 2a 10 02
    call cmpHL_DE	; ;2883 Compare HL with DE
    jp nz,l28b1h  ;---; ; ;2886 if HL.ne.DE --> ...
    ld hl,(l0263h)    ; ; ;2889 2a 63 02
    ex de,hl	      ; ; ;288c eb
    ld hl,(l020eh)    ; ; ;288d 2a 0e 02
    call cmpHL_DE     ; ; ;2890 Compare HL with DE
    jp nz,l289eh ;--; ; ; ;2893 if HL ne DE --> ...
    ld hl,(l020ch)  ; ; ; ;2896 2a 0c 02
    ld a,0c2h	    ; ; ; ;2899 'JP NZ,word'
    jp s_2ec6h	    ; ; ; ;289b --> ...
		    ; ; ;
l289eh:	      ;<----+ ; ;
    ld a,0cah	      ; ; ;289e 'JP Z,word'
    call s_2ec6h      ; ; ;28a0 cd c6 2e
    ld hl,(l0263h)    ; ; ;28a3 2a 63 02
    ex de,hl	      ; ; ;28a6 eb
    ld hl,(l020ch)    ; ; ;28a7 2a 0c 02
    call cmpHL_DE     ; ; ;28aa Compare HL with DE
    ret z	      ; ; ;28ad if HL eq DE Return
    jp l287bh	      ; ; ;28ae --> ...
		      ; ;
l28b1h:		;<----+ ;
    ex de,hl		; ;28b1 eb
    ld hl,(l020eh)	; ;28b2 2a 0e 02
    call cmpHL_DE	; ;28b5 Compare HL with DE
    jp nz,l28e6h  ;---; ; 28b8	if HL ne DE --> ...
l28bbh:		;<----)-+
    ld hl,(l0263h)    ;	  ;28bb 2a 63 02
    ex de,hl	      ;	  ;28be eb
    ld hl,(l020ch)    ;	  ;28bf 2a 0c 02
    call cmpHL_DE     ;	  ;28c2 Compare HL with DE
    jp nz,l28d0h  ;-; ;	  ;28c5 if HL ne DE --> ...
    ld hl,(l020eh)  ; ;	  ;28c8 2a 0e 02
l28cbh:		;<--)-)-;
    ld a,0f2h	    ; ; ; ;28cb 'JP P,word'
    jp s_2ec6h	    ; ; ; ;28cd --> ...
		    ; ; ;
l28d0h:	      ;<----+ ; ;
    ld a,0fah	      ; ; ;28d0 'JP M,word'
    call s_2ec6h      ; ; ;28d2 cd c6 2e
    ld hl,(l0263h)    ; ; ;28d5 2a 63 02
    ex de,hl	      ; ; ;28d8 eb
    ld hl,(l020eh)    ; ; ;28d9 2a 0e 02
    call cmpHL_DE     ; ; ;28dc Compare HL with DE
    ret z	      ; ; ;28df if HL eq DE Return
    ld (l020ch),hl    ; ; ;28e0 22 0c 02
    jp l287bh	      ; ; ;28e3 --> ...
		      ; ;
l28e6h:		  ;<--+ ;
    ld hl,(l0263h)	; ;28e6 2a 63 02
    ex de,hl		; ;28e9 eb
    ld hl,(l020ch)	; ;28ea 2a 0c 02
    call cmpHL_DE	; ;28ed Compare HL with DE
    jp nz,l2901h ;--;	; ;28f0 if HL ne DE --> ...
l28f3h:	      ;<----)-; ;
    ld hl,(l020eh)  ; ; ; ;28f3 2a 0e 02
    ld a,0cah	    ; ; ; ;28f6 'JP Z,word'
    call s_2ec6h    ; ; ; ;28f8 cd c6 2e
    ld hl,(l0210h)  ; ; ; ;28fb 2a 10 02
    jp l28cbh	;---)-)-+ ;28fe --> ...
		    ; ;
l2901h:	      ;<----+ ;
    ld a,0fah	      ;	  ;2901 'JP M,word'
    call s_2ec6h      ;	  ;2903 cd c6 2e
    ld hl,(l0263h)    ;	  ;2906 2a 63 02
    ex de,hl	      ;	  ;2909 eb
    ld hl,(l020eh)    ;	  ;290a 2a 0e 02
    call cmpHL_DE     ;	  ;290d Compare HL with DE
    jp nz,l291bh ;--; ;	  ;2910 if HL ne DE --> ...
    ld hl,(l0210h)  ; ;	  ;2913 2a 10 02
    ld a,0c2h	    ; ;	  ;2916 'JP NZ,word'
    jp s_2ec6h	    ; ;	  ;2918 --> ...
		    ; ;
l291bh:	      ;<----+ ;
    ld hl,(l0210h)    ;	  ;291b 2a 10 02
    call cmpHL_DE     ;	  ;291e Compare HL with DE
    jp nz,l28f3h   ;--+	  ;2921 if HL ne DE --> ...
    ld hl,(l020eh)	  ;2924 2a 0e 02
    ld a,0cah		  ;2927 'JP Z,word'
    jp s_2ec6h		  ;2929 --> ...
;
l292ch:
    ld a,0afh		;292c	'XOR A'
    call PutOpc		;292e
    ld a,095h		;2931	'SUB L'
    call PutOpc		;2933
    ld a,06fh		;2936	'LD L,A'
    call PutOpc		;2938
    ld a,09ch		;293b	'SBC A,H'
    call PutOpc		;293d
    ld a,095h		;2940	'SUB L'
    call PutOpc		;2942
    ld a,067h		;2945	'LD H,A'
IF  V3_44
;   call PutOpc		;	Ver 3.44
;   jp l2681h		;	--> (l0250h)=0 ret
ELSE
    jp PutOpc		;2947	--> ...
ENDIF			; V3_44
;
;   ENTRY
;     Reg a - Arithmetic operator:
;      0 - ?
;      1 - Addition
;      2 - Multiplication
;      3 - Subtraction
;      4 - Division
;	 - Exponentiation
;      7 - ?
;
s_294ah:
    or a			;294a
    jp z,s_2dech		;294b	if par.eq.0 --> ...
    cp 7			;294e
    jp nc,l2c67h		;2950	if par >= 7 --> ...
    ld b,a			;2953	Save par
    ld a,(KindID)		;2954
    dec a			;2957
    jp nz,l2bb1h		;2958	if (KindID).ne.1 (Constant)  --> ...
    ld a,(TypeID)		;295b
    dec a			;295e
    jp z,l2ad1h			;295f	if (TypeID).eq.1 (REAL)	     --> ...
    cp 2			;2962
    jp z,l2aa6h			;2964	if (TypeID).eq.3 (DOUBLE)    --> ...
    cp 3			;2967
    jp z,l2bb1h			;2969	if (TypeID).eq.4 (INTEGER*4) --> ...
    ld a,(i_Type)		;296c
    dec a			;296f
    jp z,l2b1ch			;2970	if (i_Type).eq.1 (REAL)	     --> ...
    cp 2			;2973
    jp z,l2b1ch			;2975	if (i_Type).eq.3 (DOUBLE)    --> ...
    cp 3			;2978
    jp z,l2b1ch			;297a	if (i_Type).eq.4 (INTEGER*4) --> ...
    dec a			;297d
    jp z,l29d8h	 ;----------;	;297e	if (i_Type).eq.2 (BYTE)	     --> ...
    xor a		    ;	;2981
    ld (TypeID),a	    ;	;2982	(TypeID)=0 (INTEGER)
    ld a,b		    ;	;2985	Restore par
    cp 3		    ;	;2986
    jp nz,l29d1h   ;----;   ;	;2988	if par.ne.3 (Subtraction) --> ...
    ld hl,(l01d3h)	;   ;	;298b	2a d3 01
    call Neg_HL		;   ;	;298e	Negate HL
l2991h:	       ;<-------)-; ;
    ld a,h		; ; ;	;2991	7c
    or a		; ; ;	;2992	b7
    jp m,l29a7h ;---;	; ; ;	;2993	if a < 0 --> ...
    or l	    ;	; ; ;	;2996	b5
    ret z	    ;	; ; ;	;2997	c8
    ld de,00004h    ;	; ; ;	;2998	de=4
    call cmpHL_DE   ;	; ; ;	;299b	Compare HL with DE
    jp nc,l29c6h  ;-)-; ; ; ;	;299e	if HL >= DE --> ...
    ld c,l	    ; ; ; ; ;	;29a1	4d
    ld a,023h	    ; ; ; ; ;	;29a2	'INC HL'
    jp l29b8h ;---; ; ; ; ; ;	;29a4	--> Put the opcode C times
		  ; ; ; ; ; ;
l29a7h:	   ;<-----)-+ ; ; ; ;
    inc hl	  ;   ; ; ; ;	;29a7
    inc hl	  ;   ; ; ; ;	;29a8
    inc hl	  ;   ; ; ; ;	;29a9	hl=hl+3
    ld a,h	  ;   ; ; ; ;	;29aa
    or a	  ;   ; ; ; ;	;29ab
    dec hl	  ;   ; ; ; ;	;29ac
    dec hl	  ;   ; ; ; ;	;29ad
    dec hl	  ;   ; ; ; ;	;29ae	hl=hl-3
    jp m,l29c6h ;-)---; ; ; ;	;29af	if h < 0 --> ...
    ld a,l	  ;   ; ; ; ;	;29b2	7d
    cpl		  ;   ; ; ; ;	;29b3	2f
    inc a	  ;   ; ; ; ;	;29b4	3c
    ld c,a	  ;   ; ; ; ;	;29b5	4f
    ld a,02bh	  ;   ; ; ; ;	;29b6	'DEC HL'
;		  ;   ; ; ; ;
l29b8h:	     ;<---+   ; ; ; ;		Put the opcode C times
t29b8h:		;<--; ; ; ; ;
      push af	    ; ; ; ; ;	;29b8
      push bc	    ; ; ; ; ;	;29b9
      call PutOpc   ; ; ; ; ;	;29ba	Put opcode
      pop bc	    ; ; ; ; ;	;29bd
      pop af	    ; ; ; ; ;	;29be
      dec c	    ; ; ; ; ;	;29bf	c=c-1
    jp nz,t29b8h ;--+ ; ; ; ;	;29c0	if c.ne.0 --> put next
    jp l2681h	      ; ; ; ;	;29c3	--> (l0250h)=0 ret
;		      ; ; ; ;
l29c6h:	       ;<-----+ ; ; ;
    ld a,011h		; ; ;	;29c6	'LD DE,word'
    call s_2ea6h	; ; ;	;29c8	Put opcode & addres in HL to console & REL file
    call s_2b83h	; ; ;	;29cb	'ADD HL,DE'; (l0250h)=0 ret
    jp l2681h		; ; ;	;29ce	--> (l0250h)=0 ret
			; ; ;
;    par.ne.3		; ; ;
			; ; ;
l29d1h:		;<------+ ; ;
    dec a		  ; ;	;29d1
    ld hl,(l01d3h)	  ; ;	;29d2	hl=(l01d3h)
    jp z,l2991h	   ;------+ ;	;29d5	if par.eq.1 (Addition) --> ...
			    ;
;   (i_Type).eq.2 (BYTE)    ;
			    ;
l29d8h:		    ;<------+
    ld hl,l01d4h		;29d8
    ld a,(hl)			;29db
    or a		    ;29dc
    jp z,l2a1dh	  ;-----;   ;29dd   if (l01d4h).eq.0 --> ...
    dec a		;   ;29e0
    jp nz,l2a0dh   ;--; ;   ;29e1   if (l01d4h).ne.1 --> ...
    ld a,b	      ; ;   ;29e4   Restore par
    sub 2	      ; ;   ;29e5
    jp nz,l2a0dh   ;--; ;   ;29e7   if par.ne.2 (Multiplication) --> ...
    dec hl	      ; ;   ;29ea   2b
    or (hl)	      ; ;   ;29eb   b6
    jp nz,l2a0dh   ;--; ;   ;29ec   c2 0d 2a --> ...
    ld a,(i_Type)     ; ;   ;29ef
    or a	      ; ;   ;29f2
    jp nz,l2a04h;-;   ; ;   ;29f3   if (i_Type).ne.0 (INTEGER) --> ...
    ld a,065h	  ;   ; ;   ;29f6   'LD H,L'
l29f8h:	       ;<-)-; ; ;
    call PutOpc	  ; ; ; ;   ;29f8
    ld a,02eh	  ; ; ; ;   ;29fb   'LD L,byte'
    call PutOpc	  ; ; ; ;   ;29fd
    xor a	  ; ; ; ;   ;2a00   a=0
    jp p_byte	  ; ; ; ;   ;2a01   Put byte in reg A to REL file
		  ; ; ; ;
l2a04h:	     ;<---+ ; ; ;
    xor a	    ; ; ;   ;2a04   a=0
    ld (i_Type),a   ; ; ;   ;2a05   (i_Type)=0 (INTEGER)
    ld a,067h	    ; ; ;   ;2a08   'LD H,A'
    jp l29f8h	;---+ ; ;   ;2a0a
		      ; ;
l2a0dh:	    ;<--------+ ;
    ld a,(i_Type)	;   ;2a0d
    or a		;   ;2a10
    jp z,l2b6ch		;   ;2a11   if (i_Type).eq.0 (INTEGER) --> ...
    call s_25a5h	;   ;2a14   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a	;   ;2a17   (i_Type)=0 (INTEGER)
    jp l2b6ch		;   ;2a1a   --> ...
			;
l2a1dh:		;<------+
    dec hl		    ;2a1d
    ld a,(hl)		    ;2a1e
    or a		    ;2a1f
    jp nz,l2a43h ;--;	    ;2a20   if (l01d3h).ne.0 --> ...
    ld a,b	    ;	    ;2a23   Restore par
    dec a	    ;	    ;2a24
    ret z	    ;	    ;2a25   if par.eq.1 (Addition) Return
    dec a	    ;	    ;2a26
    jp z,s_2dech    ;	    ;2a27   if par.eq.2 (Multiplication) --> ...
    dec a	    ;	    ;2a2a
    ret z	    ;	    ;2a2b   if par.eq.3 (Subtraction) Return
    dec a	    ;	    ;2a2c
    ld hl,(l023eh)  ;	    ;2a2d   2a 3e 02
    jp nz,l2b16h ;--)-----; ;2a30   if par.ne.4 (Division) --> ...
    push bc	    ;	  ; ;2a33 \
    call err_msg    ;	  ; ;2a34   Warning (30)
    db 30	    ;	  ; ;2a37   Division by Zero
    jp l2a3ch ;--;  ;	  ; ;2a38   --> ...
		 ;  ;	  ;
l2a3bh:	    ;<---)--)---; ;
    push bc	 ;  ;	; ; ;2a3b \
l2a3ch:	     ;<--+  ;	; ;
    call s_2dc5h    ;	; ; ;2a3c   cd c5 2d
    pop bc	    ;	; ; ;2a3f /
    jp l2b35h	    ;	; ; ;2a40   --> Building built-in arithmetic routine
		    ;	; ;
l2a43h:		;<--+	; ;
    dec a		; ; ;2a43
    jp nz,l2a50h ;--;	; ; ;2a44   if (l01d3h).ne.1 --> ...
    ld a,b	    ;	; ; ;2a47   Restore par
    sub 2	    ;	; ; ;2a48
    ret z	    ;	; ; ;2a4a   if par.eq.2 (Multiplication) Return
    sub 2	    ;	; ; ;2a4b
    ret z	    ;	; ; ;2a4d   if par.ne.4 (Division) Return
    dec a	    ;	; ; ;2a4e
    ret z	    ;	; ; ;2a4f   if par.ne.5 (?) Return
l2a50h:		;<--+	; ;
    ld a,(i_Type)	; ; ;2a50
    cp 2		; ; ;2a53
    jp nz,l2a8dh  ;---; ; ; ;2a55   if (i_Type).ne.2 (REAL)   --> ...
    ld a,b	      ; ; ; ;2a58   Restore par
    dec a	      ; ; ; ;2a59
    jp z,l2a62h ;-;   ; ; ; ;2a5a   if par.eq.1 (Addition)    --> ...
    sub 2	  ;   ; ; ; ;2a5d
    jp nz,l2a87h;-)-; ; ; ; ;2a5f   if par.ne.3 (Subtraction) --> ...
l2a62h:	      ;<--+ ; ; ; ;
    ld a,(l01d3h)   ; ; ; ; ;2a62
    dec a	    ; ; ; ; ;2a65
    jp nz,l2a75h;-; ; ; ; ; ;2a66   if (l01d3h).eq.1 --> ...
    ld a,b	  ; ; ; ; ; ;2a69   Restore par
    dec a	  ; ; ; ; ; ;2a6a
    ld a,03dh	  ; ; ; ; ; ;2a6b   'DEC A'
    jp nz,PutOpc  ; ; ; ; ; ;2a6d   if par.ne.1 (Addition) 'DEC A'
    ld a,03ch	  ; ; ; ; ; ;2a70   else		   'INC A'
    jp PutOpc	  ; ; ; ; ; ;2a72   --> ...
		  ; ; ; ; ;
l2a75h:	      ;<--+ ; ; ; ;
    ld a,b	    ; ; ; ; ;2a75   Restore par
    dec a	    ; ; ; ; ;2a76
    ld a,0d6h	    ; ; ; ; ;2a77   'SUB byte'
    jp nz,l2a7eh;-; ; ; ; ; ;2a79   if par.eq.1 (Addition) --> ...
    ld a,0c6h	  ; ; ; ; ; ;2a7c   'ADD A,byte'
l2a7eh:	      ;<--+ ; ; ; ;
    call PutOpc	    ; ; ; ; ;2a7e
    ld a,(l01d3h)   ; ; ; ; ;2a81   a=(l01d3h)
    jp p_byte	    ; ; ; ; ;2a84   --> Put byte in reg A to REL file
		    ; ; ; ;
l2a87h:		;<--+ ; ; ;
    call s_25a5h      ; ; ; ;2a87   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a     ; ; ; ;2a8a   (i_Type)=0 (INTEGER)
l2a8dh:	    ;<--------+ ; ;
    ld a,b		; ; ;2a8d   Restore par
    cp 2		; ; ;2a8e
    jp nz,l2b6ch	; ; ;2a90   if par.ne.2 (Multiplication) --> ...
    ld a,(l01d3h)	; ; ;2a93   3a d3 01
    ld c,0ffh		; ; ;2a96   0e ff
l2a98h:		;<--;	; ;
      rra	    ;	; ; ;2a98   1f
      inc c	    ;	; ; ;2a99   0c
    jp nc,l2a98h ;--+	; ; ;2a9a   if c not set --> ...
    or a		; ; ;2a9d   b7
    jp nz,l2a3bh   ;----+ ; ;2a9e   c2 3b 2a
    ld a,029h		  ; ;2aa1   'ADD HL,HL'
    jp l29b8h		  ; ;2aa3   --> Put the opcode C times
			  ;
;   (TypeID)=3 DOUBLE	  ;
		    ;	  ;
l2aa6h:	      ;<----+	  ;
    ld hl,l2abbh	  ; ;2aa6   Point to l2abbh
    push hl		  ; ;2aa9   Save to return
    ld a,(i_Type)	  ; ;2aaa
    cp 3		  ; ;2aad
    ret z     ;-----;	  ; ;2aaf ;-if (i_Type).eq.3 (DOUBLE) Return to l2abbh
    or a	    ;	  ; ;2ab0 ;
    jp z,l09f9h	    ;	  ; ;2ab1 ;-if (i_Type).eq.0 (INTEGER) --> Converting $CC Integer to Double; Return to l2abbh
    dec a	    ;	  ; ;2ab4 ;
    jp z,l09fch	    ;	  ; ;2ab5 ;-if (i_Type).eq.1 (REAL) --> Converting $CK Real to Double; Return to l2abbh
    jp l09f6h	    ;	  ; ;2ab8 ;  --> Converting - $CS; Return to l2abbh
		    ;	  ;	  ;
l2abbh:		;<--+	  ; <-----+
    ld (i_Type),a	  ; ;2abb   (i_Type)= according on the type of conversion
    ld hl,(l01cch)	  ; ;2abe
    ex de,hl		  ; ;2ac1
    ld hl,(l02aeh)	  ; ;2ac2
    call cmpHL_DE	  ; ;2ac5   Compare HL with DE
    jp z,l2b06h	    ;---; ; ;2ac8   if (l02aeh).eq.(l01cch) --> ...
    ld hl,(l023ch)	; ; ;2acb   2a 3c 02
    jp l2af4h	 ;----; ; ; ;2ace   --> ...
		      ; ; ;
;   (TypeID)=1 REAL   ; ; ;
		  ;   ; ; ;
l2ad1h:	      ;<--+   ; ; ;
    ld a,(i_Type)     ; ; ; ;2ad1
    dec a	      ; ; ; ;2ad4
    jp z,l2ae4h	 ;--; ; ; ; ;2ad5   if (i_Type).eq.1 (REAL) --> ...
    cp 2	    ; ; ; ; ;2ad8
    jp z,l2ae4h	 ;--; ; ; ; ;2ada   if (i_Type).eq.3 (DOUBLE) --> ...
    dec a	    ; ; ; ; ;2add
    call z,s_25a5h  ; ; ; ; ;2ade   if (i_Type).eq.4 (INTEGER*4) {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    call s_09e8h    ; ; ; ; ;2ae1   Converting value Integer to Real $AC=FLOAT(HL)
l2ae4h:	      ;<----+ ; ; ;
    ld hl,(l01cch)    ; ; ; ;2ae4
    ex de,hl	      ; ; ; ;2ae7
    ld hl,(l02b2h)    ; ; ; ;2ae8
    call cmpHL_DE     ; ; ; ;2aeb   Compare HL with DE
    jp z,l2b06h	  ;---)-; ; ;2aee   if (l02b2h).eq.(l01cch) --> ...
    ld hl,(l0240h)    ; ; ; ;2af1   2a 40 02
l2af4h:		;<----+ ; ;
    call cmpHL_DE	; ; ;2af4   Compare HL with DE
    ld a,b		; ; ;2af7   Restore par
    jp nz,l2b30h ;----; ; ; ;2af8   if HL ne DE --> ...
    sub 2	      ; ; ; ;2afb
    ret z	      ; ; ; ;2afd   if par.eq.2 (Multiplication) Return
    sub 2	      ; ; ; ;2afe
    ret z	      ; ; ; ;2b00   if par.eq.4 (Division) Return
    dec a	      ; ; ; ;2b01
    ret z	      ; ; ; ;2b02   if par.eq.5 (?) Return
    jp l2b30h	 ;----; ; ; ;2b03   --> ...
		      ; ; ;
l2b06h:	     ;<-------)-+ ;
    ld a,b	      ;	  ; ;2b06   Restore par
    dec a	      ;	  ; ;2b07
    ret z	      ;	  ; ;2b08   if par.eq.1 (Addition) Return
    dec a	      ;	  ; ;2b09
    jp z,s_2dech      ;	  ; ;2b0a   if par.eq.2 (Multiplication) --> ...
    dec a	      ;	  ; ;2b0d
    ret z	      ;	  ; ;2b0e   if par.eq.3 (Subtraction) Return
    dec a	      ;	  ; ;2b0f
    jp z,l2b28h ;---; ;	  ; ;2b10   if par.eq.4 (Division) --> ...
    ld hl,(l0240h)  ; ;	  ; ;2b13   hl=(l0241h)
l2b16h:	     ;<-----)-)---+
    call ExtAttr    ; ;	    ;2b16   Extract Attributes from the symbol table
    jp s_2dech	    ; ;	    ;2b19   --> ...
		    ; ;
; (i_Type)=1 REAL   ; ;
;	  =3 DOUBLE ; ;
;	  =4 INT*4  ; ;
l2b1ch:		    ; ;
    push bc	    ; ;	    ;2b1c \
    call s_2ea1h    ; ;	    ;2b1d   Put "LD HL,word" & addres in (l01d3h) to console & REL file
    pop bc	    ; ;	    ;2b20 /
    xor a	    ; ;	    ;2b21   a=0
    ld (TypeID),a   ; ;	    ;2b22   (TypeID)=0 (INTEGER)
    jp l2b35h  ;--; ; ;	    ;2b25   --> Building built-in arithmetic routine
		  ; ; ;
l2b28h:	     ;<---)-+ ;
    push bc	  ;   ;	    ;2b28   c5
    call err_msg  ;   ;	    ;2b29   Warning (30)
    db 01eh	  ;   ;	    ;2b2c   Division by Zero
    jp l2b31h ;-; ;   ;	    ;2b2d
		; ;   ;
l2b30h:	  ;<----)-;---+
    push bc	; ;	    ;2b30 \ c5
l2b31h:	   ;<---+ ;
    call s_2ebbh  ;	    ;2b31   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    pop bc	  ;	    ;2b34 / c1
		  ;
l2b35h:	      ;<--+
;
;   Building built-in arithmetic routine
;
;   Reg B - First character of the built-in routine corresponds to
;	    the first letter of the name of an arithmetic operator
;
    ld a,b		    ;2b35   Restore par
    dec a		    ;2b36
    ld b,'A'		    ;2b37   b='A'
    jp z,l2b50h ;-;	    ;2b39   if par.eq.1 (Addition)
    dec a	  ;	    ;2b3c
    ld b,'M'	  ;	    ;2b3d   b='M'
    jp z,l2b50h ;-;	    ;2b3f   if par.eq.2 (Multiplication)
    dec a	  ;	    ;2b42
    ld b,'S'	  ;	    ;2b43   b='S'
    jp z,l2b50h ;-;	    ;2b45   if par.eq.3 (Subtraction)
    dec a	  ;	    ;2b48
    ld b,'D'	  ;	    ;2b49   b='D'
    jp z,l2b50h ;-;	    ;2b4b   if par.eq.4 (Division)
    ld b,'E'	  ;	    ;2b4e   b='E'
		  ;				(Exponentiation)
l2b50h:	     ;<---+
;
;   Reg C - The Second character built-in routine is calculated
;	    depending on the operands of an arithmetic expression
;
    ld a,(i_Type)	    ;2b50
    rlca		    ;2b53
    rlca		    ;2b54
    rlca		    ;2b55
    add a,'9'		    ;2b56
    ld hl,TypeID	    ;2b58
    add a,(hl)		    ;2b5b   a=(i_Type)*8+'9'+(TypeID)
    cp 'U'		    ;2b5c
    jp nz,l2b62h;-;	    ;2b5e   if a.ne.'U'
    inc a	  ;	    ;2b61   a=a+1
l2b62h:	     ;<---+
    cp 'T'		    ;2b62
    jp nz,l2b68h;-;	    ;2b64   if a.ne.'T'
    inc a	  ;	    ;2b67   a=a+1
l2b68h:	     ;<---+
    ld c,a		    ;2b68   Load Second character
    jp CrBuilt		    ;2b69   --> Creating built-in routine
;
l2b6ch:
    push bc		    ;2b6c \ c5
    call s_2dc5h	    ;2b6d   cd c5 2d
    pop bc		    ;2b70 / c1
    ld a,(TypeID)	    ;2b71
    or a		    ;2b74
    jp z,l2b7eh	 ;--;	    ;2b75   if (TypeID).eq.0 (INTEGER) --> ...
    call s_25a5h    ;	    ;2b78   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (TypeID),a   ;	    ;2b7b   (TypeID)=0 (INTEGER)
l2b7eh:		;<--+<----;
    ld a,b		  ; ;2b7e   Restore par
    dec a		  ; ;2b7f
    jp nz,l2b8bh ;--;	  ; ;2b80   if par.eq.1 (Addition) --> ...
s_2b83h:	    ;	  ;
    ld a,019h	    ;	  ; ;2b83   'ADD HL,DE'
    call PutOpc	    ;	  ; ;2b85
    jp l2681h	    ;	  ; ;2b88   --> (l0250h)=0 ret
		    ;	  ;
l2b8bh:		;<--+	  ;
    sub 2		  ; ;2b8b   if par.ne.3 (Subtraction)
    jp nz,l2b35h	  ; ;2b8d     --> Building built-in arithmetic routine
    ld a,07bh		  ; ;2b90   'LD A,E'
    call PutOpc		  ; ;2b92
    ld a,095h		  ; ;2b95   'SUB L'
    call PutOpc		  ; ;2b97
    ld a,06fh		  ; ;2b9a   'LD L,A'
    call PutOpc		  ; ;2b9c
    ld a,07ah		  ; ;2b9f   'LD A,D'
    call PutOpc		  ; ;2ba1
    ld a,09ch		  ; ;2ba4   'SBC A,H'
    call PutOpc		  ; ;2ba6
    ld a,067h		  ; ;2ba9   'LD H,A'
    call PutOpc		  ; ;2bab
    jp l2681h		  ; ;2bae   --> (l0250h)=0 ret
			  ;
; (KindID).ne.1 Constant  ;
; or (TypeID)=4 INTEGER*4 ;
			; ;
l2bb1h:	    ;<----------+ ;
    ld a,(i_Type)	  ; ;2bb1
    cp 2		  ; ;2bb4
    jp nz,l2bdah ;----;	  ; ;2bb6   if (i_Type).ne.2 (BYTE) --> ...
    ld hl,TypeID      ;	  ; ;2bb9
    cp (hl)	      ;	  ; ;2bbc
    jp nz,l2bd4h ;--; ;	  ; ;2bbd   if (i_Type).ne.(TypeID) --> ...
    ld a,b	    ; ;	  ; ;2bc0   Restore par
    dec a	    ; ;	  ; ;2bc1
    jp z,l2bcfh ;-; ; ;	  ; ;2bc2   if par.eq.1 (Addition) --> ...
    sub 2	  ; ; ;	  ; ;2bc5
    jp nz,l2bd4h;-)-; ;	  ; ;2bc7   if par.ne.3 (Subtraction) --> ...
    ld a,096h	  ; ; ;	  ; ;2bca   'SUB A,(HL)'
    jp l2d32h	  ; ; ;	  ; ;2bcc   --> ...
		  ; ; ;	  ;
l2bcfh:	      ;<--+ ; ;	  ;
    ld a,086h	    ; ;	  ; ;2bcf   'ADD A,(HL)'
    jp l2d32h	    ; ;	  ; ;2bd1   --> ...
		    ; ;	  ;
l2bd4h:	     ;<-----+ ;	  ;
    call s_25a5h      ;	  ; ;2bd4   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a     ;	  ; ;2bd7   (i_Type)=0 (INTEGER)
l2bdah:		;<----+	  ;
    ld a,(TypeID)	  ; ;2bda
    cp 2		  ; ;2bdd
    jp nz,l2c0bh   ;--;	  ; ;2bdf   if (TypeID).ne.2 (BYTE) --> ...
    push bc	      ;	  ; ;2be2 \
    ld a,(i_Type)     ;	  ; ;2be3
    or a	      ;	  ; ;2be6
    jp z,l2bf7h	 ;--; ;	  ; ;2be7   if (i_Type).eq.0 (INTEGER) --> ...
    call s_2e4ch    ; ;	  ; ;2bea   cd 4c 2e
    call s_25a5h    ; ;	  ; ;2bed   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (TypeID),a   ; ;	  ; ;2bf0   (TypeID)=0 (INTEGER)
    pop bc	    ; ;	  ; ;2bf3 /
    jp l2b35h	    ; ;	  ; ;2bf4   --> Building built-in arithmetic routine
		    ; ;	  ;
l2bf7h:		;<--+ ;	  ;
    call s_2dc5h      ;	  ; ;2bf7   cd c5 2d
    pop bc	      ;	  ; ;2bfa /
    ld a,(TypeID)     ;	  ; ;2bfb
    or a	      ;	  ; ;2bfe
    jp z,l2b7eh	  ;---)---; ;2bff   if (TypeID).eq.0 (INTEGER) --> ...
    call s_25a5h      ;	  ; ;2c02   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (TypeID),a     ;	  ; ;2c05   (TypeID)=0 (INTEGER)
    jp l2b7eh	  ;---)---+ ;2c08   --> ...
		      ;
l2c0bh:		;<----+
    ld hl,TypeID	    ;2c0b
    ld a,(i_Type)	    ;2c0e
    cp (hl)		    ;2c11
    jp z,l2c3ch ;-----;	    ;2c12   if (i_Type).eq.(TypeID) --> ...
    cp 4	      ;	    ;2c15
    jp nz,l2c25h ;--; ;	    ;2c17   if (i_Type).ne.4 (INTEGER*4) --> ...
    ld a,(hl)	    ; ;	    ;2c1a
    or a	    ; ;	    ;2c1b
    ld a,(i_Type)   ; ;	    ;2c1c   a=(i_Type)
    jp z,l2c43h	  ;-)-)-;   ;2c1f   if (TypeID).eq.0 (INTEGER) --> ...
    jp l2c50h  ;----)-)-)-; ;2c22   --> Building built-in routine converting between value types
		    ; ; ; ;
l2c25h:	    ;<------+ ; ; ;
    ld a,(hl)	      ; ; ; ;2c25
    cp 4	      ; ; ; ;2c26
    ld a,(i_Type)     ; ; ; ;2c28
    jp nz,l2c35h ;--; ; ; ; ;2c2b   if (TypeID).eq.4 (INTEGER*4) --> ...
    or a	    ; ; ; ; ;2c2e   if (i_Type).eq.0 (INTEGER)
    jp z,l2c50h	  ;-)-)-)-; ;2c2f     --> Building built-in routine converting between value types
    jp l2c43h	;---)-)-; ; ;2c32   --> ...
		    ; ; ; ;
l2c35h:	    ;<------+ ; ; ;
    cp (hl)	      ; ; ; ;2c35   if (i_Type)	 <  (TypeID)
    jp c,l2c50h	   ;--)-)-; ;2c36     --> Building built-in routine converting between value types
    jp nz,l2c43h ;----)-; ; ;2c39   if (i_Type).ne. (TypeID) --> ...
l2c3ch:	 ;<-----------+ ; ;
    or a		; ; ;2c3c
    jp z,l2b6ch		; ; ;2c3d   if i_Type).eq.0 (INTEGER) --> ...
    jp l2b30h		; ; ;2c40   --> ...
			; ;
l2c43h:		;<------+ ;
    ld a,(hl)		  ; ;2c43
    or a		  ; ;2c44
    jp nz,l2b30h	  ; ;2c45   if (TypeID).ne.0 (INTEGER) --> ...
    push bc		  ; ;2c48 \
    call s_2df2h	  ; ;2c49   cd f2 2d
    pop bc		  ; ;2c4c /
    jp l2b35h		  ; ;2c4d   --> Building built-in arithmetic routine
			  ;
l2c50h:	   ;<-------------+
;
;   Building  built-in routine converting between value types
;
    ld c,a		    ;2c50   Save (i_Type)
    ld a,(hl)		    ;2c51
    ld (i_Type),a	    ;2c52   (i_Type)=(TypeID)
    ld a,c		    ;2c55   Resrore (i_Type)
    rlca		    ;2c56
    rlca		    ;2c57
    rlca		    ;2c58   (i_Type)*8
    add a,'@'		    ;2c59
    add a,(hl)		    ;2c5b
;
;   Building mnemonic built-in routine
;     Reg B - First character of the built-in routine "C"
;     Reg C - The second character of the built-in function is calculated
;	      according to the conversion of one type to another
;
    push bc		    ;2c5c \
    ld c,a		    ;2c5d   c=(i_Type)*8+'@'+(TypeID)
    ld b,'C'		    ;2c5e   $Cc
    call CrBuilt	    ;2c60   Creating built-in routine
    pop bc		    ;2c63 /
    jp l2b30h		    ;2c64   --> ...
;
;   par >= 7
;
l2c67h:
    jp nz,l2d0ch   ;----;   ;2c67   if par.ne.7 --> ...
l2c6ah:	    ;<----;	;
    ld a,(TypeID) ;	;   ;2c6a
    ld hl,i_Type  ;	;   ;2c6d
    cp (hl)	  ;	;   ;2c70
    ld a,(hl)	  ;	;   ;2c71
    jp z,l2cach ;-)---; ;   ;2c72   if (TypeID).eq.(i_Type) --> ...
    cp 2	  ;   ; ;   ;2c75
    jp nz,l2c82h;-)-; ; ;   ;2c77   if (i_Type).eq.2 (BYTE) --> ...
    ld (hl),0	  ; ; ; ;   ;2c7a   (i_Type)=0 (INTEGER)
    call s_25a5h  ; ; ; ;   ;2c7c   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    jp l2c6ah  ;--+ ; ; ;   ;2c7f   --> ...
		    ; ; ;
l2c82h:	      ;<----+ ; ;
    or a	      ; ;   ;2c82
    jp nz,l2c96h;-;   ; ;   ;2c83   if (i_Type).eq.0 (INTEGER) --> ...
    ld a,(TypeID) ;   ; ;   ;2c86
    cp 2	  ;   ; ;   ;2c89
    jp nz,l2c96h;-;   ; ;   ;2c8b   if (TypeID).ne.2 (BYTE)    --> ...
    ld a,07dh	  ;   ; ;   ;2c8e   'LD A,L'
    call PutOpc	  ;   ; ;   ;2c90
    jp l2cc9h	;-)-; ; ;   ;2c93   --> ...
		  ; ; ; ;
l2c96h:	    ;<----+ ; ; ;
    ld a,(hl)	    ; ; ;   ;2c96   a=(i_Type)
    rlca	    ; ; ;   ;2c97
    rlca	    ; ; ;   ;2c98
    rlca	    ; ; ;   ;2c99
    add a,'@'	    ; ; ;   ;2c9a
    ex de,hl	    ; ; ;   ;2c9c   Save hl=i_Type
    ld hl,TypeID    ; ; ;   ;2c9d
    add a,(hl)	    ; ; ;   ;2ca0
    ld b,(hl)	    ; ; ;   ;2ca1   b=(TypeID)
    ex de,hl	    ; ; ;   ;2ca2   Restore hl=i_Type
    ld (hl),b	    ; ; ;   ;2ca3   (i_Type)=(TypeID)
    push bc	    ; ; ;   ;2ca4 \ Save (i_Type)
    ld c,a	    ; ; ;   ;2ca5   c=(i_Type)*8+'@'+(TypeID)
    ld b,'C'	    ; ; ;   ;2ca6   $Cc
    call CrBuilt    ; ; ;   ;2ca8   Creating built-in routine
    pop af	    ; ; ;   ;2cab / Restore (i_Type)
l2cach:	     ;<-----)-+ ;
    or a	    ;	;   ;2cac
    ld hl,(l01cch)  ;	;   ;2cad
    ld (l0250h),hl  ;	;   ;2cb0   (l0250h)=(l01cch)
    jp z,l2ccdh ;---)-; ;   ;2cb3   if (i_Type).eq.0 (INTEGER) --> ...
    cp 2	    ; ; ;   ;2cb6
    jp z,l2cc9h	 ;--; ; ;   ;2cb8   if (i_Type).eq.2 (BYTE)    --> ...
    call s_2ebbh    ; ; ;   ;2cbb   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    ld a,(TypeID)   ; ; ;   ;2cbe   Load value type variable
    add a,'0'	    ; ; ;   ;2cc1   Convert binary decimal to ASCII
    ld c,a	    ; ; ;   ;2cc3   Copy to reg C
    ld b,'T'	    ; ; ;   ;2cc4   'T' - sTore floating accumulator
    jp l2e40h	    ; ; ;   ;2cc6   --> Creating built-in routine "$Tc"
		    ; ; ;
l2cc9h:	   ;<-------+ ; ;
    scf		      ; ;   ;2cc9   Set carry
    jp l2cceh	 ;--; ; ;   ;2cca   --> ...
		    ; ; ;
l2ccdh:	      ;<----)-+ ;
    xor a	    ;	;   ;2ccd   clears carry flag
l2cceh:	   ;<-------+	;
    push af		;   ;2cce \
    ld a,(ScopeID)	;   ;2ccf
    cp 3		;   ;2cd2
    jp z,l2ce9h ;---;	;   ;2cd4   if (ScopeID).eq.3 --> ...
    pop af	    ;	;   ;2cd7 /
    jp nc,l30a4h    ;	;   ;2cd8   if (i_Type) >= 0 --> 'LD (word),HL' ...
    ld hl,(l01cch)  ;	;   ;2cdb
    ld (l0250h),hl  ;	;   ;2cde   (l0250h)=(l01cch)
    ld a,2	    ;	;   ;2ce1
    ld (i_Type),a   ;	;   ;2ce3   (i_Type)=2 (BYTE)
    jp l309fh	    ;	;   ;2ce6   --> 'LD (word),A' ...
		    ;	;
l2ce9h:		;<--+	;
    pop af		;   ;2ce9 /
    jp nc,l2cf5h  ;-;	;   ;2cea   if (i_Type) >= --> ...
    call s_3095h    ;	;   ;2ced   'LD HL,(word)'
    ld a,077h	    ;	;   ;2cf0   'LD (HL),A'
    jp PutOpc	    ;	;   ;2cf2   --> ...
		    ;	;
l2cf5h:		;<--+	;
    ld a,0ebh		;   ;2cf5   'EX DE,HL'
    call PutOpc		;   ;2cf7
    call s_3095h	;   ;2cfa   'LD HL,(word)'
    ld a,073h		;   ;2cfd   'LD (HL),E'
    call PutOpc		;   ;2cff
    ld a,023h		;   ;2d02   'INC HL'
    call PutOpc		;   ;2d04
    ld a,072h		;   ;2d07   'LD (HL),D'
    jp PutOpc		;   ;2d09   --> ...
			;
l2d0ch:	    ;<----------+
    sub 8		    ;2d0c
    ld c,a		    ;2d0e   c=par-8
    ld a,0eeh		    ;2d0f   'XOR byte'
    jp z,l2d1dh	 ;--;	    ;2d11   if par.eq.8 --> ...
    dec c	    ;	    ;2d14
    ld a,0f6h	    ;	    ;2d15   'OR byte'
    jp z,l2d1dh	 ;--;	    ;2d17   if par.eq.9 --> ...
    dec c	    ;	    ;2d1a   0d
    ld a,0e6h	    ;	    ;2d1b   'AND byte'
l2d1dh:	      ;<----+
    ld b,a		    ;2d1d   Save opcode			--------+
    ld a,(KindID)	    ;2d1e					;
    dec a		    ;2d21					;
    jp z,l2d7ah	 ;----;	    ;2d22   if (KindID).eq.1 (Constant) --> ... ;
    ld a,(TypeID)     ;	    ;2d25					;
    ld hl,i_Type      ;	    ;2d28					;
    and (hl)	      ;	    ;2d2b					;
    jp z,l2d3ah	 ;--; ;	    ;2d2c   if (TypeID).eq.(i_Type) --> ...	;
    ld a,b	    ; ;	    ;2d2f   Restore opcode		<-------+
    sub '@'	    ; ;	    ;2d30   d6 40   . '@'
l2d32h:		    ; ;
    push af	    ; ;	    ;2d32 \
    call s_2ebbh    ; ;	    ;2d33   if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
    pop af	    ; ;	    ;2d36 /
    jp PutOpc	    ; ;	    ;2d37   --> ...
		    ; ;
l2d3ah:		;<--+ ;
    or (hl)	      ;	    ;2d3a
    jp z,l2d44h	 ;--; ;	    ;2d3b   if (i_Type).eq.0 --> (INTEGER)...
    call s_25a5h    ; ;	    ;2d3e   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ; ;	    ;2d41   (TypeID)=0 (INTEGER)
l2d44h:		;<--+ ;
    push bc	      ;	    ;2d44 \
    ld a,0ebh	      ;	    ;2d45   'EX DE,HL'
    call PutOpc	      ;	    ;2d47
    call s_2df2h      ;	    ;2d4a   cd f2 2d
    ld a,(TypeID)     ;	    ;2d4d
    or a	      ;	    ;2d50
    jp z,l2d5ah	 ;--; ;	    ;2d51   if (TypeID).eq.0 (INTEGER) --> ...
    call s_25a5h    ; ;	    ;2d54   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    jp l2d5fh  ;--; ; ;	    ;2d57   --> ...
		  ; ; ;
l2d5ah:	      ;<--)-+ ;
    ld a,07ch	  ;   ;	    ;2d5a   'LD A,H'
    call PutOpc	  ;   ;	    ;2d5c
l2d5fh:	    ;<----+   ;
    pop af	      ;	    ;2d5f /
    sub 'D'	      ;	    ;2d60   44h
    push af	      ;	    ;2d62 \
    call PutOpc	      ;	    ;2d63
    ld a,067h	      ;	    ;2d66   'LD H,A'
    call PutOpc	      ;	    ;2d68
    ld a,07dh	      ;	    ;2d6b   'LD A,L'
    call PutOpc	      ;	    ;2d6d
    pop af	      ;	    ;2d70 / f1
    inc a	      ;	    ;2d71   3c
    call PutOpc	      ;	    ;2d72
    ld a,06fh	      ;	    ;2d75   'LD L,A'
    jp PutOpc	      ;	    ;2d77   --> ...
		      ;
l2d7ah:	      ;<------+
    ld a,(TypeID)	    ;2d7a
    ld hl,i_Type	    ;2d7d
    and (hl)		    ;2d80
    ld a,b		    ;2d81   Restore par
    jp nz,l2a7eh	    ;2d82   if (TypeID).ne.(i_Type) --> ...
    ld a,(hl)		    ;2d85
    or (hl)		    ;2d86
    jp z,l2d98h	 ;--;	    ;2d87   if (i_Type).eq.0 (INTEGER) --> ...
    ld a,(l01d4h)   ;	    ;2d8a
    or a	    ;	    ;2d8d
    ld a,b	    ;	    ;2d8e   Restore par
    jp z,l2a7eh	    ;	    ;2d8f   if (l01d4h).eq.0 --> ...
    call s_25a5h    ;	    ;2d92   {'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ;	    ;2d95   (i_Type)=0 (INTEGER)
l2d98h:		;<--+
    ld a,07ch		    ;2d98   'LD A,H'
    push bc		    ;2d9a \ -----;
    call PutOpc		    ;2d9b	 ;
    pop af		    ;2d9e / a=b -+
    push af		    ;2d9f \ f5
    call PutOpc		    ;2da0   Put opcode
    ld a,(l01d4h)	    ;2da3   a=(l01d4h)
    call p_byte		    ;2da6   Put byte in reg A to REL file
    ld a,067h		    ;2da9   'LD H,A'
    call PutOpc		    ;2dab
    ld a,07dh		    ;2dae   'LD A,L'
    call PutOpc		    ;2db0
    pop af		    ;2db3 / f1
    call PutOpc		    ;2db4
    ld a,(l01d3h)	    ;2db7   a=(l01d3h)
    call p_byte		    ;2dba   Put byte in reg A to REL file
    ld a,06fh		    ;2dbd   'LD L,A'
    call PutOpc		    ;2dbf
    jp l2681h		    ;2dc2   --> (l0250h)=0 ret
;*
;*
;*
s_2dc5h:
    ld hl,(l0250h)	;2dc5
    ex de,hl		;2dc8
    ld hl,(l01cch)	;2dc9
    call cmpHL_DE	;2dcc	Compare HL with DE
    jp nz,l2de4h ;--;	;2dcf	if (l01cch).ne.(l0250h) --> ...
    dec hl	    ;	;2dd2
    ld (l0250h),hl  ;	;2dd3	(l0250h)=(l01cch)-1
    xor a	    ;	;2dd6
    ld (TypeID),a   ;	;2dd7	(TypeID)=0 (INTEGER)
    ld a,054h	    ;	;2dda	'LD D,H'
    call PutOpc	    ;	;2ddc
    ld a,05dh	    ;	;2ddf	'LD E,L'
    jp PutOpc	    ;	;2de1	--> ...
		    ;
l2de4h:		;<--+
    ld a,0ebh		;2de4	'EX DE,HL'
    call PutOpc		;2de6
    jp l2e19h	;---;	;2de9	--> ...
;*		    ;
;*		    ;
;*		    ;
s_2dech:	    ;
    ld a,(TypeID)   ;	;2dec
    ld (i_Type),a   ;	;2def	(i_Type)=(TypeID)
s_2df2h:	    ;
    ld hl,(l0250h)  ;	;2df2
    ex de,hl	    ;	;2df5
    ld hl,(l01cch)  ;	;2df6
    call cmpHL_DE   ;	;2df9	Compare HL with DE
    ld (l0250h),hl  ;	;2dfc	if (l01cch).ne.(l0250h) {
    jp nz,l2e19h ;--;	;2dff	    (l0250h)=(l01cch) --> ...
    ld a,(ScopeID)  ;	;2e02	    }
    cp 3	    ;	;2e05
    ret nz	    ;	;2e07	if (ScopeID).ne.3 Return
    ld a,(TypeID)   ;	;2e08
    or a	    ;	;2e0b
    jp nz,l2e14h;-; ;	;2e0c	if (TypeID).ne.0 (INTEGER) --> ...
    ld a,0ebh	  ; ;	;2e0f	'EX DE,HL'
    jp PutOpc	  ; ;	;2e11	--> ...
		  ; ;
l2e14h:	     ;<---+ ;
    dec a	    ;	;2e14
    ret z	    ;	;2e15	if (TypeID).eq.1 (REAL) Return
    jp l2e65h	    ;	;2e16	--> ...
		    ;
l2e19h:		;<--+
    ld a,(KindID)	;2e19
    cp 2		;2e1c
    jp nz,l2e29h  ;-;	;2e1e	if (KindID).ne.2 (Label) --> ...
    call s_3090h    ;	;2e21	'LD HL,word'
    xor a	    ;	;2e24
    ld (i_Type),a   ;	;2e25	(i_Type)=0 (INTEGER)
    ret		    ;	;2e28
		    ;
l2e29h:		;<--+
    ld a,(TypeID)	;2e29
    cp 4		;2e2c
    jp z,l2e35h	 ;--;	;2e2e	if (TypeID).eq.4 (INTEGER*4) --> ...
    rra		    ;	;2e31
    jp nc,s_2e4ch   ;	;2e32	if (TypeID).??. --> ...
l2e35h:		;<--+
    call s_2ebbh	;2e35	if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
;*
;*  Load floating accumulator
;*
l2e38h:
    ld b,'L'		;2e38	'L' - Load floating accumulator
    ld a,(TypeID)	;2e3a	Load value type variable
    add a,'0'		;2e3d	Convert binary decimal to ASCII
    ld c,a		;2e3f	c=(TypeID)+'0'
l2e40h:
    ld hl,(l0250h)	;2e40
    push hl		;2e43 \ Save (l0250h)
    call CrBuilt	;2e44	Creating built-in routine
    pop hl		;2e47 / Restore (l0250h)
    ld (l0250h),hl	;2e48
    ret			;2e4b
;*
;*
;*
s_2e4ch:
    ld a,(KindID)	;2e4c
    dec a		;2e4f
    jp z,l2e86h	 ;----; ;2e50	if(KindID).eq.1 (Constant) --> ...
    ld a,(TypeID)     ; ;2e53
    or a	      ; ;2e56
    ld a,(ScopeID)    ; ;2e57
    jp z,l2e6ah	 ;--; ; ;2e5a	if(TypeID).eq.0 (INTEGER) --> ...
    cp 3	    ; ; ;2e5d
    jp nz,l309ah    ; ; ;2e5f	if(ScopeID).ne.3 --> 'LD A,(word)'
    call s_3095h    ; ; ;2e62	'LD HL,(word)'
l2e65h:		    ; ;
    ld a,07eh	    ; ; ;2e65	'LD A,(HL)'
    jp PutOpc	    ; ; ;2e67	--> ...
		    ; ;
l2e6ah:	       ;<---+ ;
    cp 3	      ; ;2e6a
    jp nz,s_3095h     ; ;2e6c	if(ScopeID).ne.3 --> 'LD HL,(word)'
    call s_3095h      ; ;2e6f	'LD HL,(word)'
l2e72h:		      ;
    ld a,07eh	      ; ;2e72	'LD A,(HL)'
    call PutOpc	      ; ;2e74
    ld a,023h	      ; ;2e77	'INC HL'
    call PutOpc	      ; ;2e79
    ld a,066h	      ; ;2e7c	'LD H,(HL)'
    call PutOpc	      ; ;2e7e
    ld a,06fh	      ; ;2e81	'LD L,A'
    jp PutOpc	      ; ;2e83	--> ...
		      ;
l2e86h:		;<----+
    ld a,(TypeID)	;2e86
    or a		;2e89
    jp z,s_2ea1h ;--;	;2e8a	if (TypeID).eq.0 (INTEGER) --> ...
    ld a,(l01d3h)   ;	;2e8d
    or a	    ;	;2e90
    ld a,0afh	    ;	;2e91	'XOR A'
    jp z,PutOpc	    ;	;2e93	if (l01d3h).eq.0 --> ...
    ld a,03eh	    ;	;2e96	'LD A,byte'
    call PutOpc	    ;	;2e98
    ld a,(l01d3h)   ;	;2e9b	a=(l01d6h)
    jp p_byte	    ;	;2e9e	--> Put byte in reg A to REL file
		    ;
s_2ea1h:	;<--+
;*
;*  Put "LD HL,word" & addres from (l01d3h) to console & REL file
;*
    ld a,021h		;2ea1	'LD HL,word'
    ld hl,(l01d3h)	;2ea3	hl=(l01d3h)
;*
;*  Put opcode & addres from HL to console & REL file
;*
s_2ea6h:
    push hl		;2ea6 \
    call PutOpc		;2ea7	Put opcode 'LD DE,word'
    pop hl		;2eaa /
    ld a,(NoCode)	;2eab
    or a		;2eae	Test /N
    call z,putadr	;2eaf	if (NoCode).eq.0 Put addres in HL to console
    ld b,l		;2eb2	b=l
    push hl		;2eb3 \
    call w_const	;2eb4	Put constant byte in reg B to REL file
    pop bc		;2eb7 / b=h
    jp w_const		;2eb8	--> Put constant byte in reg B to REL file
;*
;*  if(ScopeID).eq.3 --> "LD HL,(word)" else "LD HL,word"
;*
s_2ebbh:
    ld a,(ScopeID)	;2ebb
    cp 3		;2ebe
    jp z,s_3095h	;2ec0	if(ScopeID).eq.3 --> 'LD HL,(word)'
    jp s_3090h		;2ec3	--> 'LD HL,word'
;*
;*  ENTRY
;*    Reg  A - opcode
;*    Reg HL -
;*
s_2ec6h:
    ld (l01cch),hl	;2ec6	22 cc 01
;*
;*  ENTRY
;*    Reg  A - opcode
;*
s_2ec9h:
    or a			;2ec9	b7
    jp z,l2fe7h	  ;-----------; ;2eca	if a.eq.0 --> ...
    call PutOpc		      ; ;2ecd	Put OpCode
    ld hl,(l01cch)	      ; ;2ed0
    inc hl		      ; ;2ed3
    ld a,h		      ; ;2ed4
    or l		      ; ;2ed5
    jp z,s_2ef2h  ;-;	      ; ;2ed6	if (l01cch).eq.1 --> ...
    call s_4647h    ;	      ; ;2ed9	Extract Attributes from the symbol table, entry( l01cch)
    or a	    ;	      ; ;2edc
    jp z,s_2ef2h  ;-;	      ; ;2edd	if (KindID).eq.0 --> ...
    ld a,(NoCode)   ;	      ; ;2ee0
    or a	    ;	      ; ;2ee3	Test /N
    jp nz,s_2ef2h ;-;	      ; ;2ee4	if (NoCode).ne.0  --> Skip output
		    ;	      ;
    call s_2f22h    ;	      ; ;2ee7	if (MnCode).eq.32 or 22 or 3a or 2a put '(' to console
    push af	    ;	      ; ;2eea \ f5
    call s_3aebh    ;	      ; ;2eeb	cd eb 3a
    pop af	    ;	      ; ;2eee / f1
    call z,s_2f3eh  ;	      ; ;2eef	if a.eq.? Print ")",",A" or ",HL"
		    ;	      ;
s_2ef2h:	;<--+	      ;
    ld hl,(DataID)	      ; ;2ef2
    push hl		      ; ;2ef5 \ Save (DataID)
    ld a,(ScopeID)	      ; ;2ef6
    or a		      ; ;2ef9
    jp z,l2fach ;-----------; ; ;2efa	if(ScopeID).eq.0 --> ...
    dec a		    ; ; ;2efd
    jp z,l2fa4h	   ;------; ; ; ;2efe	if(ScopeID).eq.1 --> ...
    cp 2		  ; ; ; ;2f01
    jp z,l2f78h ;---;	  ; ; ; ;2f03	if(ScopeID).eq.2 --> ...
    ld a,(KindID)   ;	  ; ; ; ;2f06
    dec a	    ;	  ; ; ; ;2f09
    jp z,l2f73h	  ;-)-;	  ; ; ; ;2f0a	if(KindID).eq.1 (Constant) --> ...
    dec a	    ; ;	  ; ; ; ;2f0d
    jp nz,l2f61h ;--)-)-; ; ; ; ;2f0e	if(KindID).ne.2 (Label) --> ...
    ld a,(RomFlg)   ; ; ; ; ; ; ;2f11
    or a	    ; ; ; ; ; ; ;2f14	Test /M
    jp nz,l2f73h  ;-)-; ; ; ; ; ;2f15	if (RomFlg).ne.0 --> ...
    ld a,(TypeID)   ; ; ; ; ; ; ;2f18
    dec a	    ; ; ; ; ; ; ;2f1b
    jp z,l2f78h ;---; ; ; ; ; ; ;2f1c	if (TypeID).eq.1 (REAL) --> ...
    jp l2f73h	  ;-)-; ; ; ; ; ;2f1f	--> ...
		    ; ; ; ; ; ;
;   if (MnCode).eq.32 or 22 or 3a or 2a put '(' to console
		    ; ; ; ; ; ;
s_2f22h:	    ; ; ; ; ; ;
    ld a,(MnCode)   ; ; ; ; ; ; ;2f22	3a 31 02
    ld c,a	    ; ; ; ; ; ; ;2f25	4f
    ld hl,l2f57h    ; ; ; ; ; ; ;2f26	Point to table Machine Code
l2f29h:	      ;<---;; ; ; ; ; ;
    ld a,(hl)	   ;; ; ; ; ; ; ;2f29
    cp c	   ;; ; ; ; ; ; ;2f2a
    jp z,l2f35h ;-;;; ; ; ; ; ; ;2f2b	if (MnCode).eq.Machine Code from table l2f57h
    inc hl	  ;;; ; ; ; ; ; ;2f2e	hl=hl+1
    or a	  ;;; ; ; ; ; ; ;2f2f
    jp nz,l2f29h;-)+; ; ; ; ; ; ;2f30	while Machine Code from table l2f57h.ne.0
    inc a	  ; ; ; ; ; ; ; ;2f33	a=1 hl=2F5C
    ret		  ; ; ; ; ; ; ; ;2f34
		  ; ; ; ; ; ; ;
l2f35h:	     ;<---+ ; ; ; ; ; ;
    xor a	    ; ; ; ; ; ; ;2f35	a=0
    ld a,'('	    ; ; ; ; ; ; ;2f36	a=28h
    push af	    ; ; ; ; ; ; ;2f38
    call z,putchr   ; ; ; ; ; ; ;2f39	Put character to console
    pop af	    ; ; ; ; ; ; ;2f3c
    ret		    ; ; ; ; ; ; ;2f3d
		    ; ; ; ; ; ;
;   Print ')',",A" or ",HL" ; ;
		    ; ; ; ; ; ;
s_2f3eh:	    ; ; ; ; ; ;
    ld a,')'	    ; ; ; ; ; ; ;2f3e	a=29h
    call putchr	    ; ; ; ; ; ; ;2f40	Put character to console
    ld a,(MnCode)   ; ; ; ; ; ; ;2f43
    cp 032h	    ; ; ; ; ; ; ;2f46
    ld hl,l2f5ch    ; ; ; ; ; ; ;2f48	hl=",A"
    jp z,PrStrg	    ; ; ; ; ; ; ;2f4b	if (MnCode).eq.032h Print string
    cp 022h	    ; ; ; ; ; ; ;2f4e
    ld hl,l2f5eh    ; ; ; ; ; ; ;2f50	hl=",HL"
    ret nz	    ; ; ; ; ; ; ;2f53	if (MnCode).ne.022h return
    jp PrStrg	    ; ; ; ; ; ; ;2f54	--> Print string
		    ; ; ; ; ; ;
l2f57h:		    ; ; ; ; ; ;
    db 032h	    ; ; ; ; ; ; ;2f57	"LD (word),A"
    db 022h	    ; ; ; ; ; ; ;2f58	"LD (word),HL"
    db 03ah	    ; ; ; ; ; ; ;2f59	"LD A,(word)"
    db 02ah	    ; ; ; ; ; ; ;2f5a	"LD HL,(word)"
    db 0	    ; ; ; ; ; ; ;2f5b
		    ; ; ; ; ; ;
l2f5ch:		    ; ; ; ; ; ;
    dc ',A'	    ; ; ; ; ; ; ;2f5c
		    ; ; ; ; ; ;
l2f5eh:		    ; ; ; ; ; ;
    dc ',HL'	    ; ; ; ; ; ; ;2f5e
		    ; ; ; ; ; ;
l2f61h:	  ;<--------)-)-+ ; ; ;
    cp 3	    ; ;	  ; ; ; ;2f61
    jp nz,l2f78h ;--; ;	  ; ; ; ;2f63	if(KindID).ne.3 (Variable) --> ...
    ld hl,(l01cch)  ; ;	  ; ; ; ;2f66
    ex de,hl	    ; ;	  ; ; ; ;2f69
    ld hl,(l0267h)  ; ;	  ; ; ; ;2f6a
    call cmpHL_DE   ; ;	  ; ; ; ;2f6d	Compare HL with DE
    jp z,l2f78h	 ;--; ;	  ; ; ; ;2f70	if (l0267h).eq.(l01cch) --> ...
l2f73h:	    ;<------)-+	  ; ; ;
    ld b,1	    ; ;	  ; ; ; ;2f73	b=1
    jp l2f7ah ;---; ; ;	  ; ; ; ;2f75
		  ; ; ;	  ; ; ;
l2f78h:	    ;<----)-+ ;	  ; ; ;
    ld b,2	  ;   ;	  ; ; ; ;2f78	b=2
l2f7ah:	      ;<--+   ;	  ; ; ;
    ld hl,(l01cch)    ;	  ; ; ; ;2f7a
    ld a,h	      ;	  ; ; ; ;2f7d
    and l	      ;	  ; ; ; ;2f7e
    inc a	      ;	  ; ; ; ;2f7f
    jp nz,l2f9eh ;--; ;	  ; ; ; ;2f80	if (l01cch).ne.0ffffh (-1) --> ...
l2f83h:	    ;<------)-)-; ; ; ;
    ld a,(NoCode)   ; ; ; ; ; ; ;2f83
    or a	    ; ; ; ; ; ; ;2f86	Test /N
    jp nz,l2f9eh ;--; ; ; ; ; ; ;2f87	if (NoCode).ne.0  --> skip output
    call s_2f22h    ; ; ; ; ; ; ;2f8a	if (MnCode).eq.32 or 22 or 3a or 2a put '(' to console
    pop hl	    ; ; ; ; ; ; ;2f8d / e1
    push hl	    ; ; ; ; ; ; ;2f8e \ e5
    push af	    ; ; ; ; ; ; ;2f8f	f5
    ld a,b	    ; ; ; ; ; ; ;2f90	78
    dec a	    ; ; ; ; ; ; ;2f91	3d
    push af	    ; ; ; ; ; ; ;2f92 \
    call z,s_3a75h  ; ; ; ; ; ; ;2f93	if eq.0 Put addres DATA' to console trap_ms (03a75h) ***
    pop af	    ; ; ; ; ; ; ;2f96 /
    call nz,s_3a85h ; ; ; ; ; ; ;2f97	if ne.0 Put addres DATA" to console trap_ms (03a85h) ***
    pop af	    ; ; ; ; ; ; ;2f9a	f1
    call z,s_2f3eh  ; ; ; ; ; ; ;2f9b	if a.eq.? Print ")",",A" or ",HL"
l2f9eh:	     ;<--;<-+ ; ; ; ; ;
    call w_code	 ;    ; ; ; ; ; ;2f9e	Output control prefix 1.b2.b1 (Reg B holds two bit control)
    jp l2fd5h  ;-)--; ; ; ; ; ; ;2fa1	--> ...
		 ;  ; ; ; ; ; ;
l2fa4h:	  ;<-----)--)-)-)-+ ; ;
    call s_5623h ;  ; ; ;   ; ; ;2fa4	cd 23 56
    ld b,3	 ;  ; ; ;   ; ; ;2fa7	b=3
    jp l2f9eh ;--+  ; ; ;   ; ; ;2fa9	--> Output control prefix ...
		    ; ; ;   ; ;
l2fach:	   ;<-------)-)-)---+ ;
    ld hl,(PrgSiz)  ; ; ;     ; ;2fac	Load Program size
    ld (DataID),hl  ; ; ;     ; ;2faf	(DataID)=(PrgSiz)
    ld hl,SegmID    ; ; ;     ; ;2fb2
    ld a,(l01a3h)   ; ; ;     ; ;2fb5
    ld d,(hl)	    ; ; ;     ; ;2fb8	d=(SegmID) Flag Address mode
    ld (hl),a	    ; ; ;     ; ;2fb9	(SegmID)=(l01a3h)
    push de	    ; ; ;     ; ;2fba \ d5
    call PutAttr    ; ; ;     ; ;2fbb	Put Attributes in Symbol table
    pop de	    ; ; ;     ; ;2fbe / d1
    pop bc	    ; ; ;     ; ;2fbf / c1
    ld a,b	    ; ; ;     ; ;2fc0
    or c	    ; ; ;     ; ;2fc1	Test bc
    jp nz,l2fcch;-; ; ; ;     ; ;2fc2	if bc.ne.0 skip output to REL file
    call w_const  ; ; ; ;     ; ;2fc5	Put constant byte in reg B to REL file
    xor a	  ; ; ; ;     ; ;2fc8	a=0
    jp w_const	  ; ; ; ;     ; ;2fc9	--> Put constant byte in reg B to REL file
		  ; ; ; ;     ;
l2fcch:	      ;<--+ ; ; ;     ;
    push bc	    ; ; ;     ; ;2fcc \ c5
    ld a,d	    ; ; ;     ; ;2fcd	Restore (SegmID)
    or a	    ; ; ;     ; ;2fce	Test Flag Address mode
    jp nz,l2f78h    ; ; ;     ; ;2fcf	if (SegmID).ne.0 --> ...
    jp l2f73h  ;----)-+ ;     ; ;2fd2	--> ...
		    ;	;     ;
l2fd5h:	    ;<------+	;     ;
    pop bc		;     ; ;2fd5 / c1
    push bc		;     ; ;2fd6 \ Save bc
    ld b,c		;     ; ;2fd7	41
    call w_byte		;     ; ;2fd8	Put byte to REL file from Reg B
    ld hl,(PrgSiz)	;     ; ;2fdb
    inc hl		;     ; ;2fde
    inc hl		;     ; ;2fdf
    ld (PrgSiz),hl	;     ; ;2fe0	(PrgSiz)=(PrgSiz)+2
    pop bc		;     ; ;2fe3 / Resrore bc
    jp w_byte		;     ; ;2fe4	--> Put byte to REL file from Reg B
			;     ;
l2fe7h:		;<------)-----+
    call s_4647h	;	;2fe7	Extract Attributes from the symbol table, entry (l01cch)
    ld hl,l024bh	;	;2fea
    inc (hl)		;	;2fed	(l024bh)=(l024bh)*2
    ld a,(hl)		;	;2fee
    cp 4		;	;2fef
    jp nc,l3005h ;--;	;   ;2ff1   if (l024bh) >= 4 --> ...
    ld hl,(l01cch)  ;	;   ;2ff4   2a cc 01
    ex de,hl	    ;	;   ;2ff7   eb
    dec a	    ;	;   ;2ff8   3d
    rlca	    ;	;   ;2ff9   Multiply by 2
    ld c,a	    ;	;   ;2ffa
    ld b,0	    ;	;   ;2ffb   b=0
    ld hl,l0245h    ;	;   ;2ffd   Pointer to ...
    add hl,bc	    ;	;   ;3000   Calculate the offset
    ld (hl),e	    ;	;   ;3001   73
    inc hl	    ;	;   ;3002   23
    ld (hl),d	    ;	;   ;3003   72
    ret		    ;	;   ;3004
		    ;	;
l3005h:	      ;<----+	;
    jp nz,s_3021h ;-;	;   ;3005   c2 21 30
    ld hl,(DatSiz)  ;	;   ;3008
    push hl	    ;	;   ;300b \ Save (DatSiz)
    ld hl,(l01cch)  ;	;   ;300c
    push hl	    ;	;   ;300f \ Save (l01cch)
    ld hl,(l0249h)  ;	;   ;3010   hl=(l0249h)
    call ExtAttr    ;	;   ;3013   Extract Attributes from the symbol table
    call s_3021h    ;	;   ;3016   cd 21 30
    pop hl	    ;	;   ;3019 / Restore (l01cch)
    call ExtAttr    ;	;   ;301a   Extract Attributes from the symbol table
    pop hl	    ;	;   ;301d / Restore (DatSiz)
    ld (l0249h),hl  ;	;   ;301e   (l0249h)=(DatSiz)
s_3021h:	;<--+	;
    ld a,(ScopeID)	;   ;3021
    cp 3		;   ;3024
    jp z,l3036h	 ;--;	;   ;3026   if (ScopeID).eq.3 --> ...
    ld a,(RomFlg)   ;	;   ;3029
    or a	    ;	;   ;302c   Test /M
    jp z,l304ch	 ;--)-; ;   ;302d   if (RomFlg).eq.0 --> ...
    call s_3090h    ; ; ;   ;3030   'LD HL,word' ...
    jp l3039h  ;--; ; ; ;   ;3033   --> ...
		  ; ; ; ;
l3036h:	     ;<---)-+ ; ;
    call s_3095h  ;   ; ;   ;3036   'LD HL,(word)'
l3039h:	  ;<------+   ; ;
    ld a,022h	      ; ;   ;3039   'LD (word),HL'
    call PutOpc	      ; ;   ;303b
    ld hl,(DatSiz)    ; ;   ;303e   Load Data size
    push hl	      ; ;   ;3041 \
    inc hl	      ; ;   ;3042
    inc hl	      ; ;   ;3043
    ld (DatSiz),hl    ; ;   ;3044   (DatSiz)=(DatSiz)+2
    ld b,2	      ; ;   ;3047   b=2
    jp l2f83h	 ;----)-+   ;3049   --> ...
		      ;
l304ch:	    ;<--------+
    ld hl,(DatSiz)	    ;304c   Load Data size
    ld bc,020bh		    ;304f   Address modes DSEG (2), REL type - Set loading location counter (11)
    call s_56deh	    ;3052   cd de 56
    call s_2ef2h	    ;3055   cd f2 2e
    ld hl,(PrgSiz)	    ;3058
    ld (DatSiz),hl	    ;305b   (DatSiz)=(PrgSiz)
    ld hl,(l021bh)	    ;305e   hl=(l021bh)
    jp s_56dbh		    ;3061   --> ...
;
;
;
s_3064h:
    ld hl,(l0247h)	;3064	hl=(l0247h)
    call ExtAttr	;3067	Extract Attributes from the symbol table
    ld a,(ScopeID)	;306a
    cp 3		;306d
    jp z,l307ah	 ;--;	;306f	if(ScopeID).eq.3 --> ...
    ld a,011h	    ;	;3072	'LD DE,word'
    call s_2ec9h    ;	;3074	cd c9 2e
    jp s_3082h	;-; ;	;3077	--> ...
		  ; ;
l307ah:	       ;<-)-+
    call s_3095h  ;	;307a	'LD HL,(word)'
    ld a,0ebh	  ;	;307d	'EX DE,HL'
    call PutOpc	  ;	;307f
s_3082h:       ;<-+
    ld hl,(l0245h)	;3082	hl=(l0245h)
    call ExtAttr	;3085	Extract Attributes from the symbol table
    ld a,(ScopeID)	;3088
    cp 3		;308b
    jp z,s_3095h ;--;	;308d	if(ScopeID).eq.3 --> 'LD HL,(word)'
		    ;
s_3090h:	    ;
    ld a,021h	    ;	;3090	'LD HL,word'
    jp s_2ec9h	    ;	;3092	--> ...
		    ;
s_3095h:	;<--+
    ld a,02ah		;3095	'LD HL,(word)'
    jp s_2ec9h		;3097	--> ...
;
l309ah:
    ld a,03ah		;309a	'LD A,(word)'
    jp s_2ec9h		;309c	--> ...
;
l309fh:
    ld a,032h		;309f	'LD (word),A'
    jp s_2ec9h		;30a1	--> ...
;
l30a4h:
    ld a,022h		;30a4	'LD (word),HL'
    jp s_2ec9h		;30a6	--> ...
;
;
;
s_30a9h:
    ld b,0c2h		;30a9	'JP NZ,word'
    jp l30b0h	;---;	;30ab	--> ...
;?		    ;	     !! No execution path to here !!
    ld b,0cah	    ;	;30ae	'JP Z,word'
l30b0h:	       ;<---+
    ld a,(l021fh)	;30b0
    or a		;30b3
    ret z		;30b4	if (l021fh).eq.0 Return
    push bc		;30b5 \ c5
    call s_3169h	;30b6	cd 69 31
    call s_3725h	;30b9	cd 25 37
    pop af		;30bc / 'JP NZ,word'
    jp s_2ec9h		;30bd	--> ...
;
;
;
s_30c0h:
    ld a,(MainFlg)	;30c0
    or a		;30c3
    ret z		;30c4	if (MainFlg).eq.0 (Main program) Return
    ld hl,(l0167h)	;30c5
    ld (DataID),hl	;30c8	(DataID)=(l0167h)
    xor a		;30cb	a=0
    ld (TypeID),a	;30cc	(TypeID)=0 (INTEGER)
    ld h,a		;30cf
    ld l,a		;30d0	hl=0
    ld (l0167h),hl	;30d1	(l0167h)=0
    call s_49ceh	;30d4	cd ce 49
;
;   Generation instructions calling sequence for actual parameters
;
s_30d7h:
    ld a,(NumArg)	;30d7
    or a		;30da
    ret z		;30db	if(NumArg).eq.0 (number of arguments to transfer) Return
    ld b,a		;30dc
    ld a,(BlkDat)	;30dd
    or a		;30e0
    ret nz		;30e1	if(BlkDat).ne.0 (Block data) Return
    ld hl,(l01cch)	;30e2
    push hl		;30e5 \ Save (l01cch)
    push bc		;30e6 \ Save (NumArg)
    call s_3151h	;30e7	cd 51 31
    ld a,022h		;30ea	'LD (word),HL'
    call s_2ec6h	;30ec	cd c6 2e
    pop bc		;30ef /
    dec b		;30f0
    jp z,l311eh	 ;--;	;30f1	if (NumArg).eq.1 --> ...
    push bc	    ;	;30f4 \
    ld a,0ebh	    ;	;30f5	'EX DE,HL'
    call PutOpc	    ;	;30f7
    call s_3151h    ;	;30fa	cd 51 31
    ld a,022h	    ;	;30fd	'LD (word),HL'
    call s_2ec6h    ;	;30ff	cd c6 2e
    pop af	    ;	;3102 /
    dec a	    ;	;3103
    jp z,l311eh	 ;--;	;3104	if (NumArg).eq.2 --> ...
    cp 1	    ;	;3107
    jp nz,l3136h ;--)-; ;3109	if (NumArg).ne.3 --> ...
    ld a,060h	    ; ; ;310c	'LD H,B'
    call PutOpc	    ; ; ;310e
    ld a,069h	    ; ; ;3111	'LD L,C'
    call PutOpc	    ; ; ;3113
    call s_3151h    ; ; ;3116	cd 51 31
    ld a,022h	    ; ; ;3119	'LD (word),HL'
    call s_2ec6h    ; ; ;311b	cd c6 2e
l311eh:		;<--+ ;
    ld hl,(l0263h)    ; ;311e
    ld a,h	      ; ;3121
    or l	      ; ;3122
    jp z,l3132h ;---; ; ;3123	if(l0263h).eq.0 --> ...
    call ExtAttr    ; ; ;3126	Extract Attributes from the symbol table
    ld hl,(PrgSiz)  ; ; ;3129
    ld (DataID),hl  ; ; ;312c	(DataID)=(PrgSiz)
    call PutAttr    ; ; ;312f	Put Attributes in Symbol table
l3132h:		;<--+ ;
    pop hl	      ; ;3132	hl=(l01cch)
    jp ExtAttr	      ; ;3133	--> Extract Attributes from the symbol table
		      ;
l3136h:		;<----+
    push af		;3136 \
    ld a,03eh		;3137	'LD A,byte'
    call PutOpc		;3139
    pop af		;313c / a=(NumArg)-2
    call p_byte		;313d	Put byte in reg A to REL file
    call s_3151h	;3140	cd 51 31
    ld a,021h		;3143	'LD HL,word'
    call s_2ec6h	;3145	cd c6 2e
    ld bc,'AT'		;3148	$AT - Argument Transfer routine
    call CrBuilt	;314b	Creating built-in routine
    jp l311eh		;314e	--> ...
;
;
;
s_3151h:
    ld hl,(l0295h)	;3151
    ld (DataID),hl	;3154	(DataID)=(l0295h)
    inc hl		;3157
    inc hl		;3158
    ld (l0295h),hl	;3159	(l0295h)=(l0295h)+2
    ld a,3		;315c
    ld (KindID),a	;315e	(KindID)=3 (Variable)
    dec a		;3161
    ld (ScopeID),a	;3162	(ScopeID)=2
    ld hl,0ffffh	;3165	hl=0ffffh
    ret			;3168
;
;
;
s_3169h:
    ld hl,(l01cch)	;3169
    push hl		;316c \ Save (l01cch)
    call l2681h		;316d	hl=(l0250h)=0
    ex de,hl		;3170			    hl=		de=0
    jp l3176h	;---;	;3171	--> ...
		    ;
l3174h:		    ;
    pop de	    ;	;3174	d1
    dec de	    ;	;3175	1b
l3176h:	       ;<---+
    push de		;3176 \ d5
    ld hl,(l0206h)	;3177	2a 06 02
    add hl,de		;317a	19
    ex de,hl		;317b	eb
    ld hl,(HeapEnd)	;317c	2a 12 02
    call cmpHL_DE	;317f	Compare HL with DE
    jp c,l319ch	 ;--;	;3182	if HL < DE --> ...
    pop hl	    ;	;3185 / e1
    ld hl,(l0206h)  ;	;3186
    ld (HeapEnd),hl ;	;3189	(HeapEnd)=(l0206h)
    ld (l0209h),hl  ;	;318c	(l0209h)=(l0206h)
    ld hl,00000h    ;	;318f	hl=0
    ld (l029ch),hl  ;	;3192	(l029ch)=0
    ld (l029eh),hl  ;	;3195	(l029eh)=0
    pop hl	    ;	;3198 / e1
    jp ExtAttr	    ;	;3199	--> Extract Attributes from the symbol table
		    ;
l319ch:		;<--+
    ld a,(de)		;319c	1a
    and 01fh		;319d	00011111b
    ld (l0242h),a	;319f	32 42 02
    ld b,a		;31a2	Save (l0242h)
    dec de		;31a3	1b
    ld a,(de)		;31a4	1a
    ld (TypeID),a	;31a5	Save value type variable
    ex de,hl		;31a8	eb
    dec hl		;31a9	2b
    ld d,(hl)		;31aa	56
    dec hl		;31ab	2b
    ld e,(hl)		;31ac	5e
    pop hl		;31ad	e1
    dec hl		;31ae	2b
    dec hl		;31af	2b
    dec hl		;31b0	2b
    push hl		;31b1	e5
    ex de,hl		;31b2	eb
    ld (l023ah),hl	;31b3	22 3a 02
    ld (l01cch),hl	;31b6	22 cc 01
    ld a,b		;31b9	Restore (l0242h)
    cp 6		;31ba
    jp z,l3250h		;31bc	if (l0242h).eq.6 --> ...
    or a		;31bf
    jp z,l3279h		;31c0	if (l0242h).eq.0 --> ...
    cp 0bh		;31c3
    jp c,l342eh		;31c5	if (l0242h) < 0bh --> ...
    jp z,l3327h		;31c8	if (l0242h).eq.0bh --> ...
    cp 0ch		;31cb
    jp z,l3342h		;31cd	if (l0242h).eq.0ch --> ...
    cp 13h		;31d0
    jp z,l336bh		;31d2	if (l0242h).eq.13h --> ...
    cp 14h		;31d5
    jp z,l3336h		;31d7	if (l0242h).eq.14h --> ...
    cp 17h		;31da
    jp z,l33d3h		;31dc	if (l0242h).eq.17h --> ...
    cp 15h		;31df
    jp z,l33a8h		;31e1	if (l0242h).eq.15h --> ...
    push af		;31e4 \
    call s_3725h	;31e5	cd 25 37
    pop af		;31e8 /
    ld bc,l3243h	;31e9	Point to l3243h
    push bc		;31ec \ c5
    sub 0dh		;31ed	d6 0d
    jp nz,l31fch ;--;	;31ef	c2 fc 31
    ld a,017h	    ;	;31f2	'RLA'
    call PutOpc	    ;	;31f4
    ld a,03fh	    ;	;31f7	'CCF'
    jp PutOpc	    ;	;31f9	--> ...
		    ;
l31fch:	      ;<----+
    dec a		;31fc	3d
    jp nz,l320fh ;--;	;31fd	c2 0f 32
    ld a,03dh	    ;	;3200	'DEC A'
    call PutOpc	    ;	;3202
    ld a,0c6h	    ;	;3205	'ADD A,byte'
    call PutOpc	    ;	;3207
    ld a,081h	    ;	;320a	3e 81
    jp p_byte	    ;	;320c	--> Put byte in reg A to REL file
		    ;
l320fh:	      ;<----+
    dec a		;320f	3d
    jp nz,l321dh ;--;	;3210	c2 1d 32
    ld a,0c6h	    ;	;3213	'ADD A,byte'
    call PutOpc	    ;	;3215
    ld a,0ffh	    ;	;3218	3e ff
    jp p_byte	    ;	;321a	--> Put byte in reg A to REL file
		    ;
l321dh:	      ;<----+
    dec a		;321d	3d
    jp nz,l3226h ;--;	;321e	c2 26 32
    ld a,017h	    ;	;3221	'RLA'
    jp PutOpc	    ;	;3223	--> ...
		    ;
l3226h:	      ;<----+
    dec a		;3226	3d
    jp nz,l3239h ;--;	;3227	c2 39 32
    ld a,03dh	    ;	;322a	'DEC A'
    call PutOpc	    ;	;322c
    ld a,0d6h	    ;	;322f	'SUB byte'
    call PutOpc	    ;	;3231
    ld a,07fh	    ;	;3234	a=7FH
    jp p_byte	    ;	;3236	--> Put byte in reg A to REL file
		    ;
l3239h:	      ;<----+
    ld a,0d6h		;3239	'SUB byte'
    call PutOpc		;323b
    ld a,1		;323e	a=1
    jp p_byte		;3240	--> Put byte in reg A to REL file
;
l3243h:
    ld a,09fh		;3243	'SBC A,A'
    call PutOpc		;3245
    ld a,2		;3248	a=2
    ld (i_Type),a	;324a	(i_Type)=2 (BYTE)
    jp l3436h		;324d	--> ...
;
l3250h:
    xor a		  ;3250 a=0
    call s_2ec9h	  ;3251 cd c9 2e
    pop de		  ;3254 d1
    push de		  ;3255 d5
    dec de		  ;3256 1b
    ld hl,(l0206h)	  ;3257 2a 06 02
    add hl,de		  ;325a 19
    ex de,hl		  ;325b eb
    ld hl,(HeapEnd)	  ;325c 2a 12 02
    call cmpHL_DE	  ;325f Compare HL with DE
    jp nc,l326dh ;--;	  ;3262 if HL >= DE --> ...
    ld a,(de)	    ;	  ;3265 1a
    and 01fh	    ;	  ;3266 00011111b
    cp 6	    ;	  ;3268 fe 06
    jp z,l3174h	    ;	  ;326a if eq.6 --> ...
l326dh:		 ;<-+
    ld hl,(l0171h)	  ;326d
    ld (l023ah),hl	  ;3270 (l023ah)=(l0171h)
    call ExtAttr	  ;3273 Extract Attributes from the symbol table
    jp l32d8h	;-------; ;3276 --> ...
			;
l3279h:			;
    call s_4647h	; ;3279 Extract Attributes from the symbol table, entry( l01cch)
    cp 5		; ;327c
    jp z,l32b8h	 ;----; ; ;327e if (KindID).eq.5 (Routine) --> ...
    ld hl,TypeID      ; ; ;3281 hl=Pointer to value type variable
    ld a,(hl)	      ; ; ;3284
    or a	      ; ; ;3285
    jp nz,l32b2h ;--; ; ; ;3286 if (TypeID).ne.0 (INTEGER) --> ...
    pop de	    ; ; ; ;3289 d1
    push de	    ; ; ; ;328a d5
    push hl	    ; ; ; ;328b e5
    dec de	    ; ; ; ;328c 1b
    ld hl,(l0206h)  ; ; ; ;328d 2a 06 02
    add hl,de	    ; ; ; ;3290 19
    ex de,hl	    ; ; ; ;3291 eb
    ld hl,(HeapEnd) ; ; ; ;3292 2a 12 02
    call cmpHL_DE   ; ; ; ;3295 Compare HL with DE
    ex de,hl	    ; ; ; ;3298 eb
    ld a,(hl)	    ; ; ; ;3299 7e
    dec hl	    ; ; ; ;329a 2b
    ld b,(hl)	    ; ; ; ;329b 46
    pop hl	    ; ; ; ;329c e1
    jp nc,l32b2h ;--; ; ; ;329d if HL >= DE --> ...
    and 01fh	    ; ; ; ;32a0 00011111b
    cp 7	    ; ; ; ;32a2 fe 07
    jp nz,l32b2h ;--; ; ; ;32a4 if ne 7 --> ...
    ld a,b	    ; ; ; ;32a7 78
    cp 2	    ; ; ; ;32a8 fe 02
    jp nz,l32b2h ;--; ; ; ;32aa if ne 2 --> ...
    ld (hl),a	    ; ; ; ;32ad 77
    ld hl,l0250h    ; ; ; ;32ae
    dec (hl)	    ; ; ; ;32b1 (l0250h)=(l0250h)-1
l32b2h:		;<--+ ; ;
    call s_2dech      ; ; ;32b2 cd ec 2d
    jp l3174h	      ; ; ;32b5 --> ...
		      ; ;
l32b8h:	     ;<-------+ ;
    pop de		; ;32b8 d1
    push de		; ;32b9 d5
    dec de		; ;32ba 1b
    ld hl,(l0206h)	; ;32bb 2a 06 02
    add hl,de		; ;32be 19
    ex de,hl		; ;32bf eb
    ld hl,(HeapEnd)	; ;32c0 2a 12 02
    call cmpHL_DE	; ;32c3 Compare HL with DE
    jp nc,l32d8h  ;-----; ;32c6 if HL >= DE --> ...
    ex de,hl		; ;32c9 eb
    ld a,(hl)		; ;32ca 7e
    and 01fh		; ;32cb 00011111b
    cp 6		; ;32cd fe 06
    ld hl,(l023ah)	; ;32cf
    ld (l0171h),hl	; ;32d2 (l0171h)=(l023ah)
    jp z,l3174h		; ;32d5 ca 74 31 --> ...
l32d8h:		;<------+
    ld a,(ScopeID)	  ;32d8
    cp 3		  ;32db
    jp nz,l32f9h ;--;	  ;32dd if (ScopeID).ne.3 --> ...
    ld hl,(PrgSiz)  ;	  ;32e0 Load Program size
    inc hl	    ;	  ;32e3
    ld (l0169h),hl  ;	  ;32e4 (l0169h)=(PrgSiz)+1
    ld a,021h	    ;	  ;32e7 'LD HL,word'
    call s_37e3h    ;	  ;32e9 Put opcode & word=0000 to REL file
    ld a,0e5h	    ;	  ;32ec 'PUSH HL'
    call PutOpc	    ;	  ;32ee
    call s_3095h    ;	  ;32f1 'LD HL,(word)'
    ld a,0e5h	    ;	  ;32f4 'PUSH HL'
    call PutOpc	    ;	  ;32f6
l32f9h:		;<--+
    call s_34c3h	  ;32f9 cd c3 34
    jp l3436h		  ;32fc --> ...
;
l32ffh:
    ld a,001h		;32ff	'LD BC,word'
    call PutOpc		;3301
    ld b,2		;3304	b=2
    call w_code		;3306	Output control prefix 1.b2.b1 (Reg B holds two bit control)
    ld hl,(l0249h)	;3309	2a 49 02
    ld a,(NoCode)	;330c
    or a		;330f	test /N
    call z,s_3a85h	;3310	if (NoCode).eq.0 Put addres DATA" to console trap_ms (03a85h) ***
    push hl		;3313	e5
    ld b,l		;3314	45
    call w_byte		;3315	Put byte to REL file from Reg B
    pop bc		;3318	c1
    call w_byte		;3319	Put byte to REL file from Reg B
    ld hl,(PrgSiz)	;331c	Load Program size
    inc hl		;331f
    inc hl		;3320
    ld (PrgSiz),hl	;3321	(PrgSiz)=(PrgSiz)+2
    jp l3503h		;3324	--> ...
;
l3327h:
    ld hl,(l023ah)	;3327
    ld (l01b0h),hl	;332a	(l01b0h)=(l023ah)
    call s_0da4h	;332d	Code generation DO statement
l3330h:		;<--;
    call l2681h	    ;	;3330	hl=(l0250h)=0
    jp l3174h	    ;	;3333	--> ...
		    ;
l3336h:		    ;
    ld hl,(l023ah)  ;	;3336
    ld (l01b0h),hl  ;	;3339	(l01b0h)=(l023ah)
    call s_25bdh    ;	;333c	cd bd 25
    jp l3330h	;---+	;333f	--> ...
;
l3342h:
    ld hl,l3436h	;3342	Point to l3436h ???
    push hl		;3345 \ save to return ???
    ld a,(i_Type)	;3346
    or a		;3349
    jp z,l292ch		;334a	if (i_Type).eq.0 (INTEGER) --> ...
    dec a		;334d	3d
    ld bc,'NB'		;334e	$NB
    jp z,CrBuilt	;3351	if (i_Type).eq.1 (REAL)	   --> Creating built-in routine $NB
    ld c,'U'		;3354	0e 55
    dec a		;3356	3d
    dec a		;3357	3d
    jp z,CrBuilt	;3358	if (i_Type).eq.3 (DOUBLE)  --> Creating built-in routine $NU
    ld c,'1'		;335b	0e 31
    dec a		;335d	3d
    jp z,CrBuilt	;335e	if (i_Type).eq.4 (INTEGER*4)--> Creating built-in routine $N1
    ld a,02fh		;3361	'CPL'
    call PutOpc		;3363
    ld a,03ch		;3366	'INC A'
    jp PutOpc		;3368	--> ...
;
l336bh:
    call s_4647h	;336b	Extract Attributes from the symbol table, entry( l01cch)
    pop de		;336e / d1
    push de		;336f \ d5
    inc de		;3370	13
    inc de		;3371	13
    inc de		;3372	13
    ld a,d		;3373
    or e		;3374	Test de
    jp z,l341bh		;3375	if de.eq.0 --> ...
    inc de		;3378	13
    inc de		;3379	13
    inc de		;337a	13
    inc de		;337b	13
    ld hl,(l0206h)	;337c	2a 06 02
    add hl,de		;337f	19
    ld a,(hl)		;3380	7e
    and 01fh		;3381	00011111b
    cp 6		;3383	fe 06
    jp z,l341bh		;3385	if eq 6 --> ...
    cp 7		;3388	fe 07
    jp z,l341bh		;338a	if eq 7 --> ...
    cp 013h		;338d	fe 13
    jp z,l341bh		;338f	if eq 13h --> ...
    ld hl,0ffffh	;3392	21 ff ff    hl=-1
    ld (l0250h),hl	;3395	(l0250h)=-1
    ld a,(ScopeID)	;3398
    cp 3		;339b
    jp z,l33efh		;339d	if(ScopeID).eq.3 --> ...
    ld a,011h		;33a0	'LD DE,word'
    call s_2ec9h	;33a2	cd c9 2e
    jp l3404h		;33a5	--> ...
;
l33a8h:
    ld a,(i_Type)	;33a8
    or a		;33ab
    ld hl,l3436h	;33ac	Point to l3436h ???
    push hl		;33af \ save to return ???
    ld a,02fh		;33b0
    jp nz,PutOpc	;33b2	if(i_Type).ne.0 (INTEGER) --> 'CPL'
    ld a,07dh		;33b5	'LD A,L'
    call PutOpc		;33b7
    ld a,02fh		;33ba	'CPL'
    call PutOpc		;33bc
    ld a,06fh		;33bf	'LD L,A'
    call PutOpc		;33c1
    ld a,07ch		;33c4	'LD A,H'
    call PutOpc		;33c6
    ld a,02fh		;33c9	'CPL'
    call PutOpc		;33cb
    ld a,067h		;33ce	'LD H,A'
    jp PutOpc		;33d0	--> ...
;
l33d3h:
    ld hl,l3436h	;33d3	Point to l3436h ???
    push hl		;33d6 \ save to return ???
    call l2681h		;33d7	hl=(l0250h)=0
    ld a,(TypeID)	;33da
    ld (i_Type),a	;33dd	(i_Type)=(TypeID)
    or a		;33e0
    jp z,l2e72h		;33e1	if (i_Type).eq.0 (INTEGER) --> ...
    dec a		;33e4
    jp z,l2e38h		;33e5	if (i_Type).eq.1 (REAL) --> Load floating accumulator
    dec a		;33e8
    jp z,l2e65h		;33e9	if (i_Type).eq.2 (BYTE) --> ...
    jp l2e38h		;33ec	--> Load floating accumulator
;
l33efh:
    ld a,(i_Type)	;33ef
    or a		;33f2
    jp z,l33fch ;---;	;33f3	if(i_Type).eq.0 (INTEGER) --> ...
    call s_25a5h    ;	;33f6	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ;	;33f9	(i_Type)=0 (INTEGER)
l33fch:		;<--+
    ld a,0ebh		;33fc	'EX DE,HL'
    call PutOpc		;33fe
    call s_3095h	;3401	'LD HL,(word)'
l3404h:
    ld a,(i_Type)	;3404
    or a		;3407
    jp z,l3411h ;---;	;3408	if(i_Type).eq.0 (INTEGER) --> ...
    call s_25a5h    ;	;340b	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    ld (i_Type),a   ;	;340e	(i_Type)=0 (INTEGER)
l3411h:		;<--+
    ld a,019h		;3411	'ADD HL,DE'
    call PutOpc		;3413
l3416h:			;
    ld a,1		;3416	a=1
    jp l3437h	;---;	;3418	--> ...
		    ;
l341bh:		    ;
    xor a	    ;	;341b
    ld (i_Type),a   ;	;341c	(i_Type)=0 (INTEGER)
    ld a,(ScopeID)  ;	;341f
    cp 3	    ;	;3422
    ld hl,l3416h    ;	;3424	Point to l3416h ???
    push hl	    ;	;3427 \ Save to return	???
    jp z,s_3095h    ;	;3428	if(ScopeID).eq.3 --> 'LD HL,(word)'
    jp s_3090h	    ;	;342b	--> 'LD HL,word'
		    ;
l342eh:		    ;
    push af	    ;	;342e \ f5
    call s_4647h    ;	;342f	Extract Attributes from the symbol table, entry( l01cch)
    pop af	    ;	;3432 / f1
    call s_294ah    ;	;3433	cd 4a 29
l3436h:		    ;
    xor a	    ;	;3436	a=0
l3437h:		;<--+
    ld (l0275h),a	;3437	32 75 02
    pop de		;343a / d1
    push de		;343b \ d5
    inc de		;343c	13
    inc de		;343d	13
    inc de		;343e	13
    ld hl,(l0206h)	;343f	2a 06 02
    add hl,de		;3442	19
    ld (l0209h),hl	;3443	22 09 02
    ex de,hl		;3446	eb
    call Neg_HL		;3447	Negate HL
    xor a		;344a	a=0
    push af		;344b \ f5
    ex de,hl		;344c	eb
    call s_56fah	;344d	cd fa 56
    pop bc		;3450 / c1
    jp nz,l3174h	;3451	c2 74 31
    push bc		;3454 \ c5
    ld a,(hl)		;3455	7e
    and 01fh		;3456	00011111b
    cp 015h		;3458
    jp z,l570ch		;345a	if a.eq.15h --> ...
    cp 017h		;345d
    jp z,l570ch		;345f	if a.eq.17h --> ...
    cp 00ch		;3462
    jp c,l346ch	 ;--;	;3464	if a < 0ch --> ...
    cp 013h	    ;	;3467
    jp c,l570ch	    ;	;3469	if a < 13h --> ...
l346ch:		;<--+
    pop bc		;346c / c1
    ld a,b		;346d	78
    or a		;346e	b7
    jp nz,l34b5h  ;---; ;346f	if ne 0 --> ...
    inc a	      ; ;3472	3c
    push af	      ; ;3473 \ f5
    ex de,hl	      ; ;3474	eb
    ld hl,(l0206h)    ; ;3475	2a 06 02
    call subHL_DE     ; ;3478	hl=hl-de
    push hl	      ; ;347b \ e5
    ld a,(i_Type)     ; ;347c	3a 28 02
    ld b,a	      ; ;347f	Save (i_Type)
    ld a,(l0275h)     ; ;3480
    or a	      ; ;3483
    ld a,b	      ; ;3484	Restore (i_Type)
    jp z,l348dh	  ;-; ; ;3485	if (l0275h).eq.0 --> a=(i_Type)
    ld a,(TypeID)   ; ; ;3488	Load value type variable
    push af	    ; ; ;348b \ f5
    xor a	    ; ; ;348c	a=0
l348dh:		;<--+ ;
    call s_1864h      ; ;348d	Creation variable T:xxx in a symbol table
    ld a,7	      ; ;3490	a=7
    call s_294ah      ; ;3492	cd 4a 29
    ld a,(l0275h)     ; ;3495
    or a	      ; ;3498
    jp z,l34abh	 ;--; ; ;3499	if (l0275h).eq.0 --> ...
    pop af	    ; ; ;349c / f1
    ld (TypeID),a   ; ; ;349d	Save value type variable
    ld a,3	    ; ; ;34a0
    ld (ScopeID),a  ; ; ;34a2	(ScopeID)=3
    call PutAttr    ; ; ;34a5	Put Attributes in Symbol table
    call l2681h	    ; ; ;34a8	hl=(l0250h)=0
l34abh:		;<--+ ;
    pop de	      ; ;34ab	d1
    ld hl,(l0206h)    ; ;34ac	2a 06 02
    call subHL_DE     ; ;34af	hl=hl-de
    jp l34b6h	;---; ; ;34b2	--> ...
		    ; ;
l34b5h:	     ;<-----)-+
    push af	    ;	;34b5	f5
l34b6h:		;<--+
    ex de,hl		;34b6	eb
    ld hl,(l01cch)	;34b7	2a cc 01
    ex de,hl		;34ba	eb
    dec hl		;34bb	2b
    dec hl		;34bc	2b
    ld (hl),d		;34bd	72
    dec hl		;34be	2b
    ld (hl),e		;34bf	73
    jp l570ch		;34c0	--> ...
;
;
;
s_34c3h:
    ld hl,(l01cch)	;34c3
    push hl		;34c6 \ Save (l01cch)
    ld a,(l024bh)	;34c7
    or a		;34ca
    jp z,l3506h ;-----; ;34cb	if (l024bh).eq.0  --> ...
    dec a	      ; ;34ce
    jp nz,l34d8h ;-;  ; ;34cf	if (l024bh).ne.1 --> ...
    call s_3082h   ;  ; ;34d2	cd 82 30
    jp l3506h	;--)--; ;34d5	--> ...
		   ;  ;
l34d8h:	     ;<----+  ;
    dec a	      ; ;34d8
    jp z,l3503h ;---; ; ;34d9	if (l024bh).ne.2 --> ...
    dec a	    ; ; ;34dc
    jp nz,l32ffh    ; ; ;34dd	if (l024bh).ne.3 --> ...
    ld hl,(l0249h)  ; ; ;34e0	2a 49 02
    call ExtAttr    ; ; ;34e3	Extract Attributes from the symbol table
    ld a,(ScopeID)  ; ; ;34e6
    cp 3	    ; ; ;34e9
    jp z,l34f6h ;-; ; ; ;34eb	if (ScopeID).eq.3 --> ...
    ld a,001h	  ; ; ; ;34ee	'LD BC,word'
    call s_2ec9h  ; ; ; ;34f0	cd c9 2e
    jp l3503h	;-)-; ; ;34f3	--> ...
		  ; ; ;
l34f6h:	     ;<---+ ; ;
    call s_3095h    ; ; ;34f6	'LD HL,(word)'
    ld a,044h	    ; ; ;34f9	'LD B,H'
    call PutOpc	    ; ; ;34fb
    ld a,04dh	    ; ; ;34fe	'LD C,L'
    call PutOpc	    ; ; ;3500
l3503h:	      ;<----+ ;
    call s_3064h      ; ;3503	cd 64 30
l3506h:	      ;<------+
    pop hl		;3506 / Restore (l01cch)
    call ExtAttr	;3507	Extract Attributes from the symbol table
    ld a,(TypeID)	;350a
    ld (i_Type),a	;350d	(i_Type)=(TypeID)
    ld a,(ScopeID)	;3510
    cp 3		;3513
    jp z,l3538h	  ;---; ;3515	if (ScopeID).eq.3 --> ...
    ld hl,(l01cch)    ; ;3518
    ex de,hl	      ; ;351b
    ld hl,(l01c4h)    ; ;351c
    call cmpHL_DE     ; ;351f	Compare HL with DE
    jp nc,l3530h ;--; ; ;3522	if (l01c4h) >= (l01cch) --> ...
    ld a,03eh	    ; ; ;3525	'LD A,byte'
    call PutOpc	    ; ; ;3527
    ld a,(l024bh)   ; ; ;352a	3a 4b 02
    call p_byte	    ; ; ;352d	Put byte in reg A to REL file
l3530h:	      ;<----+ ;
    ld a,0cdh	      ; ;3530	'CALL word'
    call s_2ec9h      ; ;3532	cd c9 2e
    jp l3546h	;---; ; ;3535	--> ...
		    ; ;
l3538h:	      ;<----)-+
    ld a,0c9h	    ;	;3538	'RET'
    call PutOpc	    ;	;353a
    ld hl,(l0169h)  ;	;353d	2a 69 01
    ld bc,010ch	    ;	;3540	Address modes CSEG, REL type - EXTERNAL-OFFSET (12)
    call s_4a15h    ;	;3543	ex de<->hl -> RELITEM
l3546h:	      ;<----+
    xor a		;3546
    ld (l024bh),a	;3547	(l024bh)=0
    jp l2681h		;354a	--> (l0250h)=0 ret
;
;   Build standard fortran header
;	LD BC,<return address>
;	JP $INIT
s_354dh:
    ld a,(BlkDat)	;354d	Load Flag Block data
    or a		;3550
    ret nz		;3551	if(BlkDat).eq.0 (not Block data) Return
    ld hl,(l01cch)	;3552
    push hl		;3555 \ Save (l01cch)
    ld hl,l35bfh	;3556	Point to l35bfh
    push hl		;3559 \ Save l35bfh to return
    ld hl,'$$'		;355a
    ld (l01d5h),hl	;355d	(l01d5h)='$$'
    ld a,2		;3560
    ld (SizeID),a	;3562	(SizeID)=2
    ld (KindID),a	;3565	(KindID)=2 (Label)
    xor a		;3568
    ld (TypeID),a	;3569	(TypeID)=0 (INTEGER)
    call s_055ah	;356c	cd 5a 05
    ld a,2		;356f
    ld (ScopeID),a	;3571	(ScopeID)=2
    ld hl,(PrgSiz)	;3574	Load Program size
    ld de,00006h	;3577	de=6 - Length code Header in bytes
    add hl,de		;357a
    ld (DataID),hl	;357b	(DataID)=(PrgSiz)+6
    call PutAttr	;357e	Put Attributes in Symbol table
    ld a,001h		;3581	'LD BC,word'
    call s_2ec9h	;3583	cd c9 2e
    ld hl,l02eah	;3586	hl="$INIT" - Name routine (Sets the stack pointer at the top of available memory)
    ld de,l01d2h	;3589	Destination address
    ld b,5		;358c	b=5 (Length name)
    call s_085ch	;358e	Move B bytes from ^HL to ^DE
    ld a,5		;3591
    ld (KindID),a	;3593	(KindID)=5 (Routine)
    ld (SizeID),a	;3596	(SizeID)=5 (Length name)
    call s_055ah	;3599	cd 5a 05
    ld a,0c3h		;359c	'JP word'
    call s_2ec9h	;359e	cd c9 2e
    ld hl,(l0263h)	;35a1
    ld a,h		;35a4
    or l		;35a5
    ret z	 ;----; ;35a6	if (l0263h).eq.0 Return to l35bfh
    call ExtAttr      ; ;35a7	Extract Attributes from the symbol table
    ld a,(RomFlg)     ; ;35aa
    or a	      ; ;35ad	Test /M
    jp nz,l35b6h  ;-; ; ;35ae	if (RomFlg).ne.0 --> ...
    ld a,(TypeID)   ; ; ;35b1
    or a	    ; ; ;35b4
    ret nz	;---)-; ;35b5	if(TypeID).ne.0 (INTEGER) Return to l35bfh
l35b6h:	      ;<----+ ;
    ld hl,(PrgSiz)    ; ;35b6
    ld (DataID),hl    ; ;35b9	(DataID)=(PrgSiz)
    jp PutAttr	      ; ;35bc	--> Put Attributes in Symbol table
		      ;
l35bfh:	    ;<--------+
    pop hl		;35bf / Restore (l01cch)
    jp ExtAttr		;35c0	--> Extract Attributes from the symbol table
;
;   Processing RETURN
;
PrReturn:
    ld a,(MainFlg)	;35c3 +
    or a		;35c6 +
    jp nz,l35ceh ;--;	;35c7 + if (MainFlg).ne.0 (Subprogram) --> Skip error message
    call err_msg    ;	;35ca + Warning (25)
    db 25	    ;	;35cd + RETURN in a Main Program
l35ceh:	      ;<----+
    call s_35d7h	;35ce	cd d7 35
    call g_n_chr	;35d1 +
    jp l259ah		;35d4	--> Set 1 (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_35d7h:
    ld a,(SubrFlg)	;35d7
    or a		;35da
    jp nz,l35e7h ;--;	;35db	if (SubrFlg).ne.0 (Subroutine) --> ...
    ld hl,(l0267h)  ;	;35de
    ld (l01cch),hl  ;	;35e1	(l01cch)=(l0267h)
    call s_1472h    ;	;35e4	cd 72 14
l35e7h:	     ;<-----+
    call s_3169h	;35e7	cd 69 31
    ld a,0c9h		;35ea	'RET'
    jp PutOpc		;35ec	--> ...
;
l35efh:
    ld hl,(l01cch)	;35ef
    push hl		;35f2 \ Save (l01cch)
    ld a,(ScopeID)	;35f3
    or a		;35f6
    jp z,l3603h	 ;--;	;35f7	if (ScopeID).eq.0 --> ...
    cp 2	    ;	;35fa
    jp z,l3603h	 ;--;	;35fc	if (ScopeID).eq.2 --> Skip error message
    call err_msg    ;	;35ff	Error (125)
    db 125	    ;	;3602	Illegal Statement Function Name
		    ;
l3603h:	     ;<-----+
    ld a,5		;3603
    ld (KindID),a	;3605	(KindID)=5 (Routine)
    call PutAttr	;3608	Put Attributes in Symbol table
    ld a,8		;360b	a=8
    call s_5012h	;360d	cd 12 50
    ld hl,(PrgSiz)	;3610
    ld (DataID),hl	;3613	(DataID)=(PrgSiz)
    ld hl,ScopeID	;3616
    ld (hl),2		;3619	(ScopeID)=2
    call PutAttr	;361b	Put Attributes in Symbol table
    ld a,(PosStm)	;361e	3a 07 01
    push af		;3621 \ Save (PosStm)
    ld hl,PrCall	;3622
    ld (CurAdr),hl	;3625	(CurAdr)=point to Processing CALL
l3628h:	     ;<-----;
    call PrName	    ;	;3628	Processing name
    ld hl,(l01cch)  ;	;362b
    ld (l01b2h),hl  ;	;362e	(l01b2h)=(l01cch)
    ld hl,(DataID)  ;	;3631
    ld (l01aeh),hl  ;	;3634	(l01aeh)=(DataID)
    ld hl,(ScopeID) ;	;3637
    ld (l01aah),hl  ;	;363a	(l01aah)=(ScopeID)
    ld a,(KindID)   ;	;363d
    ld (l01a8h),a   ;	;3640	(l01a8h)=(KindID)
    ld a,(TypeID)   ;	;3643
    ld (l01a9h),a   ;	;3646	(l01a9h)=(TypeID)
    ld hl,(EntryID) ;	;3649
    ld (l01a6h),hl  ;	;364c	(l01a6h)=(EntryID)
    call l0e41h	    ;	;364f	cd 41 0e
    ld a,(l0298h)   ;	;3652
    cp ','	    ;	;3655
    jp z,l3628h ;---+	;3657	if (l0298h).eq.',' --> ...
    ld hl,l35efh	;365a
    ld (CurAdr),hl	;365d	(CurAdr)=point to l35efh
    pop af		;3660 / Restore (PosStm)
    ld (PosStm),a	;3661	(PosStm)=(PosStm)
    ld hl,l0298h	;3664
    ld (hl),'('		;3667	(l0298h)=028h "("
    call s_1909h	;3669	Processing of actual parameters subprogram
    call s_30d7h	;366c	Generation instructions calling sequence for actual parameters
    ld a,'='		;366f
    call ch_chr		;3671	Check character (a character for check)
    ld hl,l0261h	;3674
    ld (hl),9		;3677	(l0261h)=9
    xor a		;3679	a=0
    call s_14dbh	;367a	cd db 14
    ld hl,l0261h	;367d
    ld (hl),8		;3680	(l0261h)=8
    call s_1472h	;3682	cd 72 14
    call s_3169h	;3685	cd 69 31
    pop hl		;3688 / hl=(l01cch)
    call ExtAttr	;3689	Extract Attributes from the symbol table
    ld a,(i_Type)	;368c
    ld hl,TypeID	;368f
    cp (hl)		;3692
    jp z,l36c9h		;3693	if (i_Type).eq.(TypeID) --> ...
    or a		;3696
    jp nz,l36a3h ;--;	;3697	if (i_Type).ne.0 (INTEGER) --> ...
    or (hl)	    ;	;369a
    cp 2	    ;	;369b
    jp z,l36c4h ;---)-; ;369d	if (i_Type) & (TypeID).eq.2 (BYTE) --> ...
    ld a,(i_Type)   ; ; ;36a0
l36a3h:	     ;<-----+ ;
    sub 2	      ; ;36a3
    jp nz,l36b2h ;--; ; ;36a5	if (i_Type).ne.2 (BYTE) --> ...
    or (hl)	    ; ; ;36a8
    jp nz,l36b2h ;--; ; ;36a9	if (i_Type).ne.(TypeID) --> ...
    call s_25a5h    ; ; ;36ac	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
    jp l36c9h ;---; ; ; ;36af	--> ...
		  ; ; ;
l36b2h:	     ;<---)-+ ;
    ld a,(i_Type) ;   ; ;36b2
    rlca	  ;   ; ;36b5
    rlca	  ;   ; ;36b6
    rlca	  ;   ; ;36b7	(i_Type)*8
    add a,(hl)	  ;   ; ;36b8	(i_Type)*8+(TypeID)
    add a,'@'	  ;   ; ;36b9	(i_Type)*8+(TypeID)+'@'
    ld c,a	  ;   ; ;36bb	c=(i_Type)*8+(TypeID)+'@'
    ld b,'C'	  ;   ; ;36bc	$Cc
    call CrBuilt  ;   ; ;36be	Creating built-in routine
    jp l36c9h ;---;   ; ;36c1	--> ...
		  ;   ;
l36c4h:	     ;<---)---+
    ld a,07dh	  ;	;36c4	'LD A,L'
    call PutOpc	  ;	;36c6
l36c9h:	 ;<-------+
    ld hl,l66c6h	;36c9
    ld (l01b0h),hl	;36cc	(l01b0h)=l66c6h
l36cfh:		;<--;
    call s_4788h    ;	;36cf	cd 88 47
    ld hl,(l01b2h)  ;	;36d2	2a b2 01
    call ExtAttr    ;	;36d5	Extract Attributes from the symbol table
    ld hl,(l01aeh)  ;	;36d8
    ld (DataID),hl  ;	;36db	(DataID)=(l01aeh)
    ld a,(l01aah)   ;	;36de
    ld (ScopeID),a  ;	;36e1	(ScopeID)=(l01aah)
    ld a,(l01a8h)   ;	;36e4
    ld (KindID),a   ;	;36e7	(KindID)=(l01a8h)
    ld a,(l01a9h)   ;	;36ea
    ld (TypeID),a   ;	;36ed	(TypeID)=(l01a9h)
    ld hl,(l01a6h)  ;	;36f0
    ld (EntryID),hl ;	;36f3	(EntryID)=(l01a6h)
    call PutAttr    ;	;36f6	Put Attributes in Symbol table
    ld de,0000ah    ;	;36f9
    ld hl,(l01b0h)  ;	;36fc
    add hl,de	    ;	;36ff
    ld (l01b0h),hl  ;	;3700	(l01b0h)=(l01b0h)+10
    ex de,hl	    ;	;3703
    ld hl,(l01a4h)  ;	;3704
    call cmpHL_DE   ;	;3707	Compare HL with DE
    jp nz,l36cfh ;--+	;370a	if (l01a4h).ne.(l01b0h) --> ...
    ld hl,l66c6h	;370d
    ld (l01a4h),hl	;3710	(l01a4h)=l66c6h
    ld (HeapPtr),hl	;3713	(HeapPtr)=l66c6h
    ld hl,(l029ah)	;3716
    inc hl		;3719
    ld (l029ah),hl	;371a	(l029ah)=(l029ah)+1
    ld a,0c9h		;371d	'RET'
    call PutOpc		;371f
    jp l09e4h		;3722	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*
;*
s_3725h:
    ld a,(i_Type)	;3725
    dec a		;3728
    ret z		;3729	if(i_Type).eq.1 (REAL)	   Return
    cp 2		;372a
    ret z		;372c	if(i_Type).eq.3 (DOUBLE)   Return
    cp 3		;372d
    ret z		;372f	if(i_Type).eq.4 (INTEGER*4) Return
    dec a		;3730
    jp nz,l3743h  ;---; ;3731	if(i_Type).ne.2 (BYTE) --> ...
    ld a,(l0242h)     ; ;3734
    cp 015h	      ; ;3737
    jp z,l373eh	 ;--; ; ;3739	if(l0242h).eq.015h --> ...
    or a	    ; ; ;373c
    ret nz	    ; ; ;373d	if(l0242h).ne.0 Return
l373eh:		;<--+ ;
    ld a,0b7h	      ; ;373e	'OR A'
    jp PutOpc	      ; ;3740	--> ...
		      ;
l3743h:	      ;<------+
    ld a,07dh		;3743	'LD A,L'
    call PutOpc		;3745
    ld a,007h		;3748	'RLCA'
    call PutOpc		;374a
    ld a,0b5h		;374d	'OR L'
    call PutOpc		;374f
    ld a,0e6h		;3752	'AND byte'
    call PutOpc		;3754
    ld a,07fh		;3757	a=7fh
    call p_byte		;3759	Put byte in reg A to REL file
    ld a,0b4h		;375c	'OR H'
    jp PutOpc		;375e	--> ...
;*
;*  Put opcode to REL & PRN files
;*
PutOpc:
    ld (MnCode),a	    ;3761   (MnCode)=OpCode V3.4
    ld b,a		    ;3764   Save OpCode
    ld a,(NoCode)	    ;3765
    or a		    ;3768   Test /N
    jp nz,w_const	    ;3769   if (NoCode).ne.0 --> Put constant byte in reg B to REL file
    ld a,(enaLST)	    ;376c
    or a		    ;376f   Test /L
    jp z,w_const	    ;3770   if(enaLST).eq.0 --> Put constant byte in reg B to REL file
    ld hl,OpcTab	    ;3773   hl=first OpCode from Table Mnemonic
l3776h:		;<----;
      ld a,b	      ;	    ;3776   Restore OpCode
      cp (hl)	      ;	    ;3777   Compare opcode
      inc hl	      ;	    ;3778   hl=pointer 1 Mnemonic
      jp z,l3785h ;---)-;   ;3779   OpCode found
l377ch:	      ;<----; ; ;
	ld a,(hl)   ; ; ;   ;377c   Get character
	or a	    ; ; ;   ;377d   Test end Mnemonic
	inc hl	    ; ; ;   ;377e
      jp p,l377ch ;-+ ; ;   ;377f   .. nope
    jp l3776h	;-----+ ;   ;3782   test next opcode
			;
l3785h:		;<------+
    call s_4f46h	    ;3785   if (Column).ne.0 Put cr lf to console
    push hl		    ;3788
    call s_1465h	    ;3789   Print '*****'
    pop hl		    ;378c
    call s_3a70h	    ;378d   Put addres DATA' to console
    call puttab		    ;3790   Put tab to console
    call PrStrg		    ;3793   Print string
    jp w_const		    ;3796   --> Put constant byte in reg B to REL file
;*
;*  Put byte in reg A to REL file
;*
p_byte:
    ld b,a		;3799	Save a
    ld a,(NoCode)	;379a
    or a		;379d	test /N
    jp nz,w_const	;379e	if (NoCode).ne.0 --> Put constant byte in reg B to REL file
    ld a,b		;37a1	Restore a
    call puthex		;37a2	Put hex value A to console
    jp w_const		;37a5	--> Put constant byte in reg B to REL file
;*
;*  Put constant byte in reg A to REL file and bump pointer
;*
s_37a8h:
    ld b,a		;37a8
;*
;*  Put constant byte in reg B to REL file and bump pointer
;*
w_const:
    ld hl,(PrgSiz)	;37a9	Load Program size
    inc hl		;37ac
    ld (PrgSiz),hl	;37ad	(PrgSiz)=(PrgSiz)+1 Add 1 to code pointer
    xor a		;37b0	a=0
    call w_bit		;37b1	Put zero bit
;*
;*  Put byte to REL file from Reg B
;*    ENTRY Reg B holds the byte for output
;*
w_byte:
    push bc		;37b4
    ld c,-8		;37b5	Set byte count
l37b7h:		;<--;
      ld a,b	    ;	;37b7
      rla	    ;	;37b8	.. get bit
      ld b,a	    ;	;37b9
      call w_bit    ;	;37ba	.. put it
      inc c	    ;	;37bd
    jp nz,l37b7h ;--+	;37be
    pop bc		;37c1
    ret			;37c2
;
l37c3h: db  '*****',_tab    ;37c3

;*
;*  Put 'JP Z,word' & word=0000 to REL file
;*
s_37c9h:
    ld a,0cah		;37c9	'JP Z,word'
    jp s_37d0h	;---;	;37cb	--> ...
		    ;
;*  Put 'JP word' & word=0000 to REL file
		    ;
s_37ceh:	    ;
    ld a,0c3h	    ;	;37ce	'JP word'
s_37d0h:	;<--+
    push af		;37d0 \ Save opcode
    ld hl,l0167h	;37d1		    hl=l0167h
    ld a,(hl)		;37d4
    inc hl		;37d5		    hl=l0167h+1
    or (hl)		;37d6
    pop bc		;37d7 / b=opcode
    ret nz		;37d8	if (l0167h+1).ne.(l0167h) Return
    ex de,hl		;37d9				de=l0167h+1
    ld hl,(PrgSiz)	;37da		    hl=(PrgSiz)
    ex de,hl		;37dd		    hl=l0167h+1 de=(PrgSiz)
    inc de		;37de				de=(PrgSiz)+1
    ld (hl),d		;37df
    dec hl		;37e0
    ld (hl),e		;37e1	(l0167h+1)=(PrgSiz)+1
    ld a,b		;37e2	a=opcode
;*
;*  Put opcode & word=0000 to REL file
;*
s_37e3h:
    call PutOpc		;37e3
    xor a		;37e6	a=0
    call p_byte		;37e7	Put byte in reg A to REL file
    xor a		;37ea	a=0
    jp p_byte		;37eb	--> Put byte in reg A to REL file

;#################
;# END MODULE	 #
;#################

;#################
;# START MODULE	 #
;#################
;
; Table Mnemonic
;
;     Opcode Mnemonic
OpcTab: ;     ;
    db	086h,'ADD',tab,'(HL',0a9h   ;37ee 'ADD (HL)'
    db	0c6h,'ADD',_tab		    ;37f7 'ADD '
    db	0a2h,'AND',tab,0c4h	    ;37fc 'AND D'
    db	0a3h,'AND',tab,0c5h	    ;3802 'AND E'
    db	0a6h,'AND',tab,'(HL',0a9h   ;3808 'AND (HL)'
    db	0e6h,'AND',_tab		    ;3811 'AND '
    db	0cdh,'CALL',_tab	    ;3816 'CALL '
    db	02fh,'CP',0cch		    ;381c 'CPL'
    db	03fh,'CC',0c6h		    ;3820 'CCF'
    db	0b8h,'CP',tab,0c2h	    ;3824 'CP B'
    db	0beh,'CP',tab,'(HL',0a9h    ;3829 'CP (HL)'
    db	0feh,'CP',_tab		    ;3831 'CP '
    db	019h,'ADD',tab,'HL,D',0c5h  ;3835 'ADD HL,DE'
    db	029h,'ADD',tab,'HL,H',0cch  ;383f 'ADD HL,HL'
    db	02bh,'DEC',tab,'H',0cch	    ;3849 'DEC HL'
    db	03dh,'DEC',tab,0c1h	    ;3850 'DEC A'
    db	03ch,'INC',tab,0c1h	    ;3856 'INC A'
    db	023h,'INC',tab,'H',0cch	    ;385c 'INC HL'
    db	0dah,'JP',tab,'C',0ach	    ;3863 'JP C,'
    db	0e2h,'JP',tab,'PO',0ach	    ;3869 'JP PO,'
    db	0eah,'JP',tab,'PE',0ach	    ;3870 'JP PE,'
    db	0fah,'JP',tab,'M',0ach	    ;3877 'JP M,'
    db	0c3h,'JP',_tab		    ;387d 'JP '
    db	0d2h,'JP',tab,'NC',0ach	    ;3881 'JP NC,'
    db	0c2h,'JP',tab,'NZ',0ach	    ;3888 'JP NZ,'
    db	0f2h,'JP',tab,'P',0ach	    ;388f 'JP P,'
    db	0cah,'JP',tab,'Z',0ach	    ;3895 'JP Z,'
    db	03ah,'LD',tab,'A',0ach	    ;389b 'LD A,'	    ***
    db	001h,'LD',tab,'BC',0ach	    ;38a1 'LD BC,'
    db	02ah,'LD',tab,'HL',0ach	    ;38a8 'LD HL,'(xxxx)    ***
    db	011h,'LD',tab,'DE',0ach	    ;38af 'LD DE,'
    db	021h,'LD',tab,'HL',0ach	    ;38b6 'LD HL,'xxxx
    db	0b7h,'OR',tab,0c1h	    ;38bd 'OR A'
    db	0b2h,'OR',tab,0c4h	    ;38c2 'OR D'
    db	0b3h,'OR',tab,0c5h	    ;38c7 'OR E'
    db	0f6h,'OR',_tab		    ;38cc 'OR '
    db	07ah,'LD',tab,'A,',0c4h	    ;38d0 'LD A,D'
    db	07bh,'LD',tab,'A,',0c5h	    ;38d7 'LD A,E'
    db	07dh,'LD',tab,'A,',0cch	    ;38de 'LD A,L'
    db	07eh,'LD',tab,'A,(HL',0a9h  ;38e5 'LD A,(HL)'
    db	07ch,'LD',tab,'A,',0c8h	    ;38ef 'LD A,H'
    db	078h,'LD',tab,'A,',0c2h	    ;38f6 'LD A,B'
    db	047h,'LD',tab,'B,',0c1h	    ;38fd 'LD B,A'
    db	044h,'LD',tab,'B,',0c8h	    ;3904 'LD B,H'
    db	04dh,'LD',tab,'C,',0cch	    ;390b 'LD C,L'
    db	054h,'LD',tab,'D,',0c8h	    ;3912 'LD D,H'
    db	05dh,'LD',tab,'E,',0cch	    ;3919 'LD E,L'
    db	067h,'LD',tab,'H,',0c1h	    ;3920 'LD H,A'
    db	060h,'LD',tab,'H,',0c2h	    ;3927 'LD H,B'
    db	065h,'LD',tab,'H,',0cch	    ;392e 'LD H,L'
    db	066h,'LD',tab,'H,(HL',0a9h  ;3935 'LD H,(HL)'
    db	069h,'LD',tab,'L,',0c3h	    ;393f 'LD L,C'
    db	06fh,'LD',tab,'L,',0c1h	    ;3946 'LD L,A'
    db	06bh,'LD',tab,'L,',0c5h	    ;394d 'LD L,E'
    db	06ch,'LD',tab,'L,',0c8h	    ;3954 'LD L,H'
    db	077h,'LD',tab,'(HL),',0c1h  ;395b 'LD (HL),A'
    db	072h,'LD',tab,'(HL),',0c4h  ;3965 'LD (HL),D'
    db	073h,'LD',tab,'(HL),',0c5h  ;396f 'LD (HL),E'
    db	03eh,'LD',tab,'A',0ach	    ;3979 'LD A,'
    db	02eh,'LD',tab,'L',0ach	    ;397f 'LD L,'
    db	0b4h,'OR',tab,0c8h	    ;38c7 'OR H'
    db	0b5h,'OR',tab,0cch	    ;398a 'OR L'
    db	0b6h,'OR',tab,'(HL',0a9h    ;398f 'OR HL'
    db	0e9h,'JP',tab,'(HL',0a9h    ;3997 'JP (HL)'
    db	0e1h,'POP',tab,'H',0cch	    ;399f 'POP HL'
    db	0e5h,'PUSH',tab,'H',0cch    ;39a6 'PUSH HL'
    db	017h,'RL',0c1h		    ;39ae 'RLA'
    db	01fh,'RR',0c1h		    ;39b2 'RRA'
    db	0c9h,'RE',0d4h		    ;39b6 'RET'
    db	007h,'RLC',0c1h		    ;39ba 'RLCA'
    db	09fh,'SBC',tab,0c1h	    ;39bf 'SBC A'
    db	09ch,'SBC',tab,0c8h	    ;39c5 'SBC H'
    db	09eh,'SBC',_tab		    ;39cb 'SBC '
    db	096h,'SUB',tab,'(HL',0a9h   ;39d0 'SUB (HL)'
    db	0d6h,'SUB',_tab		    ;39d9 'SUB '
    db	022h,'LD',_tab		    ;39de 'LD '(xxxx),hl    ***
    db	032h,'LD',_tab		    ;39e2 'LD '(xxxx)	    ***
    db	095h,'SUB',tab,0cch	    ;39e6 'SUB L'
    db	0ebh,'EX',tab,'DE,H',0cch   ;39ec 'EX DE,HL'
    db	0afh,'XOR',tab,0c1h	    ;39f5 'XOR A'
    db	0aah,'XOR',tab,0c4h	    ;39fb 'XOR D'
    db	0abh,'XOR',tab,0c5h	    ;3a01 'XOR E'
    db	0aeh,'XOR',tab,'(HL',0a9h   ;3a07 'XOR (HL)'
    db	0eeh,'XOR',_tab		    ;3a10 'XOR '

;#################
;# END MODULE	 #
;#################

IFT TRACE
;====================
;
; Print string followed call
;
ilstrg:
    ex	(sp),hl	    ; .. fetch address
    call pst	    ; .. print
    ex	(sp),hl
    ret
;
; Print string in ^HL
;
pst:	  ;<----;
    ld	a,(hl)	;	; Get character
    and NoMSB	;	; .. less MSB
    call putchr ;	; .. print
    cp	(hl)	;	; Test end
    inc hl	;
    ret nz	;	; .. yeap
    jp	pst ;---+
ENDIF
;====================
IFT DBG
ptest2:
    push af
    push bc
    push de
    push hl
    ld hl,ttest5    ;	hl='(l01cch)='
    call PrStrg	    ;	Print string
    ld hl,(l01cch)  ;
    call putadr	    ;	Put addres HL to console
    ld hl,ttest8    ;	hl='(SegmID)='
    call PrStrg	    ;	Print string
    ld a,(SegmID)   ;
    call puthex	    ;	Put hex value A to console
;
    ld hl,ttest3    ;	hl='(SizeID)='
    call PrStrg	    ;	Print string
    ld a,(SizeID)   ;
    call puthex	    ;	Put hex value A to console
;
    ld hl,ttest2    ;	hl='(KindID)='
    call PrStrg	    ;	Print string
    ld a,(KindID)   ;
    call puthex	    ;	Put hex value A to console
;
    ld hl,ttest0    ;	hl='(TypeID)='
    call PrStrg	    ;	Print string
    ld a,(TypeID)   ;
    call puthex	    ;	Put hex value A to console
;
    ld hl,ttest4    ;	hl='(ScopeID)='
    call PrStrg	    ;	Print string
    ld a,(ScopeID)  ;
    call puthex	    ;	Put hex value A to console
;
    ld hl,ttest9    ;	hl='(DataID)='
    call PrStrg	    ;	Print string
    ld hl,(DataID)  ;
    call putadr	    ;	Put addres HL to console
;
    ld hl,ttesta    ;	hl='(EntryID)='
    call PrStrg	    ;	Print string
    ld hl,(EntryID)  ;
    call putadr	    ;	Put addres HL to console
;
    ld hl,ttestb    ;	hl='Name='
    call PrStrg	    ;	Print string
    ld a,''''	    ;
    call putchr	    ;
;
    call PutName    ;
;
    ld a,''''
    call putchr	    ;
;   call p_crlf	    ;	Put cr lf to console
    pop hl
    pop de
    pop bc
    pop af
    ret
;
ttest1: db  cr,lf
ttest0: db	  ' (TypeID)',0bdh
ttest2: db	  ' (KindID)',0bdh
ttest3: db	  ' (SizeID)',0bdh
ttest4: db	  ' (ScopeID)',0bdh
ttest5: db  cr,lf,' (l01cch)',0bdh
ttest6: db	  ' (BC)',0bdh
ttest7: db	  ' (HL)',0bdh
ttest8: db	  ' (SegmID)',0bdh
ttest9: db	  ' (DataID)',0bdh
ttesta: db	  ' (EntryID)',0bdh
ttestb: db	  ' Name',0bdh
;
ptest1:
    push af
    push bc
    push de
    push hl
    ld hl,ttest5    ;	hl='(l01cch)='
    call PrStrg	    ;	Print string
    ld hl,(l01cch)  ;;
    push hl	    ; \ --------------------------------+
    ld a,(hl)	    ;;	Load byte from (l01cch)		;
    and 7fh	    ;;	Clear high bit (a=(SizeID))	;
    push af	    ; \ ------------------------------+ ;
    push af	    ; \ ----------------------------+ ; ;
    call putadr	    ;	Put addres HL to console    ; ; ;
    ld hl,ttest3    ;	hl='(SizeID)='		    ; ; ;
    call PrStrg	    ;	Print string		    ; ; ;
    pop af	    ; / ----------------------------+ ; ;
    call puthex	    ;	Put hex value A to console    ; ;
    ld hl,ttest6    ;	hl='(BC)='		      ; ;
    call PrStrg	    ;	Print string		      ; ;
    pop af	    ; / <-----------------------------+ ;
    cpl		    ;;					;
    sub 5	    ;;					;
    ld c,a	    ;;	c=(SizeID)-5			;
    ld b,0ffh	    ;;	bc = -(SizeID)+5		;
    push bc	    ; \ --------------------------+	;
    push bc	    ; \ -+			  ;	;
    pop hl	    ; / -+  hl=bc		  ;	;
    call putadr	    ;	Put addres HL to console  ;	;
    ld hl,ttest7    ;	hl='(HL)='		  ;	;
    call PrStrg	    ;	Print string		  ;	;
    pop bc	    ; / <-------------------------+	;
    pop hl	    ; / <-------------------------------+
    add hl,bc	    ;;
    call putadr	    ;	Put addres HL to console
    pop hl
    pop de
    pop bc
    pop af
    ret
ENDIF
;====================
;#################
;# START MODULE	 #
;#################
;?			     !! No execution path to here !!
    call puttab		;3a15	Put tab to console
;*
;*  Put addres HL to console
;*
putadr:
    push bc		;3a18	Save the contents of the registers
    push hl		;3a19
    ld a,(HexFlg)	;3a1a
    or a		;3a1d	Test /O
    jp nz,putoct	;3a1e	if (HexFlg).ne.0 --> Put Octal to console
    ld a,h		;3a21
    call puthex		;3a22	Put hex value A to console
    ld a,l		;3a25
    call puthex		;3a26	Put hex value A to console
    pop hl		;3a29	Restore original register contents
    pop bc		;3a2a
    ret			;3a2b
;*
;*  Put hex value A to console
;*
puthex:
    push bc		;3a2c	Save the contents of the register
    ld b,a		;3a2d	Save val
    ld a,(HexFlg)	;3a2e
    or a		;3a31	Test /O
    jp nz,l3a68h  ;---; ;3a32	if (HexFlg).ne.0 --> ...
    ld a,b	      ; ;3a35	Restore val
    rrca	      ; ;3a36	Extract hi bits
    rrca	      ; ;3a37
    rrca	      ; ;3a38
    rrca	      ; ;3a39
    call putdig	      ; ;3a3a	Put digit to console
    ld a,b	      ; ;3a3d	Then get low bits
    call putdig	      ; ;3a3e	Put digit to console
    pop bc	      ; ;3a41	Restore original register content
    ret		      ; ;3a42
		      ;
;*  Put digit to console
		      ;
putdig:		      ;
    and 0fh	      ; ;3a43	Use only lower 4 bits (00001111b)
    add a,'0'	      ; ;3a45	Convert binary decimal to ASCII
    cp '9'+1	      ; ;3a47	Test hex (3ah)
    jp c,putchr	      ; ;3a49	Nope --> Put character to console
    add a,'A'-'0'-10  ; ;3a4c	Fix for A..F (07h)
    jp putchr	      ; ;3a4e	--> Put character to console
		      ;
;*  Put Octal to console
		      ;
putoct:		      ;
    ld c,6	      ; ;3a51	c=6
    xor a	      ; ;3a53	a=0
    jp l3a5ch ;-;     ; ;3a54	--> ...
		;     ;
l3a57h:	   ;<---)---; ;
      xor a	;   ; ; ;3a57	af
      add hl,hl ;   ; ; ;3a58	Get MSB
      adc a,a	;   ; ; ;3a59	8f
l3a5ah:	    ;<--)-; ; ;
      add hl,hl ; ; ; ; ;3a5a	Shift word
      adc a,a	; ; ; ; ;3a5b	Sample bits
l3a5ch:	    ;<--+ ; ; ;
      add hl,hl	  ; ; ; ;3a5c	29
      adc a,a	  ; ; ; ;3a5d	8f
      call putdig ; ; ; ;3a5e	Put digit to console
      dec c	  ; ; ; ;3a61	c=c-1
    jp nz,l3a57h;-)-+ ; ;3a62	if c.ne.0 --> ...
    pop hl	  ;   ; ;3a65	e1
    pop bc	  ;   ; ;3a66	c1
    ret		  ;   ; ;3a67
		  ;   ;
l3a68h:	    ;<----)---+
    push hl	  ;	;3a68	e5
    xor a	  ;	;3a69	a=0
    ld h,b	  ;	;3a6a	60
    ld c,3	  ;	;3a6b	c=3
    jp l3a5ah ;---+	;3a6d	--> ...
;*
;*  Put addres DATA' to console
;*
s_3a70h:
    push hl		;3a70
    ld hl,(PrgSiz)	;3a71	Load Program size
    db 0feh		;3a74	cp 0e5h (in the original)   trap_ms ***
s_3a75h:
    push hl		;3a75
    call putadr		;3a76	Put addres HL to console
    ld a,''''		;3a79	a="'"
l3a7bh:	      ;<----;
    call putchr	    ;	;3a7b	Put character to console
    pop hl	    ;	;3a7e
    ret		    ;	;3a7f
		    ;
;*  Put addres DATA" to console
		    ;
;?		    ;	     !! No execution path to here !!
    push hl	    ;	;3a80
    ld hl,(DatSiz)  ;	;3a81	Load Data size
    db 0feh	    ;	;3a84	cp 0e5h (in the original)   trap_ms ***
s_3a85h:	    ;
    push hl	    ;	;3a85
    call putadr	    ;	;3a86	Put addres to console
    ld a,'"'	    ;	;3a89	a="
    jp l3a7bh	;---+	;3a8b	--> Put character to console
;*
;*  Print number in HL as decimal number
;*    ENTRY Reg HL
;*
PrNumb:
    push hl		    ;3a8e   Save the contents of the registers
    push bc		    ;3a8f
    push de		    ;3a90
    ld de,l3ac9h	    ;3a91   Pointer to Decimal division table
    ld a,5		    ;3a94   Set digit count
    or a		    ;3a96   Reset Carry
l3a97h:	     ;<-----------;
    push af		  ; ;3a97 \ Save Carry status
l3a98h:	       ;<-------; ;
    ex de,hl		; ; ;3a98	    hl=adrtbl de=num
    ld c,(hl)		; ; ;3a99
    inc hl		; ; ;3a9a
    ld b,(hl)		; ; ;3a9b   bc=(hl)
    inc hl		; ; ;3a9c   hl=hl+2
    ex de,hl		; ; ;3a9d	    hl=num de=adrtbl+2
    xor a		; ; ;3a9e   a=0
l3a9fh:	      ;<----;	; ;
      push hl	    ;	; ; ;3a9f \ e5
      add hl,bc	    ;	; ; ;3aa0   09
      jp nc,l3aaah;-)-; ; ; ;3aa1   if a >= --> ...
      inc a	    ; ; ; ; ;3aa4   a=a+1
      inc sp	    ; ; ; ; ;3aa5   33
      inc sp	    ; ; ; ; ;3aa6   33
    jp l3a9fh ;-----+ ; ; ; ;3aa7   --> ...
		      ; ; ;
l3aaah:		;<----+ ; ;
    pop hl		; ; ;3aaa / e1
    ld c,a		; ; ;3aab   Save a
    pop af		; ; ;3aac / Restore Carry status
    dec a		; ; ;3aad   a=a-1
    push af		; ; ;3aae \ Save Carry status
    jp c,l3abdh ;---;	; ; ;3aaf
    jp z,l3abdh ;---;	; ; ;3ab2   if a.le.0 --> ...
    ld a,c	    ;	; ; ;3ab5   Restore a
    or a	    ;	; ; ;3ab6
    jp z,l3a98h	  ;-)---+ ; ;3ab7   if a.eq.0 --> ...
    pop af	    ;	  ; ;3aba / Restore Carry status
    scf		    ;	  ; ;3abb   Set carry
    push af	    ;	  ; ;3abc \ Save Carry status
l3abdh:		;<--+	  ;
    ld a,c		  ; ;3abd   Restore a
    call putdig		  ; ;3abe   Put digit to console
    pop af		  ; ;3ac1 / Restore Carry status
    jp nz,l3a97h  ;-------+ ;3ac2   if a.ne.0 --> ...
    pop de		    ;3ac5   Restore original register contents
    pop bc		    ;3ac6
    pop hl		    ;3ac7
    ret			    ;3ac8
;*
;*  Decimal division table
;*
l3ac9h:
    dw	-10000		;3ac9
    dw	-1000		;3acb
    dw	-100		;3acd
    dw	-10		;3acf
    dw	-1		;3ad1
;*
;*  Print HL hh (dd)
;*
pHexDec:
    call putadr		;3ad3	Put addres HL to console
    ld a,' '		;3ad6
    call putchr		;3ad8	Put ' ' to console
    ld a,'('		;3adb
    call putchr		;3add	Put '(' to console
    call PrNumb		;3ae0	Print number in HL as decimal number
    ld a,')'		;3ae3
    jp putchr		;3ae5	--> Put ')' to console
;*
;*
;*
s_3ae8h:
    call puttab		;3ae8	Put tab to console
s_3aebh:
    ld a,(l01d6h)	;3aeb
    cp 2ah		;3aee	'*'
    jp nz,l3b24h  ;--;	;3af0	if (l01d6h).ne.02ah --> ...
    ld hl,(l01cch)   ;	;3af3
    push hl	     ;	;3af6 \ Save (l01cch)
    ld hl,(DataID)   ;	;3af7
    push hl	     ;	;3afa \ Save (DataID) ----------------------------------------------------;
    ld hl,(l01d4h)   ;	;3afb	hl=(l01d4h)							  ;
    call ExtAttr     ;	;3afe	Extract Attributes from the symbol table			  ;
    call PutName     ;	;3b01	Put string to console length (SizeID) starting at address l01d6h  ;
    ld hl,(DataID)   ;	;3b04	hl=(DataID)							  ;
    ex de,hl	     ;	;3b07		    de=(DataID)						  ;
    pop hl	     ;	;3b08 / hl=(DataID)   <---------------------------------------------------+
    call subHL_DE    ;	;3b09	hl=hl-de
    ld a,h	     ;	;3b0c	7c
    or a	     ;	;3b0d	b7
    ld a,'+'	     ;	;3b0e
    jp p,l3b15h ;--; ;	;3b10	if positive --> ...
    ld a,'-'	   ; ;	;3b13
l3b15h:		;<-+ ;
    push af	     ;	;3b15 \ Save flags
    call putchr	     ;	;3b16	Put character to console
    pop af	     ;	;3b19 / Restore flags
    call m,Neg_HL    ;	;3b1a	if a < 0 Negate HL
    call putadr	     ;	;3b1d	Put the contents HL to console
    pop hl	     ;	;3b20 / hl=(l01cch)
    jp ExtAttr	     ;	;3b21	--> Extract Attributes from the symbol table
		     ;
l3b24h:		  ;<-+
    ld a,(KindID)	;3b24
    cp 6		;3b27
    push af		;3b29 \
    ld a,'/'		;3b2a
    call z,putchr	;3b2c	if (KindID).eq.6 (Common) Put '/' to console
    pop af		;3b2f /
    push af		;3b30 \ Save (KindID)
    dec a		;3b31
    jp nz,l3b67h  ;---; ;3b32	if (KindID).eq.1 (Constant)--> ...
    ld a,'['	      ; ;3b35
    call putchr	      ; ;3b37	Put '[' to console
    ld a,(SizeID)     ; ;3b3a
    ld c,a	      ; ;3b3d	c=(SizeID)
    cpl		      ; ;3b3e
    ld e,a	      ; ;3b3f
    ld d,0ffh	      ; ;3b40
    ld hl,l01d8h      ; ;3b42
    add hl,de	      ; ;3b45	hl=l01d8h-(SizeID)
    jp l3b57h	;---+ ; ;3b46	--> ...
		    ; ;
l3b49h:	       ;<-+ ; ;
      push bc	  ; ; ; ;3b49 \
      push hl	  ; ; ; ;3b4a \
      ld a,(hl)	  ; ; ; ;3b4b	a=(hl)
      call puthex ; ; ; ;3b4c	Put hex value A to console
      ld a,' '	  ; ; ; ;3b4f
      call putchr ; ; ; ;3b51	Put ' ' to console
      pop hl	  ; ; ; ;3b54 /
      inc hl	  ; ; ; ;3b55	hl=hl+1
      pop bc	  ; ; ; ;3b56 /
l3b57h:	      ;<--)-+ ;
      dec c	  ;   ; ;3b57	c=c-1
    jp nz,l3b49h;-+   ; ;3b58	if c.ne.0 next step
    ld a,(hl)	      ; ;3b5b	a=(hl)
    call puthex	      ; ;3b5c	Put hex value A to console
    ld a,']'	      ; ;3b5f
    call putchr	      ; ;3b61	Put ']' to console
    jp l3b8eh	 ;--; ; ;3b64	--> ...
		    ; ;
l3b67h:		;<--)-+
    ld hl,l01d5h    ;	;3b67
    ld a,(hl)	    ;	;3b6a
    cp ':'	    ;	;3b6b
    jp nz,l3b8bh;-; ;	;3b6d	if (l01d5h).ne.':' --> ...
    inc hl	  ; ;	;3b70	hl=hl+1
    ld a,(hl)	  ; ;	;3b71	a=(hl)
    call putchr	  ; ;	;3b72	Put character to console
    dec hl	  ; ;	;3b75	hl=hl-1
    ld a,(hl)	  ; ;	;3b76	a=(hl)
    call putchr	  ; ;	;3b77	Put character to console
    ld a,(SizeID) ; ;	;3b7a
    sub 2	  ; ;	;3b7d
    ld b,a	  ; ;	;3b7f	b=(SizeID)-2
l3b80h:		  ; ;
      dec hl	  ; ;	;3b80	hl=hl-1
      ld a,(hl)	  ; ;	;3b81	a=(hl)
      call puthex ; ;	;3b82	Put hex value A to console
      dec b	  ; ;	;3b85	b=b-1
    jp nz,l3b80h  ; ;	;3b86	if b.ne.0 next step
    pop af	  ; ;	;3b89 / Restore balance stack (KindID)
    ret		  ; ;	;3b8a
		  ; ;
l3b8bh:	      ;<--+ ;
    call PutName    ;	;3b8b	Put string to console length (SizeID) starting at address l01d6h
l3b8eh:		;<--+
    pop af		;3b8e / Restore (KindID)
    push af		;3b8f \
    ld a,'/'		;3b90
    call z,putchr	;3b92	if (KindID).eq.0 Put character '/' to console
    pop af		;3b95 /
    cp 2		;3b96
    ld a,'L'		;3b98
    call z,putchr	;3b9a	if (KindID).eq.2 (Label) Put character 'L' to console
    ret			;3b9d
;*
;*  Put string to console length (SizeID) starting at address l01d6h
;*
PutName:
    ld a,(SizeID)	;3b9e +
    ld c,a		;3ba1 + c=(SizeID)
    ld hl,l01d6h	;3ba2 + hl=l01d6h initial address the string
l3ba5h:	       ;<---;
      ld a,(hl)	    ;	;3ba5 + a=(hl)
      call putchr   ;	;3ba6 + Put character to console
      dec hl	    ;	;3ba9 + hl=hl-1
      dec c	    ;	;3baa + c=c-1
    jp nz,l3ba5h ;--+	;3bab + if c.ne.0 next step
    ret			;3bae +
;*
;*  Put TAB and CRLF
;*
TabCRLF:
l3bafh:		 ;<---;
    ld a,(Column)     ; ;3baf
    cp 72	      ; ;3bb2
    jp nc,p_crlf      ; ;3bb4	if (Column) >= 72 --> Put cr lf to console
    or a	      ; ;3bb7
    ret z	      ; ;3bb8	if (Column).eq.0 Return
    cp 24	      ; ;3bb9
    ret z	      ; ;3bbb	if (Column).eq.24  Return
    jp nc,l3bc5h ;--; ; ;3bbc	if (Column) >= 24 --> ...
l3bbfh:	       ;<-+ ; ;
    call puttab	  ; ; ; ;3bbf	Put tab to console
    jp l3bafh  ;--)-)-+ ;3bc2	--> ...
l3bc5h:	     ;<---)-+
    cp 48	  ;	;3bc5
    ret z	  ;	;3bc7	if (Column).eq.48  Return
    jp l3bbfh ;---+	;3bc8	--> ...
;*
;*  Completion compile the module
;*
l3bcbh:
    ld bc,0ah		;3bcb	REL type - define DATA SIZE (1010b)
    ld hl,(DatSiz)	;3bce	Load data size
    ex de,hl		;3bd1
    call RELITEM	;3bd2	Give ABS data size
    ld hl,(l01a4h)	;3bd5
    ex de,hl		;3bd8
    ld hl,l66c6h	;3bd9
    call cmpHL_DE	;3bdc	Compare HL with DE
    jp z,l3be6h ;---;	;3bdf	if l66c6h.eq.(l01a4h) --> skip error message
    call err_msg    ;	;3be2	Warning (22)
    db 22	    ;	;3be5	Missing Do Termination
l3be6h:		;<--+
    ld a,(BlkDat)	;3be6	Load Flag Block data
    or a		;3be9
    jp z,l3bfch ;---;	;3bea	if (BlkDat).eq.0 (not Block data) --> ...
    ld hl,(PrgSiz)  ;	;3bed	Load Program size
    ld a,h	    ;	;3bf0
    or l	    ;	;3bf1
    jp z,Summary    ;	;3bf2	if (PrgSiz).eq.0 --> Outputs the summary information about Program size, Data area length
    call err_msg    ;	;3bf5	Warning (23)
    db	23	    ;	;3bf8	Code Output in BLOCK DATA
    jp Summary	    ;	;3bf9	--> Outputs the summary information about Program size, Data area length
		    ;
l3bfch:		;<--+
    ld hl,(l0263h)	    ;3bfc
    ld a,h		    ;3bff
    or l		    ;3c00
    jp nz,l3c0bh ;---;	    ;3c01   if (l0263h).ne.0 --> ...
    ld a,(l0299h)    ;	    ;3c04
    or a	     ;	    ;3c07
    jp nz,l3c1eh ;---)-;    ;3c08   if (l0299h).ne.0 --> ...
l3c0bh:	       ;<----+ ;
    ld a,(MainFlg)     ;    ;3c0b
    or a	       ;    ;3c0e
    jp z,l3c18h	 ;-;   ;    ;3c0f   if (MainFlg).eq.0 (Main program) --> ...
		   ;   ;	    .. subprogram
    call s_35d7h   ;   ;    ;3c12
    jp l3c1eh  ;---)-; ;    ;3c15   --> ...
		   ; ; ;
l3c18h:	     ;<----+ ; ;
    ld bc,'EX'	     ; ;    ;3c18   $EX - routine returns control to the OS
    call CrBuilt     ; ;    ;3c1b   Creating built-in routine
l3c1eh:		;<---+-+
    xor a		    ;3c1e
    ld (l028fh),a	    ;3c1f   (l028fh)=0
    call s_59eeh	    ;3c22   Extract Attributes from the symbol table, entry (l031eh)
l3c25h:		;<-----+
    jp c,Summary       ;    ;3c25   if carry set (Found end of Symbol table) --> Outputs summary about Program size, Data area length
    ld bc,l3c75h       ;    ;3c28   Point to l3c75h
    push bc	       ;    ;3c2b \ Save the return
    dec a	       ;    ;3c2c
    jp nz,l3c7bh  ;----)-;  ;3c2d   if a.ne.1 --> ...
    ld a,(TypeID)      ; ;  ;3c30
    cp 7	       ; ;  ;3c33
    ret z	  ;--; ; ;  ;3c35   if (TypeID).eq.7 Return to l3c75h
    ld hl,(DataID)   ; ; ;  ;3c36
    ld a,h	     ; ; ;  ;3c39
    or l	     ; ; ;  ;3c3a
    ret z	  ;--; ; ;  ;3c3b   if (DataID).eq.0 --> Return to l3c75h
    ex de,hl	     ; ; ;  ;3c3c
    ld bc,010ch	     ; ; ;  ;3c3d   Address modes CSEG,rel type - EXTERNAL-OFFSET (12)
    ld a,(SegmID)    ; ; ;  ;3c40   Load Flag Address mode
    or a	     ; ; ;  ;3c43
    jp z,l3c49h ;--; ; ; ;  ;3c44   if (SegmID).eq.0 (CSEG) --> ...
    ld b,2	   ; ; ; ;  ;3c47   Address modes DSEG, rel type - EXTERNAL-OFFSET (12)
l3c49h:		;<-+ ; ; ;
    call RELITEM     ; ; ;  ;3c49
    ld a,(NoCode)    ; ; ;  ;3c4c
    or a	     ; ; ;  ;3c4f   Test /N
    jp nz,l3c5fh ;-; ; ; ;  ;3c50   if (NoCode).ne.0  --> skip output
    call s_4f46h   ; ; ; ;  ;3c53   if (Column).ne.0 Put cr lf to console
    call s_1465h   ; ; ; ;  ;3c56   Print *****
    call s_3a70h   ; ; ; ;  ;3c59   Put addres DATA' to console
    call puttab	   ; ; ; ;  ;3c5c   Put tab to console
l3c5fh:	       ;<--+ ; ; ;
    ld hl,(l01cch)   ; ; ;  ;3c5f   2a cc 01
    ld a,(SizeID)    ; ; ;  ;3c62   3a b6 01
    call w_NAMe	     ; ; ;  ;3c65   Put Name from Symbol table to REL file
;*		     ; ; ;
;*  (SegmID)=0 (DataID)=0 PutAttr
;*		     ; ; ;
s_3c68h:	     ; ; ;
    ld a,0	     ; ; ;  ;3c68   a=0 (CSEG)
    ld (SegmID),a    ; ; ;  ;3c6a   (SegmID)=0 Save Flag Address mode
    ld h,a	     ; ; ;  ;3c6d
    ld l,a	     ; ; ;  ;3c6e   hl=0
    ld (DataID),hl   ; ; ;  ;3c6f   (DataID)=0
    jp PutAttr	     ; ; ;  ;3c72   --> Put Attributes in Symbol table
		     ; ; ;
l3c75h:		  ;<-+ ; ;	    Calculate address next symbol in the Symbols table;
    call s_59f4h       ; ;  ;3c75   if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp l3c25h	;------+ ;  ;3c78   --> ...
			 ;
l3c7bh:	    ;<-----------+
    dec a		    ;3c7b   3d
    jp nz,l3ca2h ;----;	    ;3c7c   c2 a2 3c
    inc a	      ;	    ;3c7f   3c
    ld (l028fh),a     ;	    ;3c80   (l028fh)=
    ld a,(ScopeID)    ;	    ;3c83
    or a	      ;	    ;3c86
    ret nz	      ;	    ;3c87   if (ScopeID).eq.0 Return to l3c75h
    call s_1b32h      ;	    ;3c88   Clear buffer ^l02b4h length 20
    ld hl,l02b4h      ;	    ;3c8b   Destination address
    ld de,l01d6h      ;	    ;3c8e   Source address
    ld a,(SizeID)     ;	    ;3c91
    ld b,a	      ;	    ;3c94   b=(SizeID)
l3c95h:	       ;<---; ;
      ld a,(de)	    ; ;	    ;3c95
      ld (hl),a	    ; ;	    ;3c96   (hl)=(de)
      dec de	    ; ;	    ;3c97   de=de-1
      inc hl	    ; ;	    ;3c98   hl=hl+1
      dec b	    ; ;	    ;3c99   b=b-1
    jp nz,l3c95h ;--+ ;	    ;3c9a   if b.ne.0 --> ...
    call err_msg      ;	    ;3c9d   Warning (24)
    db 018h	      ;	    ;3ca0   Undefined Labels Have Occurred
    ret		      ;	    ;3ca1   Return to l3c75h
		      ;
l3ca2h:		;<----+
    cp 3		    ;3ca2
    ret nz		    ;3ca4   if ne.3 Return to l3c75h
    ld a,(ScopeID)	     ;3ca5
    cp 2		    ;3ca8
    ret nc		    ;3caa   if (ScopeID) >= 2 Return to l3c75h
    ld bc,0106h		    ;3cab   Address modes CSEG, rel type - CHAIN EXTERNAL
    ld hl,(DataID)	    ;3cae
    ld a,h		    ;3cb1
    or l		    ;3cb2
    ret z		    ;3cb3   if (DataID).eq.0 Return to l3c75h
    ld a,(SegmID)	    ;3cb4   Load Flag Address mode
    or a		    ;3cb7
    jp z,l3cbdh ;---;	    ;3cb8   if (SegmID).eq.0 (CSEG) --> ...
    ld b,2	    ;	    ;3cbb   Address modes DSEG, rel type - CHAIN EXTERNAL
l3cbdh:		;<--+
    ex de,hl		    ;3cbd   de=(DataID)
    jp RELITEM		    ;3cbe
;*
;*  Outputs the summary information about Program size, Data area length
;*
Summary:
    call s_4f46h	    ;3cc1   if (Column).ne.0 Put cr lf to console
    ld hl,l3e3fh	    ;3cc4   hl="Program Unit Length"
    call PrStrg		    ;3cc7   Print string
    ld hl,(PrgSiz)	    ;3cca   Load Program size
    call pHexDec	    ;3ccd   Print HL hh (dd)
;
    ld hl,l3e55h	    ;3cd0   hl="Bytes, Data Area Length"
    call PrStrg		    ;3cd3   Print string
    ld hl,(DatSiz)	    ;3cd6   Load Data size
    call pHexDec	    ;3cd9   Print HL hh (dd)
;*
;*  Displays a list Subroutines
;*
    ld hl,l3e70h	    ;3cdc   hl="Bytes,Subroutines Referensed"
    call PrStrg		    ;3cdf   Print string
    call s_59eeh	    ;3ce2   Extract Attributes from the symbol table, entry (l031eh)
    jp c,l3d0ch	 ;------;   ;3ce5   if carry set (Found end of Symbol table) --> Displays list Variables
l3ce8h:	      ;<------; ;
    cp 5	      ; ;   ;3ce8
    jp nz,l3d06h ;--; ; ;   ;3cea   if (KindID).ne.5 (Routine) --> ...
    ld a,(ScopeID)  ; ; ;   ;3ced
    cp 2	    ; ; ;   ;3cf0
    jp z,l3d06h	 ;--; ; ;   ;3cf2   if (ScopeID).eq.2 --> ...
    ld hl,(DataID)  ; ; ;   ;3cf5
    ld a,h	    ; ; ;   ;3cf8
    or l	    ; ; ;   ;3cf9
    jp z,l3d06h	 ;--; ; ;   ;3cfa   if (DataID).eq.0 --> ...
    call TabCRLF    ; ; ;   ;3cfd   Put TAB and CRLF
    call s_3aebh    ; ; ;   ;3d00   cd eb 3a
    call s_3c68h    ; ; ;   ;3d03   (SegmID)=0 (DataID)=0 PutAttr
l3d06h:		 ;<-+ ; ;	    Calculate address next symbol in the Symbols table;
    call s_59f4h      ; ;   ;3d06   if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp nc,l3ce8h   ;--+ ;   ;3d09   if (l0206h) < (l01cch) --> ...
			;
l3d0ch:	       ;<-------+
;*
;*  Displays list Variables
;*
    call s_4f46h	    ;3d0c   if (Column).ne.0 Put cr lf to console
    ld hl,l3e95h	    ;3d0f   hl="Variables:"
    call PrStrg		    ;3d12   Print string
    xor a		    ;3d15   a=0
    ld (l0289h),a	    ;3d16   (l0289h)=0
    call s_59eeh	    ;3d19   Extract Attributes from the symbol table, entry (l031eh)
l3d1ch:
    jp c,l3d43h	 ;------;   ;3d1c   if carry set (Found end of Symbol table) --> Displays COMMON Length
    cp 3		;   ;3d1f
    jp z,l3d29h	 ;-;	;   ;3d21   if (KindID).eq.3 (Variable)--> ...
    cp 4	   ;	;   ;3d24
    jp nz,l3d3dh ;-)--; ;   ;3d26   if (KindID).ne.4 (Array)--> ...
l3d29h:	       ;<--+  ; ;
    ld a,(l01d6h)     ; ;   ;3d29
    cp 2ah	      ; ;   ;3d2c   '*'
    jp z,l3d3dh	 ;----; ;   ;3d2e   if (l01d6h).eq.02ah --> ...
    call TabCRLF      ; ;   ;3d31   Put TAB and CRLF
    call s_3aebh      ; ;   ;3d34   cd eb 3a
    call puttab	      ; ;   ;3d37   Put tab to console
    call s_461bh      ; ;   ;3d3a   cd 1b 46
l3d3dh:		 ;<---+ ;	    Calculate address next symbol in the Symbols table;
    call s_59f4h	;   ;3d3d   if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp nc,l3d1ch	;   ;3d40   if (l0206h) < (l01cch) --> ...
			;
l3d43h:		 ;<-----+
;*
;*  Displays COMMON Length
;*
    call s_4f46h	    ;3d43   if (Column).ne.0 Put cr lf to console
    ld a,(l0289h)	    ;3d46
    or a		    ;3d49
    jp z,l3d73h	 ;------;   ;3d4a   if (l0289h).eq.0 skip output
    ld hl,l3ea5h	;   ;3d4d   hl="COMMON Length"
    call PrStrg		;   ;3d50   Print string
    call s_59eeh	;   ;3d53   Extract Attributes from the symbol table, entry (l031eh)
l3d56h:	     ;<-------; ;
    jp c,l3d73h	 ;----)-;   ;3d56   if carry set (Found end of Symbol table) --> Displays list Labels
    cp 6	      ; ;   ;3d59
    jp nz,l3d6dh ;--; ; ;   ;3d5b   if (KindID).ne.6 (Common) --> ...
    call TabCRLF    ; ; ;   ;3d5e   Put TAB and CRLF
    call s_3aebh    ; ; ;   ;3d61   cd eb 3a
    ld hl,(DataID)  ; ; ;   ;3d64   Load value COMMON Length
    call pHexDec    ; ; ;   ;3d67   Print HL hh (dd)
    call p_crlf	    ; ; ;   ;3d6a   Put cr lf to console
l3d6dh:		;<--+ ; ;	    Calculate address next symbol in the Symbols table;
    call s_59f4h      ; ;   ;3d6d   if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp nc,l3d56h ;----+ ;   ;3d70   if (l0206h) < (l01cch) --> ...
			;
l3d73h:	       ;<-------+
;*
;*  Displays list Labels
;*
    call s_4f46h	    ;3d73   if (Column).ne.0 Put cr lf to console
    ld a,(l028fh)	    ;3d76
    or a		    ;3d79
    jp z,l3dc0h ;-------;   ;3d7a   if (l028fh).eq.0 skip output
    ld hl,l3eb8h	;   ;3d7d   hl="Labels"
    call PrStrg		;   ;3d80   Print string
    call s_59eeh	;   ;3d83   Extract Attributes from the Symbol table, entry (l031eh)
l3d86h:	      ;<------+ ;
    jp c,l3dc0h ;-----)-;   ;3d86   if carry set (Found end of Symbol table) --> Print number of Warning(s) detected
    cp 2	      ; ;   ;3d89
    jp nz,l3dbah ;--; ; ;   ;3d8b   if (KindID).ne.2 (Label) --> ...
    call TabCRLF    ; ; ;   ;3d8e   Put TAB and CRLF
    call s_3aebh    ; ; ;   ;3d91   cd eb 3a
    ld a,(ScopeID)  ; ; ;   ;3d94
    or a	    ; ; ;   ;3d97
    jp z,l3dbah	 ;--; ; ;   ;3d98   if (ScopeID).eq.0 --> ...
    call puttab	    ; ; ;   ;3d9b   Put tab to console
    ld hl,(DataID)  ; ; ;   ;3d9e   2a 5d 01
    ld a,(RomFlg)   ; ; ;   ;3da1
    or a	    ; ; ;   ;3da4   Test /M
    jp z,l3daeh ;-; ; ; ;   ;3da5   if (RomFlg).eq.0 --> skip output
    call s_3a75h  ; ; ; ;   ;3da8   Put addres DATA' to console	     trap_ms (03a75h) ***
    jp l3dbah	;-)-; ; ;   ;3dab   --> ...
		  ; ; ; ;
l3daeh:	       ;<-+ ; ; ;
    ld a,(TypeID)   ; ; ;   ;3dae
    or a	    ; ; ;   ;3db1
    push af	    ; ; ;   ;3db2
    call z,s_3a75h  ; ; ;   ;3db3   if (TypeID).eq.0 (INTEGER?) Put addres DATA' to console trap_ms (03a75h) ***
    pop af	    ; ; ;   ;3db6
    call nz,s_3a85h ; ; ;   ;3db7   if (TypeID).ne.0 (INTEGER?) Put addres DATA" to console trap_ms (03a85h) ***
l3dbah:	       ;<---+ ; ;	    Calculate address next symbol in the Symbols table;
    call s_59f4h      ; ;   ;3dba   if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp nc,l3d86h ;----+ ;   ;3dbd   if (l0206h) < (l01cch) --> ...
			;
l3dc0h:		  ;<----+
;*
;*  Print number of Warning(s) detected
;*
    ld a,1		    ;3dc0
    ld (conflg),a	    ;3dc2   (conflg)=1 Force console
    ld hl,(WrnCnt)	    ;3dc5   hl=Warning counter
    ld a,h		    ;3dc8
    or l		    ;3dc9
    jp z,l3ddeh ;--;	    ;3dca   if (WrnCnt).eq.0 --> skip displaying message about the number of warnings
    call p_crlf	   ;	    ;3dcd   Put cr lf to console
    ld a,'%'	   ;	    ;3dd0
    call putchr	   ;	    ;3dd2   Put '%' to console
    call PrNumb	   ;	    ;3dd5   Print number in HL as decimal number
    ld hl,l3ec5h   ;	    ;3dd8   hl=" Warning(s) Issued"
    call PrStrg	   ;	    ;3ddb   Print string
		   ;
l3ddeh:		;<-+
;*
;*  Print a number of Fatal Error(s) detected
;*
    ld hl,(ErrCnt)	    ;3dde   hl=Error counter
    ld a,h		    ;3de1
    or l		    ;3de2
    jp z,l3df7h ;--;	    ;3de3   if (ErrCnt).eq.0 --> Skip displaying message about the number of errors
    call p_crlf	   ;	    ;3de6   Put cr lf to console
    ld a,'?'	   ;	    ;3de9
    call putchr	   ;	    ;3deb   Put '?' to console
    call PrNumb	   ;	    ;3dee   Print number in HL as decimal number
    ld hl,l3ed9h   ;	    ;3df1   hl="Fatal Error(s) Detected"
    call PrStrg	   ;	    ;3df4   Print string
l3df7h:	     ;<----+
    xor a		    ;3df7   a=0
    ld (conflg),a	    ;3df8   (conflg)=0 Clear console
;
    ld hl,(PrgSiz)	    ;3dfb   Load Program size
    ld bc,010dh		    ;3dfe   Address modes CSEG, rel type - define PROGRAM SIZE
    ex de,hl		    ;3e01
    call RELITEM	    ;3e02   for CSEG program size ???
;
    ld a,(BlkDat)	    ;3e05 Load Flag Block data
    or a		    ;3e08
    jp nz,l3e22h  ;--;	    ;3e09   if (BlkDat).ne.0 (Block data) --> ...
    ld a,(MainFlg)   ;	    ;3e0c
    or a	     ;	    ;3e0f
    jp z,l3e25h	  ;--)--;   ;3e10 if (MainFlg).eq.0 (Main program) --> ...    trap_ms (03e25h) ***
		     ;	;	  ..Subprogram
    ld hl,(l0267h)   ;	;   ;3e13
    call ExtAttr     ;	;   ;3e16   Extract Attributes from the symbol table
    ld bc,0107h	     ;	;   ;3e19   Address modes CSEG, Rel type - define ENTRY POINT
    ld de,00000h     ;	;   ;3e1c   de=0
    call RELITEM     ;	;   ;3e1f   Give code entry point
l3e22h:	     ;<------+	;
    ld b,0		;   ;3e22   b=0 Address_modes ASEG
    db 11h     ;---;	;   ;3e24   ld de,00106h (in the original)  trap_ms ***
l3e25h:	     ;<----)----+
    ld b,1	   ;	    ;3e25   Address modes CSEG
    ld c,0eh   ;<--+	    ;3e27   Rel type - END PROGRAM (1110b)
    ld de,00000h	    ;3e29   de=0
    call RELITEM	    ;3e2c   Give code end Program
;*
;*  Forces to byte boundary
;*
l3e2fh:		  ;<---;
      ld hl,(l0159h)   ;  ;3e2f hl=REL byte
      ld a,h	       ;  ;3e32
      cp -8	       ;  ;3e33
      jp z,l0704h      ;  ;3e35 if a.eq.-8 --> Compile next module
      xor a	       ;  ;3e38 a=0
      call w_bit       ;  ;3e39 Put zero bit
    jp l3e2fh	  ;----+  ;3e3c
;
l3e3fh:
    db cr,lf
    dc 'Program Unit Length='		    ;3e3f
l3e55h:
    db cr,lf,' Bytes',cr,lf		    ;3e55
    dc 'Data Area Length='		    ;3e5f
l3e70h:
    db ' Bytes',cr,lf,cr,lf		    ;3e70
    db 'Subroutines Referenced:'	    ;3e7a
    db cr,lf,cr,_lf			    ;3e91
l3e95h:
    db cr,lf,'Variables:'		    ;3e95
    db cr,lf,cr,_lf			    ;3ea1
l3ea5h:
    db cr,lf,'COMMON',tab,'Length'	    ;3ea5
    db cr,lf,cr,_lf			    ;3eb4
l3eb8h:
    db cr,lf,'Labels:'			    ;3eb8
    db cr,lf,cr,_lf			    ;3ec1
l3ec5h:
    db ' Warning(s) Issued',cr,_lf	    ;3ec5
l3ed9h:
    db ' Fatal Error(s) Detected',cr,_lf    ;3ed9
;#################
;# END MODULE	 #
;#################

;#################
;# START MODULE	 #
;#################
;
;   Error msg table
;
ErrTab:
    db 080h					    ;3ef3
    dc 'Illegal Statement Number'		    ;3ef4 (100)
    dc 'Statement Unrecognizable or Misspelled'	    ;3f0c (101)
    dc 'Illegal Statement Completion'		    ;3f32 (102)
    dc 'Illegal DO Nesting'			    ;3f4e (103)
    dc 'Illegal Data Constant'			    ;3f60 (104)
    dc 'Missing Name'				    ;3f75 (105)
    dc 'Illegal Procedure Name'			    ;3f81 (106)
    dc 'Invalid DATA Constant or Repeat Factor'	    ;3f97 (107)
    dc 'Incorrect Number of DATA Constants'	    ;3fbd (108)
    dc 'Incorrect Integer Constant'		    ;3fdf (109)
    dc 'Invalid Statement Number'		    ;3ff9 (110)
    dc 'Not a Variable Name'			    ;4011 (111)
    dc 'Illegal Logical Form Operator'		    ;4024 (112) ?
    db 'Data Pool Overflow; '			    ;4041 (113)
    dc 'Out of Memory'				    ;
    dc 'Literal String is too large'		    ;4062 (114)
    dc 'Invalid Data List Element in I/O'	    ;407d (115)
    dc 'Unbalanced DO Nest'			    ;409d (116)
    dc 'Identifier Too Long'			    ;40af (117)
    dc 'Illegal Operator'			    ;40c2 (118)
    dc 'Mismatched Parenthesis'			    ;40d2 (119)
    dc 'Consecutive Operators'			    ;40e8 (120)
    dc 'Improper Subscript Syntax'		    ;40fd (121) ?
    dc 'Illegal Integer Quantity'		    ;4116 (122) ?
    dc 'Illegal Hollerith Construction'		    ;412e (123)
    dc 'Backwards DO reference'			    ;414c (124)
    dc 'Illegal Statement Function Name'	    ;4162 (125)
    dc 'Illegal Character for Syntax'		    ;4181 (126)
    dc 'Statement is out of Sequence'		    ;419d (127)
    dc 'Missing Integer Quantity'		    ;41b9 (128)
    dc 'Invalid Logical Operator'		    ;41d1 (129)
    dc 'Illegal Item in Type Declaration'	    ;41e9 (130)
    dc 'Premature End of File on input device'	    ;4209 (131)
    dc 'Illegal Mixed Mode Operation'		    ;422e (132).
    dc 'Function Call with No Parameters'	    ;424a (133) ?
    dc 'Stack Overflow'				    ;426a (134).
    dc 'Illegal Statement Following Logical IF'	    ;4278 (135).
    dc 'Wrong Number of Subscripts'		    ;429e (136).
    dc 'File Not Found'				    ;42b8 (137).
;
;   Warning msg table
;
WrnTab:
    db 080h					    ;42c6
    dc 'Duplicate Statement Label'		    ;42c7 (0)
    dc 'Illegal DO Termination'			    ;42e0 (1)
    dc 'Block Name = Procedure Name'		    ;42f6 (2)
    dc 'Array Name Misuse'			    ;4311 (3)
    dc 'COMMON Name Usage'			    ;4322 (4)
    dc 'Wrong Number of Subscripts'		    ;4333 (5)
    dc 'Array Multiply EQUIVALENCEd Within a Group' ;434d (6)
    dc 'Multiple EQUIVALENCE of COMMON'		    ;4377 (7)
    dc 'COMMON Base Lowered'			    ;4395 (8)
    dc 'Non-COMMON Variable in BLOCK DATA'	    ;43a8 (9)
    dc 'Empty List for Unformatted WRITE'	    ;43c9 (10)
    dc 'Non-Integer Expression'			    ;43e9 (11) ?
    dc 'Operand Mode Not Compatible with Operator'  ;43ff (12) ?
    dc 'Mixing of Operand Modes Not Allowed'	    ;4428 (13) ?
    dc 'Missing Integer Variable'		    ;444b (14)
    dc 'Missing Statement Number on FORMAT'	    ;4463 (15)
    dc 'Zero Repeat Factor'			    ;4485 (16) ?
    dc 'Zero Format Value'			    ;4497 (17)
    dc 'Format Nest Too Deep'			    ;44a8 (18)
    dc 'Statement Number not FORMAT Associated'	    ;44bc (19)
    dc 'Invalid Statement Number Usage'		    ;44e2 (20)
    dc 'No Path to this Statement'		    ;4500 (21)
    dc 'Missing DO Termination'			    ;4519 (22)
    dc 'Code Output in BLOCK DATA'		    ;452f (23)
    dc 'Undefined Labels Have Occurred'		    ;4548 (24)
    dc 'RETURN in a Main Program'		    ;4566 (25)
    dc 'STATUS Error on READ'			    ;457e (26) ?
    dc 'Invalid Operand Usage'			    ;4592 (27)
    dc 'Function with no Parameter'		    ;45a7 (28) ?
    dc 'Hex Constant Overflow'			    ;45c1 (29)
    dc 'Division by Zero'			    ;45d6 (30)
    dc 'X'					    ;45e6      d8
    dc 'Array Name Expected'			    ;45e6 (32)
    dc 'Illegal Argument to ENCODE/DECODE'	    ;45fa (33)
;#################
;# END MODULE	 #
;#############$$##

;#################
;# START MODULE	 #
;#################
;*
;*
;*
s_461bh:
    ld a,(ScopeID)	;461b
    dec a		;461e
    ld hl,(DataID)	;461f	hl=(DataID)
    jp nz,s_3a85h	;4622	if (ScopeID).ne.1 Put addres DATA" to console trap_ms (03a85h) ***
    inc a		;4625
    ld (l0289h),a	;4626	(l0289h)=(ScopeID)
    push hl		;4629 \
    ld hl,(l01cch)	;462a
    push hl		;462d \
    ld hl,(EntryID)	;462e	hl=(EntryID)
    call ExtAttr	;4631	Extract Attributes from the symbol table
    call s_3aebh	;4634	cd eb 3a
    pop hl		;4637 / hl=(l01cch)
    call ExtAttr	;4638	Extract Attributes from the symbol table
    ld a,'+'		;463b	a='+'
    call putchr		;463d	Put character to console
    pop hl		;4640 / hl=(DataID)
    jp putadr		;4641	--> Put addres HL to console
;*
;*  Extract Attributes from the symbol table
;*    ENTRY Reg HL - ADDR
;*
ExtAttr:
    ld (l01cch),hl	;4644	(l01cch)=ADDR
;*
;*  Extract Attributes from the Symbol table, entry (l01cch)
;*
s_4647h:
    ld hl,(l01cch)	;4647
    inc hl		;464a	hl=hl+1
    ld a,h		;464b
    or l		;464c	Test hl
    dec hl		;464d	hl=hl-1
    ret z		;464e	if (l01cch).eq.0ffffh Return
    ex de,hl		;464f
    ld hl,(l0206h)	;4650
    call cmpHL_DE	;4653	Compare HL with DE
    ex de,hl		;4656				    de=(l0206h) hl=(l01cch)
    ret nc		;4657	if (l0206h) >= (l01cch) Return
    ld a,(hl)		;4658				    Load byte from (l01cch)
    and 01111111b	;4659				    Clear high bit
    ld (SizeID),a	;465b	(SizeID)=(l01cch).and.7fh
    ld b,a		;465e				    b=(SizeID)
    ld a,(hl)		;465f				    Load byte from (l01cch)
    and 10000000b	;4660				    Select the high bit from (l01cch)
    rlca		;4662				    Place it in a zero bit
    ld (SegmID),a	;4663	(SegmID)=byte composed of high bit from (l01cch)
    dec hl		;4666				    hl=(l01cch)-1
    ld a,(hl)		;4667				    Load byte from (l01cch)-1
    and 00000111b	;4668				    Select 3 low bits
    ld c,a		;466a				    c=(KindID)
    ld (KindID),a	;466b	(KindID)=byte composed of 3 low bits from (l01cch)-1
    ld a,(hl)		;466e				    Load byte from (l01cch)-1
    and 00111000b	;466f				    Select select with 3 on 5 bits
    rra			;4671
    rra			;4672
    rra			;4673				    Place them in low bits
    ld (TypeID),a	;4674	(TypeID)= byte composed of with 3 on 5 bits
    ld a,(hl)		;4677				    Load byte from (l01cch)-1
    and 11000000b	;4678				    Select two high bit
    rlca		;467a
    rlca		;467b				    Place them in two low bits
    ld (ScopeID),a	;467c	(ScopeID)=byte composed of with 6 on 7 bits
    dec hl		;467f				    hl=(l01cch)-2
    ld d,(hl)		;4680
    dec hl		;4681				    hl=(l01cch)-3
    ld e,(hl)		;4682				    de=word from (l01cch)-2
    ex de,hl		;4683				    de=(l01cch)-3 hl=word from (l01cch)-2
    ld (DataID),hl	;4684	(DataID)=Word from (l01cch)-2
    ex de,hl		;4687				    de=(DataID) hl=(l01cch)-3
    dec hl		;4688				    hl=(l01cch)-4
    ld d,(hl)		;4689
    dec hl		;468a				    hl=(l01cch)-5
    ld e,(hl)		;468b				    de=word from (l01cch)-4
    dec hl		;468c				    hl=(l01cch)-6
    ex de,hl		;468d				    de=(l01cch)-6 hl=word from (l01cch)-4
    ld (EntryID),hl	;468e	(EntryID)=Word from (l01cch)-4
    call s_093ah	;4691	(l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=0
;
    ld hl,l01d6h	;4694	hl=l01d6h
;				de=(l01cch)-6
;				b=(SizeID)
l4697h:		;<--;
      ld a,(de)	    ;	;4697
      ld (hl),a	    ;	;4698	(hl)=(de)
      dec hl	    ;	;4699	hl=hl-1
      dec de	    ;	;469a	de=de-1
      dec b	    ;	;469b	b=b-1
    jp nz,l4697h ;--+	;469c				    de=(l01cch)-6-(SizeID)

IFT DBG
;   call ptest2
;   ret
ENDIF

    ld a,c		;469f				    a=(KindID)
    cp 4		;46a0
    jp nz,l46bch   ;--; ;46a2	if (KindID).ne.4 (Array) --> ...
    ld hl,(DataID)    ; ;46a5
    ld (l021dh),hl    ; ;46a8	(l021dh)=(DataID)
    dec hl	      ; ;46ab				    hl=(DataID)-1
    ld a,(hl)	      ; ;46ac				    Load byte from (DataID)-1
    and 11000000b     ; ;46ad				    Select two high bit
    rlca	      ; ;46af
    rlca	      ; ;46b0				    Place them in two low bits
    ld (l022dh),a     ; ;46b1	(l022dh)=byte composed of with 6 on 7 bits
    dec hl	      ; ;46b4				    hl=(DataID)-2
    ld d,(hl)	      ; ;46b5
    dec hl	      ; ;46b6				    hl=(DataID)-3
    ld e,(hl)	      ; ;46b7				    de=word from (DataID)-2
    ex de,hl	      ; ;46b8				    hl=word from (DataID)-2 de=(DataID)-3
    ld (DataID),hl    ; ;46b9	(DataID)=word from (DataID)-2
l46bch:		  ;<--+
    ld a,(TypeID)	;46bc
    cp 4		;46bf
    jp z,l46e1h ;-----; ;46c1	if (TypeID).eq.4 (INTEGER*4) --> ...
    cp 2	      ; ;46c4
    jp nz,l46d9h  ;-; ; ;46c6	if (TypeID).ne.2 (BYTE)	     --> ...
    ld a,(KindID)   ; ; ;46c9
    dec a	    ; ; ;46cc
    ld a,(TypeID)   ; ; ;46cd
    jp nz,l46d9h  ;-; ; ;46d0	if (KindID).eq.1 (Constant)  --> ...
    ld hl,(l01d5h)  ; ; ;46d3
    ld (l01d3h),hl  ; ; ;46d6	(l01d3h)=(l01d5h)
l46d9h:	       ;<---+ ;
		      ;
;   Calculation storage size variable according to the type
		      ;
    inc a	      ; ;46d9	a=(TypeID)+1
    rlca	      ; ;46da	Multiply by 2
    or a	      ; ;46db	for compatibility with z80
    jp po,l46e1h ;-;  ; ;46dc	if (TypeID).ne.3 (Byte) --> ...
    ld a,1	   ;  ; ;46df	a=1
l46e1h:	       ;<--+<-+
    ld (l02aah),a	;46e1	(l02aah)=Storage size
    ld a,(KindID)	;46e4
    or a		;46e7	Test (KindID)
    ret			;46e8
;
;
;
s_46e9h:
    ld hl,(DataID)	;46e9
    push hl		;46ec \ Save (DataID)
    ld hl,(EntryID)	;46ed
    push hl		;46f0 \ Save (EntryID)
    ld hl,(l01cch)	;46f1
    push hl		;46f4 \ Save (l01cch)
    xor a		;46f5
    ld (l0275h),a	;46f6	(l0275h)=0
    ld a,(l022dh)	;46f9	3a 2d 02
    ld hl,(l021dh)	;46fc	2a 1d 02
    ld bc,-6		;46ff	01 fa ff
    add hl,bc		;4702	hl=(l021dh)-6
    ld de,l0269h	;4703	de=l0269h
l4706h:		;<----;
    push af	      ; ;4706 \ f5
    push de	      ; ;4707 \ d5
    ld d,(hl)	      ; ;4708	56
    dec hl	      ; ;4709	2b
    ld e,(hl)	      ; ;470a	5e
    dec hl	      ; ;470b	2b
    ex (sp),hl	      ; ;470c	e3
    push hl	      ; ;470d	e5
    ex de,hl	      ; ;470e	eb
    call ExtAttr      ; ;470f	Extract Attributes from the Symbol table
    ld a,(ScopeID)    ; ;4712
    cp 3	      ; ;4715
    ld hl,(l01cch)    ; ;4717	2a cc 01
    jp z,l4722h ;---; ; ;471a	if (ScopeID).eq.3 --> ...    trap_ms (04722h) ***
    or a	    ; ; ;471d	b7
    ld hl,(l01d3h)  ; ; ;471e	2a d3 01
    db 6	    ; ; ;4721	ld b,037h (in the original) trap_ms ***
l4722h:		;<--+ ;
    scf		      ; ;4722
    ld bc,l0275h      ; ;4723	01 75 02
    ld a,(bc)	      ; ;4726	0a
    rla		      ; ;4727	17
    ld (bc),a	      ; ;4728	02
    ex de,hl	      ; ;4729	eb
    pop hl	      ; ;472a	e1
    ld (hl),e	      ; ;472b	73
    inc hl	      ; ;472c	23
    ld (hl),d	      ; ;472d	72
    inc hl	      ; ;472e	23
    ex de,hl	      ; ;472f	eb
    pop hl	      ; ;4730 / e1
    pop af	      ; ;4731 / f1
    dec a	      ; ;4732	a=a-1
    jp nz,l4706h  ;---+ ;4733	if a.eq.0 -->
    ld a,(l022dh)	;4736	3a 2d 02
    ld hl,l0275h	;4739	21 75 02
    or a		;473c	b7
    dec a		;473d	a=a-1
    jp z,l476bh	 ;--;	;473e	if a.eq.0 -->
    dec a	    ;	;4741	a=a-1
    ld a,(hl)	    ;	;4742	7e
    jp z,l474ch ;-; ;	;4743	if a.eq.0 -->
    ld b,a	  ; ;	;4746	Save a -------+
    and 006h	  ; ;	;4747	00000110b     |
    jp l4750h ;-; ; ;	;4749	--> ...	      |
		; ; ;	;		      |
l474ch:	    ;<--)-+ ;	;		      |
    rla		;   ;	;474c	17	      |
    ld b,a	;   ;	;474d	Save a	----+ |
    and 004h	;   ;	;474e	00000100b   | |
l4750h:	    ;<--+   ;	;		    | |
    jp z,l476bh	 ;--;	;4750	ca 6b 47    | |
    ld hl,l026ch    ;	;4753	21 6c 02    | |
    ld a,b	    ;	;4756	Restore a <-+-+
    rra		    ;	;4757	1f
    rra		    ;	;4758	1f
    jp c,l4761h ;-; ;	;4759	if carry --> ...
    push af	  ; ;	;475c \ f5
    call s_477ah  ; ;	;475d	cd 7a 47
    pop af	  ; ;	;4760 / f1
l4761h:	     ;<---+ ;
    rra		    ;	;4761	1f
    jp c,l476ah ;-; ;	;4762	da 6a 47
    dec hl	  ; ;	;4765
    dec hl	  ; ;	;4766	hl=hl-2
    call s_477ah  ; ;	;4767	cd 7a 47
l476ah:	     ;<---+ ;
    scf		    ;	;476a	Set carry
l476bh:	     ;<-----+
    pop hl		;476b / e1
    push af		;476c	f5
    call ExtAttr	;476d	Extract Attributes from the symbol table
    pop af		;4770	f1
    pop hl		;4771 / e1
    ld (EntryID),hl	;4772	(EntryID)=
    pop hl		;4775 / e1
    ld (DataID),hl	;4776	(DataID)=
    ret			;4779
;
;     ENTRY Reg HL - ADDR
;
s_477ah:		;			 de	 hl	 SP
    ld d,(hl)		;477a	56
    dec hl		;477b	hl=hl-1			ADDR-1
    ld e,(hl)		;477c	de=(hl)		(ADDR)
    push hl		;477d \ Save hl				ADDR-1
    ex de,hl		;477e			ADDR-1	(ADDR)
    call s_0523h	;477f	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ex de,hl		;4782	eb
    pop hl		;4783 / e1
    ld (hl),e		;4784	73
    inc hl		;4785
    ld (hl),d		;4786	72
    ret			;4787
;
;
;
s_4788h:
    ld hl,(l01b0h)	;4788
    call s_47abh	;478b
    ld (l01b2h),hl	;478e	(l01b2h)= word from (l01b0h)
    call s_47aah	;4791
    ld (l01aeh),hl	;4794	l01aeh = s_47aah
    call s_47aah	;4797
    ld (l01aah),hl	;479a	l01aah = s_47aah
    call s_47aah	;479d
    ld (l01a6h),hl	;47a0	l01a6h = s_47aah
    call s_47aah	;47a3
    ld (l01a8h),hl	;47a6	l01a8h = s_47aah
    ret			;47a9
;
;
;						de	    hl
s_47aah:		;			Addr1	    Addr2
    ex de,hl		;47aa			Addr2	    Addr1
s_47abh:
    ld e,(hl)		;47ab
    inc hl		;47ac				    Addr2+1
    ld d,(hl)		;47ad			(Addr2)
    inc hl		;47ae				    Addr2+2
    ex de,hl		;47af			Addr2+2	    (Addr2)
    ret			;47b0
;
; Processing BYTE, LOGICAL
;				Equivalent  Original
PrByte:
    ld a,2		;47b1	ld a,2	    ld a,2
    db 21h		;47b3 ;-jp l47bbh   ld hl,0033eh    trap_ms1 ***
			      ;
; Processing DOUBleprecision  ;
PrDouble:		      ;
    ld a,3		;47b4 ; ld a,3
    db 21h		;47b6 ;-jp l47bbh   ld hl,0013eh    trap_ms1 ***
			      ;
; Processing REAL	      ;
PrReal:			      ;
    ld a,1		;47b7 ; ld a,1
    db 26h		;47b9 ;-jp l47bbh   ld h,0afh	    trap_ms1 ***
			      ;
; Processing INTEGER	      ;
PrIneger:		      ;
    xor a		;47ba ;
l47bbh:		    ;<--------+
    ld (tmpvar),a	;47bb	(tmpvar)=a
    call g_n_chr	;47be +
    cp '*'		;47c1
    jp nz,l47fch  ;---; ;47c3	if chr.ne.'*' --> Size specifier not found
    call g_n_chr      ; ;47c6 +
    jp p,err130	      ; ;47c9 + if chr Special character or Letter --> Error (130) Illegal Item in Type Declaration
    sub '0'	      ; ;47cc + Make binary from ASCII Size_storage in bytes
    ld b,a	      ; ;47ce + Save Size_storage
    ld a,(tmpvar)     ; ;47cf
    dec a	      ; ;47d2
    jp z,l47eeh	 ;--; ; ;47d3	if (tmpvar).eq.1 (REAL) --> ...
    cp 2	    ; ; ;47d6
    jp z,l47eeh	 ;--; ; ;47d8	if (tmpvar).eq.3 (DOUBLE) --> ...
    ld a,b	    ; ; ;47db + Restore Size_storage
    dec a	    ; ; ;47dc
    jp z,PrByte	    ; ; ;47dd	if Size_storage.eq.1 --> Processing BYTE
    dec a	    ; ; ;47e0
    jp z,PrIneger   ; ; ;47e1	if Size_storage.eq.2 --> Processing INTEGER	    trap_ms1 (047bah) ***
    cp 2	    ; ; ;47e4
    jp nz,err130    ; ; ;47e6	if Size_storage.ne.4 --> Error (130) Illegal Item in Type Declaration
    ld a,4	    ; ; ;47e9	a=4 (INTEGER*4)
    jp l47bbh	    ; ; ;47eb	--> ...
		    ; ;
l47eeh:		;<--+ ;
    ld a,b	      ; ;47ee	Restore Size_storage
    cp 4	      ; ;47ef
    jp z,PrReal	      ; ;47f1	if Size_storage.eq.4 --> Processing REAL	    trap_ms1 (047b7h) ***
    cp 8	      ; ;47f4
    jp z,PrDouble     ; ;47f6	if Size_storage.eq.8 --> Processing DOUBleprecision trap_ms1 (047b4h) ***
    jp err130	      ; ;47f9	Error (130) Illegal Item in Type Declaration
		      ;
l47fch:		;<----+		Size specifier not found
    ld (l0173h),a	;47fc	(l0173h)=chr
    push af		;47ff	Save chr
    ld a,(PosStm)	;4800
    ld (l01ceh),a	;4803	(l01ceh)=(PosStm)
    ld a,6		;4806
    call GetStr		;4808	Reading string length 6 characters
    ld b,6		;480b	b=6
    ld de,l01d9h	;480d	11 d9 01
    ld hl,l02d3h	;4810	hl="FUNCTI"
    call cmpstr		;4813	Compare strings ^HL:^DE with length in B
    jp nz,l4835h ;--;	;4816	if strings not "FUNCTI" --> no found "FUNCTION"
		    ;
;   Found FUNCTI    ;
		    ;
    ld a,2	    ;	;4819
    call GetStr	    ;	;481b	Reading string length 2 characters
    ld de,04f4eh    ;	;481e	de="ON"
    ld hl,(l01ddh)  ;	;4821
    call cmpHL_DE   ;	;4824	Compare HL with DE
    jp nz,l4835h ;--;	;4827	if (l01ddh).ne."ON" --> no found "FUNCTION"
    pop af	    ;	;482a	Restore chr
    xor a	    ;	;482b
    ld (l01ceh),a   ;	;482c	(l01ceh)=0
    ld a,(tmpvar)   ;	;482f	3a 8d 02
    jp l599ch	    ;	;4832	--> Processing FUNCTION
		    ;
l4835h:		;<--+
;
;   No found FUNCTION
;
    call s_4e49h	;4835	Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
    pop af		;4838	Restore chr
    ld (l0298h),a	;4839	(l0298h)=chr
    ld (l0173h),a	;483c	(l0173h)=chr
    ld hl,l4845h	;483f
    ld (CurAdr),hl	;4842	(CurAdr)=point to l4845h
l4845h:
    call PrName		;4845	Processing name
    ld a,(tmpvar)	;4848
    ld (TypeID),a	;484b	(TypeID)=(tmpvar)
    call PutAttr	;484e	Put Attributes in Symbol table
    ld a,(l0298h)	;4851
    cp '('		;4854
    call z,s_19e8h	;4856	if (l0298h).eq.'(' --> Processing subscript an array
    jp l0928h		;4859	--> Test continue processing statement
;
err130:
    call err_msg	;485c	Error (130)
    db 130		;485f	Illegal Item in Type Declaration
;
;   Move 8 bytes from ^l01cfh to ^l01d7h
;
s_4860h:
    ld hl,l01cfh	;4860	Source address
s_4863h:
    ld de,l01d7h	;4863	Destination address
s_4866h:
    ld b,8		;4866	b=8
    jp s_085ch		;4868	--> Move B bytes from ^HL to ^DE
;
;   Processing BACKSPACE u, ENDFILE u, REWIND u
;
PrBackspace:
    call s_257ch	;486b	Processing integer constant
    xor a		;486e	a=0
    call s_294ah	;486f	cd 4a 29
    ld a,(i_Type)	;4872
    or a		;4875
    jp z,l487ch ;---;	;4876	if (i_Type).eq.0 (INTEGER) --> skip
    call s_25a5h    ;	;4879	{'LD L,A'->'RLA'->'SBC A,A'->'LD H,A'}
l487ch:		;<--+
    ld hl,l022bh	;487c	Load Pointer to location 1 and 2 bytes statement
    ld c,(hl)		;487f	Loading second character statement
    inc hl		;4880	hl=hl+1
    ld b,(hl)		;4881	Loading first character statement
    call CrBuilt	;4882	Creating built-in routine ($BA, $EN, or $RE)
    jp l09e4h		;4885	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;
;
;
s_4888h:
    ld a,(l0298h)	    ;4888
    cp '.'		    ;488b
    jp z,s_48bbh	    ;488d   if (l0298h).eq.'.' --> Parsing Logical operation
    cp '*'		    ;4890
    jp z,l4904h	 ;--------; ;4892   if (l0298h).eq.'*' --> ...
    ld de,00006h	  ; ;4895   de=6
    ld hl,l0487h	  ; ;4898   hl=pointer to Table Arithmetic Operators
l489bh:	      ;<---;	  ;
      cp (hl)	   ;	  ; ;489b   be
      jp z,l48abh;-)-;	  ; ;489c   if (l0298h).eq.(hl) --> exit from loop
      dec hl	   ; ;	  ; ;489f   hl=hl-1
      dec e	   ; ;	  ; ;48a0   e=e-1
    jp p,l489bh ;--+ ;	  ; ;48a1   if e >= 0
    xor a	     ;	  ; ;48a4
    ld (l0242h),a    ;	  ; ;48a5   (l0242h)=0
    jp l48b7h	 ;-; ;	  ; ;48a8   --> ...
		   ; ;	  ;
l48abh:	      ;<---)-+<-; ;
    ex de,hl	   ;	; ; ;48ab   hl=Counter value
    add hl,hl	   ;	; ; ;48ac   hl=hl*2
    ld de,l04a6h   ;	; ; ;48ad   DE= Pointer Table
    add hl,de	   ;	; ; ;48b0   hl=hl+de offset calculation
    ld a,(hl)	   ;	; ; ;48b1   7e
    ld (l0242h),a  ;	; ; ;48b2   (l0242h)= first byte in the table
    inc hl	   ;	; ; ;48b5   hl=hl+1
    ld a,(hl)	   ;	; ; ;48b6   7e
l48b7h:	   ;<------+	; ;
    ld (l01b4h),a	; ; ;48b7   (l01b4h)= second byte in the table
    ret			; ; ;48ba
			; ;
;   Parsing Logical operation
			; ;
s_48bbh:		; ;
    ld a,3		; ; ;48bb + a=3
    call GetStr		; ; ;48bd + Reading string length 3 characters
    ld de,0000ah	; ; ;48c0 + de=10 - counrer
    ld hl,l04a3h	; ; ;48c3 + hl=pointer to table Logical operations
l48c6h:		;<----; ; ;
      push de	      ; ; ; ;48c6 +
      push hl	      ; ; ; ;48c7 +
      ld b,3	      ; ; ; ;48c8 + b=3 Length Logical operations
      ld de,l01dch    ; ; ; ;48ca   11 dc 01
      call cmpstr     ; ; ; ;48cd + Compare strings ^HL:^DE with length in B
      pop hl	      ; ; ; ;48d0 +
      pop de	      ; ; ; ;48d1 +
      jp z,l48ebh ;-; ; ; ; ;48d2 + if strings eq --> Found Logical operation
      dec hl	    ; ; ; ; ;48d5 +
      dec hl	    ; ; ; ; ;48d6 +
      dec hl	    ; ; ; ; ;48d7 + hl=hl-3 Update pointer to next Logical operation
      dec e	    ; ; ; ; ;48d8 + e=e-1
    jp nz,l48c6h ;--)-+ ; ; ;48d9 + if e.ne.0 --> ...
		    ;	; ;
l48dch:	     ;<-----)-; ; ;
    ld hl,(TopMem)  ; ; ; ; ;48dc   Load value Top of memory
    ld sp,hl	    ; ; ; ; ;48df   Set for stack
    ld a,(l01ceh)   ; ; ; ; ;48e0
    or a	    ; ; ; ; ;48e3
    jp nz,l5666h    ; ; ; ; ;48e4   if (l01ceh).ne.0 --> Search statement
    call err_msg    ; ; ; ; ;48e7   Error (129)
    db 129	    ; ; ; ; ;48ea   Invalid Logical Operator
		    ; ; ; ;
;   Found Logical operation
		    ; ; ; ;
l48ebh:		;<--+ ; ; ;
    ld a,6	      ; ; ; ;48eb
    add a,e	      ; ; ; ;48ed
    ld e,a	      ; ; ; ;48ee   e=e+6
    ld a,(l0298h)     ; ; ; ;48ef
    cp '.'	      ; ; ; ;48f2
    jp z,l48abh	   ;--)-; ; ;48f4   if (l0298h).eq.'.' --> ...
    push de	      ; ; ; ;48f7
    call g_n_chr      ; ; ; ;48f8 \
    cp '.'	      ; ; ; ;48fb
    pop de	      ; ; ; ;48fd /
    jp z,l48abh	   ;--)-; ; ;48fe   if chr.eq.'.' --> ...
    jp l48dch  ;------+ ; ; ;4901   --> ...
			; ;
l4904h:	    ;<----------)-+
    call g_n_chr	;   ;4904 +
    cp '*'		;   ;4907
    ld de,00011h	;   ;4909   de=17
    jp z,l48abh	   ;----;   ;490c   if str.eq.'*' --> ...
    ld (l0173h),a	;   ;490f   (l0173h)=str
    ld e,2		;   ;4912   e=2
    jp l48abh	   ;----+   ;4914   --> ...
;
;   ENTRY
;     Reg DE - PAR1
;     Reg BC - PAR2
;
s_4917h:
    ld hl,00000h	 ;4917	hl=0
    ld a,16		 ;491a	a=16
l491ch:		 ;<----;
      add hl,hl	       ; ;491c	hl=hl*2
      ex de,hl	       ; ;491d	hl=PAR1	    de=hl*2
      add hl,hl	       ; ;491e	hl=PAR1*2
      ex de,hl	       ; ;491f	hl=hl*2	    de=PAR1*2
      jp nc,l4924h ;-; ; ;4920	if >= --> ...
      add hl,bc	     ; ; ;4923	hl=hl*2+PAR2
l4924h:		;<---+ ;
      dec a	       ; ;4924	a=a-1
    jp nz,l491ch   ;---+ ;4925	if a.ne.0 --> ...
    ret			 ;4928
;
;   Negate HL
;
Neg_HL:
    xor a		;4929	a=0
    sub l		;492a	a=a-l
    ld l,a		;492b	l=-l
    sbc a,h		;492c	a=a-h-Carry
    sub l		;492d
    ld h,a		;492e	h=a-l
    ret			;492f
;
;   Give Special LINK items:
;
;     Control_field Adr_mode Address Length
;1 00	  xxxx	     yy	     nn	     zzz     + characters of Symbol_name
;	   C	     B	     DE	    (SizeID)	     l01d6h
;
;     ENTRY Reg	 C holds xxxx Control_field (REL type)
;	    Reg	 B holds Address_mode (0-ASEG, 1-CSEG, 2-DSEG, 3-COMMON)
;	    Reg DE holds Address
RELITEM:
    push bc		;4930 \
    ld b,00b		;4931
    call w_code		;4933	Write special item
    ld b,c		;4936	Get bits
    ld a,4		;4937	Set count
    call w_bits		;4939	Put control
    pop bc		;493c /
    ld a,c		;493d	Get code back
    cp 0100b+1		;493e	Test name field only
    jp c,l4957h	 ;--;	;4940	.. yeap
    cp 15	    ;	;4943	Test end of file
    ret z	    ;	;4945	.. Yeap, no more follows
    ld a,2	    ;	;4946
    call w_bits	    ;	;4948	Give address bits
    ld b,e	    ;	;494b
    call w_byte	    ;	;494c	Put low
    ld b,d	    ;	;494f
    call w_byte	    ;	;4950	.. and high
    ld a,c	    ;	;4953
    cp 8	    ;	;4954	Test name field follows
    ret nc	    ;	;4956	.. nope
l4957h:		;<--+
    ld a,(SizeID)	;4957	3a b6 01
    ld b,a		;495a
    ld d,a		;495b
    ld a,3		;495c
    call w_bits		;495e	Give length
    push hl		;4961 \
;
;   Put name
;
    ld hl,l01d6h	;4962	21 d6 01
l4965h:		;<--;
      ld b,(hl)	    ;	;4965
;     ld a,b	    ;		Ver 3.44
;     and 7fh	    ;		Reset bit 7
;     ld b,a	    ;
      call w_byte   ;	;4966	.. Put name
      dec hl	    ;	;4969
      dec d	    ;	;496a
    jp nz,l4965h ;--+	;496b
    pop hl		;496e /
    ret			;496f
;
;   Output n bits
;     ENTRY Reg A holds bit count
;	    Reg B holds bits to be outputted
;
w_bits:
    push de		;4970
    ld d,a		;4971	Get count
    ld a,8		;4972
    sub d		;4974	Calculate remaining bits
    jp z,l4980h ;-----; ;4975	.. boundary
    ld e,a	      ; ;4978
    ld a,b	      ; ;4979
l497ah:	      ;<----; ;
      add a,a	    ; ; ;497a	Left justify bits
      dec e	    ; ; ;497b
    jp nz,l497ah ;--+ ; ;497c
    ld b,a	      ; ;497f
l4980h:	      ;<------+
t4980h:	      ;<------;
      ld a,b	      ; ;4980	Get value
      add a,a	      ; ;4981	.. get carry
      ld b,a	      ; ;4982
      call w_bit      ; ;4983	Write it
      dec d	      ; ;4986
    jp nz,t4980h  ;---+ ;4987
    pop de		;498a
    ret			;498b
;
; Put Name from Symbol table to REL file
;   ENTRY
;     Reg A  - SizeID
;     Reg HL - ADDR
;
w_NAMe:
    push af		;498c	Save SizeID
    cpl			;498d
    sub 4		;498e
    ld c,a		;4990
    ld b,0ffh		;4991	bc = SizeID-5
    add hl,bc		;4993	hl=ADDR-SizeID-5
    db 0feh		;4994	cp 0f5h (in the original)   trap_ms ***
l4995h:		;<--;
      push af	    ;	;4995 \
      push hl	    ;	;4996 \
      ld a,(hl)	    ;	;4997	7e
      call p_byte   ;	;4998	Put byte in reg A to REL file
      ld a,' '	    ;	;499b
      call putchr   ;	;499d	Put ' ' to console
      pop hl	    ;	;49a0 /
      pop af	    ;	;49a1 /
      dec a	    ;	;49a2	a=a-1
      inc hl	    ;	;49a3	hl=hl+1
    jp nz,l4995h ;--+	;49a4	Put next byte	  trap_ms (04995h) ***
    ret			;49a7
;
;   Output control prefix 1.b2.b1
;     ENTRY Reg B holds two bit control
;
w_code:
    scf			;49a8	Set bit
    call w_bit		;49a9	Write it (Put 1)
    ld a,b		;49ac
    rra			;49ad	Get b2
    rra			;49ae
    call w_bit		;49af	Write it (Put b2)
    ld a,b		;49b2
    rra			;49b3	Get b1 and write it
;
;   Put bit (CY) to REL file
;     ENTRY Carry indicates bit set
;
w_bit:
    push hl		;49b4
    ld hl,l0159h	;49b5	Point to REL byte
    ld a,(hl)		;49b8	Get current value
    rla			;49b9	.. shift carry in
    ld (hl),a		;49ba
    inc hl		;49bb
    inc (hl)		;49bc	Test bits remaining
    jp nz,l49cch ;--;	;49bd	.. yeap
    ld a,(l0159h)   ;	;49c0
    call oput	    ;	;49c3	Put byte to REL file
    ld hl,0f800h    ;	;49c6	h=-8
    ld (l0159h),hl  ;	;49c9	Reset bit count
l49cch:		;<--+
    pop hl		;49cc
    ret			;49cd
;
s_49ceh:
    ld hl,(DataID)	;49ce
    ld a,h		;49d1
    or l		;49d2
    ret z		;49d3	if (DataID).eq.0 Return
    ld bc,0010ch	;49d4	Address modes CSEG, rel type - PRGSIZ
    ld a,(TypeID)	;49d7
    or a		;49da
    jp z,l4a0dh ;-----; ;49db	if (TypeID).eq.0 (INTEGER) --> ...
    push bc	      ; ;49de \ c5
    push hl	      ; ;49df \ e5
    ld a,(RomFlg)     ; ;49e0
    or a	      ; ;49e3	Test /M
    jp z,l49fah ;---; ; ;49e4	if (RomFlg).eq.0 --> ...
    ld hl,(PrgSiz)  ; ; ;49e7	Load Program size
    ld a,(l020bh)   ; ; ;49ea
    or a	    ; ; ;49ed
    jp nz,l49f4h;-; ; ; ;49ee	if (l020bh).ne.0 --> ...
    inc hl	  ; ; ; ;49f1
    inc hl	  ; ; ; ;49f2
    inc hl	  ; ; ; ;49f3	hl=(PrgSiz)+3
l49f4h:	      ;<--+ ; ;
    call s_56dbh    ; ; ;49f4	cd db 56
    jp l4a02h  ;--; ; ; ;49f7	--> ...
		  ; ; ;
l49fah:	      ;<--)-+ ;
    inc b	  ;   ; ;49fa	b=b+1
    dec c	  ;   ; ;49fb	c=c-1
    ld hl,(DatSiz);   ; ;49fc	Load Data size
    call s_56deh  ;   ; ;49ff	cd de 56
l4a02h:	       ;<-+   ;
    pop de	      ; ;4a02 / de=(DataID)
    pop bc	      ; ;4a03 / Address modes CSEG, rel type - PRGSIZ
    call RELITEM      ; ;4a04	cd 30 49
    ld hl,(l021bh)    ; ;4a07	2a 1b 02
    jp s_56dbh	      ; ;4a0a	--> ...
		      ;
l4a0dh:		  ;<--+
    ld a,(SegmID)	;4a0d	Load Flag Address mode
    or a		;4a10
    jp z,s_4a15h  ;---; ;4a11	if (SegmID).eq.0 (CSEG) -->
    inc b	      ; ;4a14	Address modes DSEG, rel type - PRGSIZ
s_4a15h:	  ;<--+
    ex de,hl		;4a15	de=(DataID)
    jp RELITEM		;4a16	--> ...
;
;   Assign name "$MAIN" and put name main program to REL file
;
s_4a19h:
    ld hl,l02e5h	;4a19	hl="$MAIN"
    ld de,l01d2h	;4a1c	Destination address
    ld b,5		;4a1f	b=5
    ld a,b		;4a21
    ld (SizeID),a	;4a22	(SizeID)=5
    call s_085ch	;4a25	Move B bytes from ^HL to ^DE
;
;   Put name program to REL file
;
s_4a28h:
    ld a,(l5a66h)	;4a28	a=Drive	    *n*
    inc a		;4a2b
    jp z,l4a49h	 ;---;	;4a2c	if (Drive).eq.1 --> Skip output name to console
    ld a,(SizeID)    ;	;4a2f
    ld c,a	     ;	;4a32	c=(SizeID)
    ld hl,l01d6h     ;	;4a33	21 d6 01
l4a36h:	     ;<----; ;
      ld a,(hl)	   ; ;	;4a36
      call conout  ; ;	;4a37	Put character in Accu to console
      dec hl	   ; ;	;4a3a	hl=hl-1
      dec c	   ; ;	;4a3b	c=c-1
    jp nz,l4a36h ;-+ ;	;4a3c	if c.ne.0 next
    ld a,cr	     ;	;4a3f	a=cr
    call conout	     ;	;4a41	Put character in Accu to console
    ld a,lf	     ;	;4a44	a=lf
    call conout	     ;	;4a46	Put character in Accu to console
l4a49h:		;<---+
    ld c,2		;4a49	REL types - Program name
    ld a,c		;4a4b
    ld (l024dh),a	;4a4c	(l024dh)=2
    call RELITEM	;4a4f
    ld a,(MainFlg)	;4a52
    or a		;4a55
    ret nz		;4a56	if (MainFlg).ne.0 (Subprogram) Return
    ld bc,0107h		;4a57	Address modes CSEG, rel type - define ENTRY POINT
    ld de,00000h	;4a5a	de=0
    call RELITEM	;4a5d	Give code entry point
    jp s_4a69h	;---;	;4a60	--> ...
		    ;
l4a63h:		    ;
    db 'BILROF'	    ;	;4a63	"FORLIB"
		    ;
s_4a69h:	;<--+
    ld hl,(l01cch)	;4a69
    push hl		;4a6c \ Save (l01cch)
    ld hl,l4a63h	;4a6d	hl="FORLIB"
    ld de,l01d1h	;4a70	Destination address
    ld b,6		;4a73	b=6
    ld a,b		;4a75
    ld (SizeID),a	;4a76	(SizeID)=6
    call s_085ch	;4a79	Move B bytes from ^HL to ^DE
    ld bc,0003h		;4a7c	REL type - request LIBRARY SEARCH
    call RELITEM	;4a7f	Give lib request
    pop hl		;4a82 / Restore (l01cch)
    jp ExtAttr		;4a83	--> Extract Attributes from the symbol table
;
;   Test Allocate A bytes of memory
;
ChkMem:
    ld c,a		;4a86
    ld b,0		;4a87
    ld hl,(HeapPtr)	;4a89				hl=(HeapPtr)
    add hl,bc		;4a8c	Add bytes requested	hl=(HeapPtr)+a
    ex de,hl		;4a8d						de=(HeapPtr)+a
    ld hl,(HeapEnd)	;4a8e				hl=(HeapEnd)
    call cmpHL_DE	;4a91	Compare HL with DE
    ret nc		;4a94	if (HeapEnd) >= (HeapPtr)+a Return
    ld hl,(l0206h)	;4a95
    ld (HeapEnd),hl	;4a98	(HeapEnd)=(l0206h)
    ld (l0209h),hl	;4a9b	(l0209h)=(l0206h)
    call err_msg	;4a9e	Error (113)
    db 113		;4aa1	Data Pool Overflow
;
;   Move 19 bytes from l02b5h to l02b4h
;     ENTRY Reg A
s_4aa2h:
    ld c,a		;4aa2	4f
    ld hl,l02b5h	;4aa3	21 b5 02
    ld de,l02b4h	;4aa6	11 b4 02
    ld b,013h		;4aa9	b=19
    call s_085ch	;4aab	Move 19 bytes from ^HL to ^DE
    ld a,c		;4aae	79
    ld (de),a		;4aaf	Store Len
    ret			;4ab0
;
;
;
s_4ab1h:
    ld a,(l01d3h)	;4ab1
    ld d,a		;4ab4	d=(l01d3h)
    ld e,8		;4ab5	e=8
    ld hl,02020h	;4ab7
    call s_093dh	;4aba	(l01cfh)=(l01d1h)=(l01d3h)=(l01d5h)=2020h
    ld hl,l01cfh	;4abd	21 cf 01
l4ac0h:		;<--;
      push hl	    ;	;4ac0 \
      call s_1a98h  ;	;4ac1	cd 98 1a
      pop hl	    ;	;4ac4 /
      ret z	    ;	;4ac5	if a.eq.0 Return
      dec e	    ;	;4ac6	e=e-1
      ld (hl),a	    ;	;4ac7	(hl)=a
      inc hl	    ;	;4ac8	hl=hl+1
    jp p,l4ac0h ;---+	;4ac9	if e >= 0 --> ...
    call err_msg	;4acc	Error (114)
    db 072h		;4acf	"Literal String Too Large"
;
;   Processing PROGRAM (PROGRAM name)
;
PrProgram:
    ld a,6		;4ad0 + a=6 Expected length of the name
    call GetStr		;4ad2 + Reading string length 6 characters
    cp cr		;4ad5 +
    ld de,l01deh	;4ad7	Address first character in read buffer
    jp nz,l4ae4h ;-;	;4ada	if Last character.ne.cr --> process name   trap_ms (04ae4h) ***
    call cmpHL_DE  ;	;4add
    jp z,l4afeh	 ;-)--; ;4ae0	if Pointer to last character.eq.Address first character (missing name) --> Assign default name
    db 0feh	   ;  ; ;4ae3	cp 02bh (in the original)		    trap_ms ***
l4ae4h:	    ;<-----+  ;
    dec hl	      ; ;4ae4	hl=hl-1
    ld bc,l01d6h      ; ;4ae5	Destination adress
    xor a	      ; ;4ae8	a=0 Clear counter characters
    push af	      ; ;4ae9 \ f5
		      ;
;   Copy the name     ;
		      ;
l4aeah:		      ;
      call cmpHL_DE   ; ;4aea	Compare HL with DE
      jp z,l4afah ;-; ; ;4aed	if HL(current address).eq.Address first character in read buffer --> Exit from loop
      ld a,(de)	    ; ; ;4af0
      ld (bc),a	    ; ; ;4af1	(bc)=(de)
      dec bc	    ; ; ;4af2	bc=bc-1
      dec de	    ; ; ;4af3	de=de-1
      pop af	    ; ; ;4af4 / f1
      inc a	    ; ; ;4af5	a=a+1
      push af	    ; ; ;4af6 \ f5
    jp l4aeah	    ; ; ;4af7	--> Copy next character of name
		    ; ;
l4afah:	     ;<-----+ ;
    pop af	      ; ;4afa / Number of characters in the name
    jp nz,l4b04h  ;-; ; ;4afb	if copied at least one character
		    ; ;
l4afeh:		;<--)-+
		    ;
;   Assign  default ; name
		    ;
    call s_4a19h    ;	;4afe	Assign name "$MAIN" and put it to REL file
    jp l4b0fh	;---)-; ;4b01	--> ...
		    ; ;
l4b04h:	   ;<-------+ ;
    ld (SizeID),a     ; ;4b04	(SizeID)=number of characters in the name
    call s_4a28h      ; ;4b07	Put name main program to REL file
    ld a,1	      ; ;4b0a
    ld (l0261h),a     ; ;4b0c	(l0261h)=1
l4b0fh:		  ;<--+
    call s_354dh	;4b0f	Build standard fortran header
    ld a,(l0298h)	;4b12	3a 98 02
l4b15h:		  ;<--;
      cp cr	      ; ;4b15 +
      jp z,l09e4h     ; ;4b17 + if a.eq.cr --> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
      call g_n_chr    ; ;4b1a +
    jp l4b15h	  ;---+ ;4b1d + --> ...
;
;
;
s_4b20h:
    ld hl,(l01cch)	    ;4b20
    push hl		    ;4b23 \ Save (l01cch)	    hl=(l01cch)
    ld a,(l022dh)	    ;4b24
    rlca		    ;4b27   Multiply by 2
    ld (l0295h),a	    ;4b28   (l0295h)=(l022dh)*2
    ld a,1		    ;4b2b
    ld (l0259h),a	    ;4b2d   (l0259h)=1
    ld hl,00000h	    ;4b30			    hl=0
    ld (l01eah),hl	    ;4b33   (l01eah)=0
    ld (l01e7h),hl	    ;4b36   (l01e7h)=0
    push hl		    ;4b39 \ e5
    dec hl		    ;4b3a   2b
    ld (l0234h),hl	    ;4b3b   (l0234h)=(l01cch)-1
l4b3eh:		;<------;
    pop bc		;   ;4b3e / Restore bc
    push bc		;   ;4b3f \ Save bc
    ld hl,(l02b0h)	;   ;4b40			    hl=(l02b0h)
    ex de,hl		;   ;4b43					    de=(l02b0h)
    ld hl,l02a4h	;   ;4b44			    hl=l02a4h
    add hl,bc		;   ;4b47			    hl=l02a4h+bc
    ld (hl),e		;   ;4b48   (l02a4h+bc)=(l02b0h)
    inc hl		;   ;4b49
    ld (hl),d		;   ;4b4a
    ld hl,l026fh	;   ;4b4b			    hl=l026fh
    add hl,bc		;   ;4b4e			    hl=l026fh+bc
    ld de,00001h	;   ;4b4f					    de=1
    ld (hl),e		;   ;4b52   (l026fh+bc) = 1
    inc hl		;   ;4b53
    ld (hl),d		;   ;4b54
    ld hl,l026bh	;   ;4b55			    hl=l026bh
    add hl,bc		;   ;4b58			    hl=l026bh+bc
    dec de		;   ;4b59
    dec de		;   ;4b5a					    de = -1
    ld (hl),e		;   ;4b5b   (l026bh+bc) = -1
    inc hl		;   ;4b5c
    ld (hl),d		;   ;4b5d
    call s_257ch	;   ;4b5e   Processing integer constant
    ld a,(KindID)	;   ;4b61
    dec a		;   ;4b64
    jp nz,l4b80h  ;---; ;   ;4b65   if (KindID).ne.1 (Constant) --> ...
    ld a,(l0242h)     ; ;   ;4b68
    cp 2	      ; ;   ;4b6b
    jp nz,l4ba0h ;--; ; ;   ;4b6d   if (l0242h).ne.2 --> ...
    ld hl,(l01d3h)  ; ; ;   ;4b70			    hl=(l01d3h)
    ex de,hl	    ; ; ;   ;4b73					    de=(l01d3h)
    ld hl,l026fh    ; ; ;   ;4b74			    hl=l026fh
    pop bc	    ; ; ;   ;4b77 / Restore bc
    push bc	    ; ; ;   ;4b78 \ Save bc
    add hl,bc	    ; ; ;   ;4b79			    hl=l026fh+bc
    ld (hl),e	    ; ; ;   ;4b7a   (l026fh+bc)=(l01d3h)
    inc hl	    ; ; ;   ;4b7b
    ld (hl),d	    ; ; ;   ;4b7c
    call s_2569h    ; ; ;   ;4b7d   Processing integer constant & Test (KindID).ne.1
l4b80h:	       ;<---)-+ ;
    ld hl,(l01cch)  ;	;   ;4b80			    hl=(l01cch)
    ex de,hl	    ;	;   ;4b83					    de=(l01cch)
    ld hl,l02a4h    ;	;   ;4b84			    hl=l02a4h
    pop bc	    ;	;   ;4b87 / Restore bc
    push bc	    ;	;   ;4b88 \ Save bc
    add hl,bc	    ;	;   ;4b89			    hl=l02a4h+bc
    ld (hl),e	    ;	;   ;4b8a   (l02a4h+bc)=(l01cch)
    inc hl	    ;	;   ;4b8b
    ld (hl),d	    ;	;   ;4b8c
    ld a,(l0298h)   ;	;   ;4b8d
    cp '+'	    ;	;   ;4b90
    jp z,l4b9ah ;-; ;	;   ;4b92   if (l0298h).eq.'+' --> ...
    cp '-'	  ; ;	;   ;4b95
    jp nz,l4baeh;-)-)-; ;   ;4b97   if (l0298h).ne.'-' --> ...
l4b9ah:	      ;<--+ ; ; ;
    ld (l0173h),a   ; ; ;   ;4b9a   (l0173h)='+' or' -'
    call s_1b26h    ; ; ;   ;4b9d   Processing integer constant with test (KindID)=Constant
l4ba0h:		;<--+ ; ;
    ld hl,(l01d3h)    ; ;   ;4ba0			    hl=(l01d3h)
    dec hl	      ; ;   ;4ba3			    hl=(l01d3h)-1
    ex de,hl	      ; ;   ;4ba4					    de=(l01d3h)-1
    ld hl,l016bh      ; ;   ;4ba5			    hl=l016bh
    pop bc	      ; ;   ;4ba8 / Restore bc
    push bc	      ; ;   ;4ba9 \ Save bc
    add hl,bc	      ; ;   ;4baa			    hl=l016bh+bc
    ld (hl),e	      ; ;   ;4bab   (l016bh+bc)=(l01d3h)-1
    inc hl	      ; ;   ;4bac
    ld (hl),d	      ; ;   ;4bad
l4baeh:		;<----+ ;
    pop bc		;   ;4bae / Restore bc
    inc bc		;   ;4baf
    inc bc		;   ;4bb0   bc=bc+2
    ld a,c		;   ;4bb1
    ld hl,l0295h	;   ;4bb2
    cp (hl)		;   ;4bb5
    jp z,l4bc0h ;---;	;   ;4bb6   if (l0295h).eq.c --> ...
    push bc	    ;	;   ;4bb9 \ Save bc  -------;
    call ChComma    ;	;   ;4bba   Check ','	    ;
    jp l4b3eh ;-----)---+   ;4bbd   --> ...	    ;
		    ;				    ;
l4bc0h:		;<--+				    ;
    call s_4e59h	    ;4bc0   cd 59 4e	    ;
    pop hl		    ;4bc3 / hl=bc    <------+
    ld a,(l0242h)	    ;4bc4
    push af		    ;4bc7 \ Save (l0242h)
    push hl		    ;4bc8 \ Save hl=bc
    call ExtAttr	    ;4bc9   Extract Attributes from the symbol table
    call s_46e9h	    ;4bcc   cd e9 46
    jp c,l4d26h		    ;4bcf   if ? --> ...
    ld hl,(l02aah)	    ;4bd2
    ld (l0291h),hl	    ;4bd5   (l0291h)=(l02aah)
    ld hl,00000h	    ;4bd8   hl=0
    ld (NumArg),hl	    ;4bdb   (NumArg)=0
    push hl		    ;4bde \ Save hl=0 --+
l4bdfh:		;<----;				;
    ld hl,(l0291h)    ;	    ;4bdf		;	    hl=(l0291h)
    ex de,hl	      ;	    ;4be2		;			    de=(l0291h)
    ld hl,l016bh      ;	    ;4be3		;	    hl=l016bh
    pop bc	      ;	    ;4be6 / bc=	      <-+
    push bc	      ;	    ;4be7 \ c5
    add hl,bc	      ;	    ;4be8			    hl=l016bh+bc
    ld c,(hl)	      ;	    ;4be9   bc=(l016bh+bc)
    inc hl	      ;	    ;4bea
    ld b,(hl)	      ;	    ;4beb
    push de	      ;	    ;4bec \ save de=(l0291h)
    call s_4917h      ;	    ;4bed   cd 17 49
    ex de,hl	      ;	    ;4bf0   eb
    ld hl,(NumArg)    ;	    ;4bf1   2a 93 02
    add hl,de	      ;	    ;4bf4   19
    ld (NumArg),hl    ;	    ;4bf5   22 93 02
    pop de	      ;	    ;4bf8 / d1
    ld hl,l026fh      ;	    ;4bf9   21 6f 02
    pop bc	      ;	    ;4bfc / c1
    push bc	      ;	    ;4bfd \ c5
    add hl,bc	      ;	    ;4bfe   09
    push hl	      ;	    ;4bff \ e5
    ld c,(hl)	      ;	    ;4c00   4e
    inc hl	      ;	    ;4c01   23
    ld b,(hl)	      ;	    ;4c02   46
    call s_4917h      ;	    ;4c03   cd 17 49
    ex de,hl	      ;	    ;4c06   eb
    pop hl	      ;	    ;4c07 / e1
    ld (hl),e	      ;	    ;4c08   73
    inc hl	      ;	    ;4c09   23
    ld (hl),d	      ;	    ;4c0a   72
    pop bc	      ;	    ;4c0b / c1
    push bc	      ;	    ;4c0c \ c5
    push de	      ;	    ;4c0d \ d5
    ld hl,l02a4h      ;	    ;4c0e   21 a4 02
    add hl,bc	      ;	    ;4c11   09
    ld e,(hl)	      ;	    ;4c12   5e
    inc hl	      ;	    ;4c13   23
    ld d,(hl)	      ;	    ;4c14   56
    ld hl,(l02b0h)    ;	    ;4c15   2a b0 02
    call cmpHL_DE     ;	    ;4c18   Compare HL with DE
    pop hl	      ;	    ;4c1b / e1
    jp z,l4c51h	 ;--; ;	    ;4c1c   if HL eq DE
    call s_0523h    ; ;	    ;4c1f   (l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl  ; ;	    ;4c22   (l0237h)=
    pop bc	    ; ;	    ;4c25 / c1
    push bc	    ; ;	    ;4c26 \ c5
    ld hl,(l0234h)  ; ;	    ;4c27   2a 34 02
    push hl	    ; ;	    ;4c2a \ e5
    ld hl,l02a4h    ; ;	    ;4c2b   21 a4 02
    add hl,bc	    ; ;	    ;4c2e   09
    ld e,(hl)	    ; ;	    ;4c2f   5e
    inc hl	    ; ;	    ;4c30   23
    ld d,(hl)	    ; ;	    ;4c31   56
    ex de,hl	    ; ;	    ;4c32   eb
    ld (l0234h),hl  ; ;	    ;4c33   22 34 02
    ld a,2	    ; ;	    ;4c36
    ld (l0242h),a   ; ;	    ;4c38   (l0242h)=2
    call s_4e0ch    ; ;	    ;4c3b   cd 0c 4e
    pop hl	    ; ;	    ;4c3e / e1
    inc hl	    ; ;	    ;4c3f   23
    ld a,h	    ; ;	    ;4c40
    or l	    ; ;	    ;4c41
    jp z,l4c51h	 ;--; ;	    ;4c42   test hl
    dec hl	    ; ;	    ;4c45   2b
    ld (l0236h),hl  ; ;	    ;4c46   22 36 02
    ld a,1	    ; ;	    ;4c49
    ld (l0242h),a   ; ;	    ;4c4b   (l0242h)=1
    call s_4e0ch    ; ;	    ;4c4e   cd 0c 4e
l4c51h:		;<--+ ;
    pop bc	      ;	    ;4c51 / c1
    inc bc	      ;	    ;4c52   03
    inc bc	      ;	    ;4c53   03
    ld a,c	      ;	    ;4c54   79
    ld hl,l0295h      ;	    ;4c55   21 95 02
    cp (hl)	      ;	    ;4c58   be
    jp z,l4c71h	 ;--; ;	    ;4c59   ca 71 4c
    push bc	    ; ;	    ;4c5c \ c5
    ld hl,l0267h    ; ;	    ;4c5d   21 67 02
    add hl,bc	    ; ;	    ;4c60   09
    ld c,(hl)	    ; ;	    ;4c61   4e
    inc hl	    ; ;	    ;4c62   23
    ld b,(hl)	    ; ;	    ;4c63   46
    ld hl,(l0291h)  ; ;	    ;4c64   2a 91 02
    ex de,hl	    ; ;	    ;4c67   eb
    call s_4917h    ; ;	    ;4c68   cd 17 49
    ld (l0291h),hl  ; ;	    ;4c6b   22 91 02
    jp l4bdfh	;---)-+	    ;4c6e   --> ...
		    ;
l4c71h:		;<--+
    pop hl		    ;4c71 / e1
    call ExtAttr	    ;4c72   Extract Attributes from the symbol table
    ld hl,(NumArg)	    ;4c75
    ld a,h		    ;4c78
    or l		    ;4c79
    jp z,l4cfah	  ;-------; ;4c7a   if (NumArg).eq.0 --> ...
    ld a,(ScopeID)	  ; ;4c7d
    cp 3		  ; ;4c80
    jp nz,l4cb5h  ;---;	  ; ;4c82   if (ScopeID).ne.3 --> ...
    push hl	      ;	  ; ;4c85 \ SP=(NumArg)
    ld hl,(l01cch)    ;	  ; ;4c86
    ex (sp),hl	      ;	  ; ;4c89   hl=(NumArg) SP=(l01cch)
    call s_0523h      ;	  ; ;4c8a   (l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl    ;	  ; ;4c8d   (l0236h)=
    ld hl,(l0234h)    ;	  ; ;4c90
    inc hl	      ;	  ; ;4c93
    ld a,h	      ;	  ; ;4c94
    or l	      ;	  ; ;4c95
    jp nz,l4ca2h  ;-; ;	  ; ;4c96   if (l0234h).ne.1 --> ...
    ld hl,(l01cch)  ; ;	  ; ;4c99
    ld (l0234h),hl  ; ;	  ; ;4c9c   (l0234h)=(l01cch)
    jp l4caah ;---; ; ;	  ; ;4c9f   --> ...
		  ; ; ;	  ;
l4ca2h:	       ;<-)-+ ;	  ;
    ld a,1	  ;   ;	  ; ;4ca2
    ld (l0242h),a ;   ;	  ; ;4ca4   (l0242h)=1
    call s_4e0ch  ;   ;	  ; ;4ca7   cd 0c 4e
l4caah:	     ;<---+   ;	  ;
    pop hl	      ;	  ; ;4caa / hl=(l01cch)
    call ExtAttr      ;	  ; ;4cab   Extract Attributes from the symbol table
    xor a	      ;	  ; ;4cae
    ld (l0259h),a     ;	  ; ;4caf   (l0259h)=0
    jp l4d07h	;-----)-; ; ;4cb2   --> ...
		      ; ; ;
l4cb5h:	      ;<------+ ; ;
    ld hl,(l01cch)	; ; ;4cb5
    ld (l01d4h),hl	; ; ;4cb8   (l01d4h)=(l01cch)
    ld hl,(NumArg)	; ; ;4cbb
    ex de,hl		; ; ;4cbe
    ld hl,(DataID)	; ; ;4cbf
    add hl,de		; ; ;4cc2
    ld (l01d2h),hl	; ; ;4cc3   (l01d2h)=(DataID)+(NumArg)
    push hl		; ; ;4cc6 \ Save (l01d2h) ----------;
    ld a,02ah		; ; ;4cc7   '*'			    ;
    ld (l01d6h),a	; ; ;4cc9   (l01d6h)=02ah	    ;
    ld a,5		; ; ;4ccc			    ;
    ld (SizeID),a	; ; ;4cce   (SizeID)=5		    ;
    ld a,3		; ; ;4cd1			    ;
    ld (KindID),a	; ; ;4cd3   (KindID)=3 (Variable)   ;
    ld a,(ScopeID)	; ; ;4cd6			    ;
    push af		; ; ;4cd9 \ Save (ScopeID) -------; ;
    ld hl,(EntryID)	; ; ;4cda			  ; ;
    push hl		; ; ;4cdd \ Save (EntryID)    --; ; ;
    call s_055ah	; ; ;4cde   cd 5a 05		; ; ;
    pop hl		; ; ;4ce1 / Restore (EntryID) <-+ ; ;
    pop af		; ; ;4ce2 / Restore	   <------+ ;
    ld (ScopeID),a	; ; ;4ce3	(ScopeID)	    ;
    dec a		; ; ;4ce6			    ;
    jp z,l4cedh	 ;--;	; ; ;4ce7   if(ScopeID).eq.1 --> ...;
    ld hl,(l01cch)  ;	; ; ;4cea   hl=(l01cch)		    ;
l4cedh:		;<--+	; ;				    ;
    ld (EntryID),hl	; ; ;4ced   (EntryID)=		    ;
    pop hl		; ; ;4cf0 / Resore (l01d2h) <-------+
    ld (DataID),hl	; ; ;4cf1   (DataID)=(DataID)+(NumArg)
    call PutAttr	; ; ;4cf4   Put Attributes in Symbol table
    call s_055ah	; ; ;4cf7   cd 5a 05
l4cfah:	      ;<--------;-+
    xor a		;   ;4cfa   a=0
    ld (l0259h),a	;   ;4cfb   (l0259h)=0
    ld hl,(l0234h)	;   ;4cfe
    inc hl		;   ;4d01
    ld a,h		;   ;4d02
    or l		;   ;4d03
    jp z,l4d21h ;-----; ;   ;4d04   if (l0234h).eq.1 --> ...
l4d07h:	      ;<------)-+
    ld a,013h	      ;	    ;4d07
    ld (l0242h),a     ;	    ;4d09   (l0242h)=013h
    ld hl,(l01cch)    ;	    ;4d0c
    ld (l0236h),hl    ;	    ;4d0f   (l0236h)=(l01cch)
    ld a,(TypeID)     ;	    ;4d12
    ld (l01ebh),a     ;	    ;4d15   (l01ebh)=(TypeID)
    call s_4e0ch      ;	    ;4d18   cd 0c 4e
    ld hl,(l0234h)    ;	    ;4d1b
    ld (l01cch),hl    ;	    ;4d1e   (l01cch)=(l0234h)
l4d21h:		;<----+
    pop af		    ;4d21 / f1
    ld (l0242h),a	    ;4d22   (l0242h)=
    ret			    ;4d25
;
l4d26h:
    ld a,(l022dh)	;4d26
    cp 2		;4d29
    jp z,l4d64h ;---;	;4d2b	if(l022dh).eq.2 --> ...
    ld hl,(l02a8h)  ;	;4d2e
    ld (l0234h),hl  ;	;4d31	(l0234h)=(l02a8h)
    ld hl,(l0273h)  ;	;4d34	hl=(l0273h)
    call s_0523h    ;	;4d37	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl  ;	;4d3a	(l0236h)=
    ld a,2	    ;	;4d3d
    ld (l0242h),a   ;	;4d3f	(l0242h)=2
    call s_4e0ch    ;	;4d42	cd 0c 4e
    ld hl,(l016fh)  ;	;4d45	hl=(l016fh)
    call s_0523h    ;	;4d48	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl  ;	;4d4b	(l0236h)=
    ld a,1	    ;	;4d4e
    ld (l0242h),a   ;	;4d50	(l0242h)=1
    call s_4e0ch    ;	;4d53	cd 0c 4e
    ld hl,(l026bh)  ;	;4d56
    ld (l0236h),hl  ;	;4d59	(l0236h)=(l026bh)
    ld a,2	    ;	;4d5c
    ld (l0242h),a   ;	;4d5e	(l0242h)=2
    call s_4e0ch    ;	;4d61	cd 0c 4e
l4d64h:		;<--+
    ld hl,(l0234h)	;4d64
    push hl		;4d67 \ Save (l0234h)
    ld hl,(l02a6h)	;4d68
    ld (l0234h),hl	;4d6b	(l0234h)=(l02a6h)
    ld hl,(l0271h)	;4d6e	hl=(l0271h)
    call s_0523h	;4d71	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl	;4d74	(l0236h)=
    ld a,2		;4d77
    ld (l0242h),a	;4d79	(l0242h)=2
    call s_4e0ch	;4d7c	cd 0c 4e
    pop hl		;4d7f / Restore (l0234h)
    inc hl		;4d80
    ld a,h		;4d81
    or l		;4d82
    jp z,l4d92h ;---;	;4d83	if (l0234h).eq.-1 --> ...
    dec hl	    ;	;4d86
    ld (l0236h),hl  ;	;4d87	(l0236h)=(l0234h)
    ld a,1	    ;	;4d8a
    ld (l0242h),a   ;	;4d8c	(l0242h)=1
    call s_4e0ch    ;	;4d8f	cd 0c 4e
l4d92h:		;<--+
    ld hl,(l016dh)	;4d92	hl=(l016dh)
    call s_0523h	;4d95	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl	;4d98	(l0236h)=
    ld a,1		;4d9b
    ld (l0242h),a	;4d9d	(l0242h)=1
    call s_4e0ch	;4da0	cd 0c 4e
    ld hl,(l0269h)	;4da3
    ld (l0236h),hl	;4da6	(l0236h)=(l0269h)
    ld a,2		;4da9
    ld (l0242h),a	;4dab	(l0242h)=2
    call s_4e0ch	;4dae	cd 0c 4e
    ld hl,(l0234h)	;4db1
    push hl		;4db4 \ Save (l0234h)
    ld hl,(l02a4h)	;4db5
    ld (l0234h),hl	;4db8	(l0234h)=(l02a4h)
    ld hl,(l026fh)	;4dbb	hl=(l026fh)
    call s_0523h	;4dbe	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl	;4dc1	(l0236h)=
    ld a,2		;4dc4
    ld (l0242h),a	;4dc6	(l0242h)=2
    call s_4e0ch	;4dc9	cd 0c 4e
    pop hl		;4dcc / Restore (l0234h)
    ld (l0236h),hl	;4dcd	(l0236h)=(l0234h)
    ld a,1		;4dd0
    ld (l0242h),a	;4dd2	(l0242h)=1
    call s_4e0ch	;4dd5	cd 0c 4e
    pop hl		;4dd8 / e1
    push hl		;4dd9 \ e5
    call ExtAttr	;4dda	Extract Attributes from the symbol table
    ld hl,(l02aah)	;4ddd
    push hl		;4de0 \ Save (l02aah)
    call s_0523h	;4de1	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl	;4de4	(l0236h)=
    ld a,2		;4de7
    ld (l0242h),a	;4de9	(l0242h)=2
    call s_4e0ch	;4dec	cd 0c 4e
    pop bc		;4def / c1
    ld hl,(l016bh)	;4df0	2a 6b 01
    ex de,hl		;4df3	eb
    call s_4917h	;4df4	cd 17 49
    call s_0523h	;4df7	(l01d3h)=hl; (l01d5h)=0; (TypeID)=0; (KindID)=1; (SizeID)=4 --> ...
    ld (l0236h),hl	;4dfa	(l0236h)=
    ld a,1		;4dfd
    ld (l0242h),a	;4dff	(l0242h)=1
    call s_4e0ch	;4e02	cd 0c 4e
    pop hl		;4e05 / e1
    call ExtAttr	;4e06	Extract Attributes from the symbol table
    jp l4cfah		;4e09	--> ...
;*
;*
;*
s_4e0ch:
    ld hl,00000h	;4e0c
    ld (l01e7h),hl	;4e0f	(l01e7h)=0
    ld hl,(l0206h)	;4e12
    ex de,hl		;4e15
    ld hl,(l0234h)	;4e16
    call cmpHL_DE	;4e19	Compare HL with DE
    jp c,l4e25h	 ;--;	;4e1c	if (l0234h) < (l0206h) --> ...
    call s_4e37h    ;	;4e1f	cd 37 4e
    ld (l01e7h),a   ;	;4e22	32 e7 01
l4e25h:		;<--+
    ld hl,(l0236h)	;4e25	2a 36 02
    call cmpHL_DE	;4e28	Compare HL with DE
    jp c,s_0ec6h	;4e2b	if HL < DE --> ...
    call s_4e37h	;4e2e	cd 37 4e
    ld (l01e8h),a	;4e31	32 e8 01
    jp s_0ec6h		;4e34	--> ...
;*
;*
;*
s_4e37h:
    push de		;4e37 \
    call ExtAttr	;4e38	Extract Attributes from the symbol table
    pop de		;4e3b /
    dec a		;4e3c
    jp nz,l4e47h ;--;	;4e3d	if (KindID).ne.1 (Constant) --> ...
    ld a,(TypeID)   ;	;4e40
    or a	    ;	;4e43
    ld a,1	    ;	;4e44	a=1
    ret z	    ;	;4e46	if (TypeID).eq.0 (INTEGER) Return
l4e47h:		;<--+
    xor a		;4e47	a=0
    ret			;4e48
;*
;*  Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
;*
s_4e49h:
    ld a,(l01ceh)	;4e49
    ld (PosStm),a	;4e4c	(PosStm)=(l01ceh)
    xor a		;4e4f
    ld (l01ceh),a	;4e50	(l01ceh)=0
    ld (l0173h),a	;4e53	(l0173h)=0
    jp s_1b32h		;4e56	--> Clear buffer ^l02b4h length 20
;*
;*
;*
s_4e59h:
    ld a,')'		;4e59 +
    call ch_chr		;4e5b + Check character (a character for check)
    call g_n_chr	;4e5e +
    jp s_4888h		;4e61	--> ...
;*
;*  Print source line
;*
s_4e64h:
l4e64h:		;<--------;
    ld hl,l0220h	  ; ;4e64
    ld (hl),0		  ; ;4e67   (l0220h)=0
    ld hl,(NumSrc)	  ; ;4e69   Get line number source file
    inc hl		  ; ;4e6c
    ld (NumSrc),hl	  ; ;4e6d   (NumSrc)=(NumSrc)+1
    ld hl,l0108h	  ; ;4e70			==???==
    ld a,' '		  ; ;4e73
    ld (l010dh),a	  ; ;4e75   (l010dh)=' '
    ld a,(l01b7h)	  ; ;4e78
    or a		  ; ;4e7b
    jp z,l4e83h ;---;	  ; ;4e7c   if (l01b7h).eq.0 --> skip error message
    call err_msg    ;	  ; ;4e7f   Error (131)
    db 131	    ;	  ; ;4e82   Premature End Of File on Input Device
l4e83h:	      ;<----+	  ;
    ld b,0		  ; ;4e83   b=0
    call s_4f46h	  ; ;4e85   if (Column).ne.0 Put cr lf to console
l4e88h:	      ;<----;	  ;
    call fget	    ;	  ; ;4e88   Get character from source file
    jp c,l4eb7h	 ;--)-;	  ; ;4e8b   if found eof --> ...
    cp lf	    ; ;	  ; ;4e8e
    jp z,l4e88h	 ;--; ;	  ; ;4e90   skip Line feed
    cp ff	    ; ;	  ; ;4e93
    jp z,l4e88h	 ;--; ;	  ; ;4e95   skip Form feed
    cp 08ch	    ; ;	  ; ;4e98
    jp z,l4e88h	 ;--+ ;	  ; ;4e9a   skip 08ch
    or a	      ;	  ; ;4e9d
    jp m,l4ebeh ;-;   ;	  ; ;4e9e   if < 0 --> ...
    push af	  ;   ;	  ; ;4ea1 \ Save chr
    push hl	  ;   ;	  ; ;4ea2 \
    ld hl,(NumSrc);   ;	  ; ;4ea3   Get line number source file
    call PrNumb	  ;   ;	  ; ;4ea6   Print number in HL as decimal number
    pop hl	  ;   ;	  ; ;4ea9 / hl=l0108h
    call puttab	  ;   ;	  ; ;4eaa   Put tab to console
    pop af	  ;   ;	  ; ;4ead / Restore chr
    jp l4ebeh  ;--;   ;	  ; ;4eae   --> ...
		  ;   ;	  ;
l4eb1h:	 ;<-------)---)-; ;
    call fget	  ;   ; ; ; ;4eb1   Get character from source file
    jp nc,l4ebeh;-;   ; ; ; ;4eb4   if not found eof --> ...
	    ;<----)---+ ; ;
l4eb7h:	    ;<----)-;	; ;
    ld a,cr	  ; ;	; ; ;4eb7
    ld (l01b7h),a ; ;	; ; ;4eb9   (l01b7h)=cr
    ld (hl),a	  ; ;	; ; ;4ebc   77
    ret		  ; ;	; ; ;4ebd
		  ; ;	; ;
l4ebeh:	    ;<----+ ;	; ;
    cp lf	    ;	; ; ;4ebe
    jp z,l4ec8h ;-; ;	; ; ;4ec0   if chr.eq_lf --> ...
    cp cr	  ; ;	; ; ;4ec3
    call nz,putchr; ;	; ; ;4ec5   if chr.ne.cr --> Put character to console
l4ec8h:	     ;<---+ ;	; ;
    or a	    ;	; ; ;4ec8
    jp p,l4ef5h	 ;--)-; ; ; ;4ec9   if chr > 0 --> ...
    ld de,l0220h    ; ; ; ; ;4ecc   11 20 02
l4ecfh:	    ;<----; ; ; ; ;
    and 07fh	  ; ; ; ; ; ;4ecf   Strip bit 7
    ld (de),a	  ; ; ; ; ; ;4ed1   (de)=
    inc de	  ; ; ; ; ; ;4ed2   de=de+1
    call fget	  ; ; ; ; ; ;4ed3   Get character from source file
    jp c,l4eb7h ;-)-+ ; ; ; ;4ed6   if found eof --> ...
    cp lf	  ;   ; ; ; ;4ed9
    call nz,putchr;   ; ; ; ;4edb   if chr.ne_lf Put character to console
    cp _tab	  ;   ; ; ; ;4ede
    jp z,l4ee7h ;-)-; ; ; ; ;4ee0   if chr.eq."_tab" --> ...
    or a	  ; ; ; ; ; ;4ee3
    jp m,l4ecfh ;-+ ; ; ; ; ;4ee4   if chr Digit? --> ...
l4ee7h:	   ;<-------+ ; ; ;
    push af	      ; ; ; ;4ee7 \ f5
    dec de	      ; ; ; ;4ee8   de=de-1
    ld a,(de)	      ; ; ; ;4ee9   1a
    or 080h	      ; ; ; ;4eea   Set high bit (10000000b)
    ld (de),a	      ; ; ; ;4eec   12
    pop af	      ; ; ; ;4eed / f1
    and 07fh	      ; ; ; ;4eee   Strip bit 7
    cp tab	      ; ; ; ;4ef0
    jp z,l4eb1h	  ;---)-; ; ;4ef2   if eq tab --> Get next character
l4ef5h:	      ;<------+ ; ;
    cp lf		; ; ;4ef5
    jp z,l4eb1h	  ;-----; ; ;4ef7   if eq lf --> Get next character
    cp tab		; ; ;4efa
    jp nz,l4f10h ;----; ; ; ;4efc   if ne tab --> ...
l4effh:	     ;<-----; ; ; ;
      ld a,' '	    ; ; ; ; ;4eff
      ld (hl),a	    ; ; ; ; ;4f01
      inc hl	    ; ; ; ; ;4f02   hl=hl+1
      inc b	    ; ; ; ; ;4f03   b=b+1
      ld a,b	    ; ; ; ; ;4f04
      cp 80	    ; ; ; ; ;4f05
      ret nc	    ; ; ; ; ;4f07   if (b >= 80) Return
      and 007h	    ; ; ; ; ;4f08   Test tab stop (00000111b)
    jp nz,l4effh ;--+ ; ; ; ;4f0a   Nope
    jp l4eb1h  ;------)-; ; ;4f0d   --> Get next character
		      ; ; ;
l4f10h:	      ;<------+ ; ;
    ld (hl),a		; ; ;4f10
    cp cr		; ; ;4f11
    jp nz,l4f55h ;----; ; ; ;4f13   if (char.ne.cr) --> ...
    dec b	      ; ; ; ;4f16   b=b-1
    inc b	      ; ; ; ;4f17   b=b+1
    jp z,l4e64h ;-----)-)-+ ;4f18   if (b.eq.0) --> Print source line
		      ; ; 
l4f1bh:	   ;<---------)-)-+
    ld (l0150h),a     ; ; ; ;4f1b   (l0150h)=a
    ret		      ; ; ; ;4f1e
;*                    ; ; ;
;*  Put tab to console or printer
;*                    ; ; ;
puttab:               ; ; ;
    ld a,tab	      ; ; ; ;4f1f	a=tab
;*                    ; ; ;
;*  Put character in Accu to console or printer
;*                    ; ; ;
putchr:               ; ; ;
    push af	      ; ; ; ;4f21 \ Save character
    ld a,(conflg)     ; ; ; ;4f22	Test flag
    or a	      ; ; ; ;4f25
    jp nz,l4f2dh ;--; ; ; ; ;4f26	.. nope
    pop af	    ; ; ; ; ;4f29 / Restore character
    jp s_4f62h	    ; ; ; ; ;4f2a	--> Put character in Accu to list considering tabs
		    ; ; ; ;
l4f2dh:		 ;<-+ ; ; ;
    ld a,(enaLST)     ; ; ; ;4f2d	Test list enabled
    or a	      ; ; ; ;4f30
    jp z,l4f42h	 ;--; ; ; ; ;4f31	if(enaLST).eq.0 --> Put character to console
    pop af	    ; ; ; ; ;4f34 / Restore character
    push af	    ; ; ; ; ;4f35 \
    call s_4f62h    ; ; ; ; ;4f36	Put character in Accu to list considering tabs
    ld a,(l5a66h)   ; ; ; ; ;4f39	a=Drive *n*
    inc a	    ; ; ; ; ;4f3c
    jp nz,l4f42h ;--; ; ; ; ;4f3d	if (Drive).ne.1 --> Put character to console
    pop af	    ; ; ; ; ;4f40 / Restore character
    ret		    ; ; ; ; ;4f41
		    ; ; ; ;
l4f42h:	    ;<------+ ; ; ;
;*                    ; ; ;
;*  Put character to console
;*                    ; ; ;
    pop af	      ; ; ; ;4f42 + Get character back
    jp conout	      ; ; ; ;4f43 + Put character in Accu to console
;*                    ; ; ;
;*  if (Column).ne.0 Put cr lf to console
;*                    ; ; ;
s_4f46h:              ; ; ;
    ld a,(Column)     ; ; ; ;4f46 +
    or a	      ; ; ; ;4f49 +
    ret z	      ; ; ; ;4f4a + if (Column).eq.0 Return
;*                    ; ; ;
;*  Put crlf to console ; ;
;*                    ; ; ;
p_crlf:               ; ; ;
    ld a,cr	      ; ; ; ;4f4b +
    call putchr	      ; ; ; ;4f4d + Put character to console
    ld a,lf	      ; ; ; ;4f50 +
    jp putchr	      ; ; ; ;4f52 + Put character to console
		      ; ; ;
l4f55h:	     ;<-------+ ; ;
    inc hl	     	; ; ;4f55   hl=hl+1
    inc b	     	; ; ;4f56   04
    ld a,79	     	; ; ;4f57
    cp b	     	; ; ;4f59   b8
    jp nc,l4eb1h ;------+ ; ;4f5a   if a >= b --> Get next character
    ld a,cr	     	  ; ;4f5d   a=cr
    jp l4f1bh  ;----------+ ;4f5f   --> ...
;*
;*  Put character in Accu to list considering tabs
;*    ENTRY Reg a - chr
;*
s_4f62h:
    push af		  ;4f62 \ Save chr
    and 07fh		  ;4f63	  Reset bit 7
    push hl		  ;4f65 \ Save hl
    ld hl,Column	  ;4f66
    cp tab		  ;4f69
    jp nz,l4f7eh  ;-----; ;4f6b	  if chr.ne_tab --> ...
l4f6eh:		;<--;	;
      inc (hl)	    ;	; ;4f6e	  (Column)=(Column)+1
      ld a,(hl)	    ;	; ;4f6f	  Load chr
      and 007h	    ;	; ;4f70	  Test tab stop
    jp nz,l4f6eh ;--+	; ;4f72	  Nope
    dec (hl)		; ;4f75	  (Column)=(Column)-1
    ld a,tab		; ;4f76	  chr=tab
l4f78h:	     ;<-------; ;
    inc (hl)	      ; ; ;4f78	  (Column)=(Column)+1
l4f79h:	       ;<---; ; ;
    pop hl	    ; ; ; ;4f79 / Restore hl
    pop af	    ; ; ; ;4f7a / Restore chr
    jp lput	    ; ; ; ;4f7b	  --> Put character to list device
		    ; ; ;
l4f7eh:	      ;<----)-)-+
    cp lf	    ; ;	  ;4f7e	  Test lf
    jp nz,l4f88h;-; ; ;	  ;4f80	  if chr.ne_lf --> ...
    ld (hl),0	  ; ; ;	  ;4f83	  (Column)=0
    jp l4f79h ;---)-; ;	  ;4f85	  --> ...
		  ; ; ;
l4f88h:	      ;<--+ ; ;
    cp ' '	    ; ;	  ;4f88	  Test blank
    jp c,l4f79h ;---+ ;	  ;4f8a	  if chr < ' ' --> ...
    jp l4f78h ;-------+	  ;4f8d	  --> ...
;
;   Get character from selected source file
;     Carry set indicates end of file
;
fget:
    ld a,(incflg)	;4f90	Test source state
    or a		;4f93
    jp z,l4fa2h	 ;--;	;4f94	if (incflg).eq.0 Get character
    call s_669ah    ;	;4f97	ret    (?Get character from include file?)
    ret nc	    ;	;4f9a	ok
    call s_669ah    ;	;4f9b	ret    (?Close include file?)
    xor a	    ;	;4f9e	a=0
    ld (incflg),a   ;	;4f9f	(incflg)=0 Disable include file
l4fa2h:	      ;<----+
    call sget		;4fa2	Get character from source file
    ret			;4fa5
;*
;*  Put Attributes in Symbol table
;*
PutAttr:

IFT DBG
    call ptest2
ENDIF

    ld hl,SizeID	;4fa6
    ld c,(hl)		;4fa9	c=(SizeID)
    ld a,(SegmID)	;4faa	Load Flag Address mode
    rrca		;4fad	Put 0 bit from (SegmID) in 7 bits
    or (hl)		;4fae	Add to reg A bits from (SizeID)
    ld hl,(l01cch)	;4faf
    ld (hl),a		;4fb2	Put reg A into memory to address stored in (l01cch)
    ld a,(ScopeID)	;4fb3
    rrca		;4fb6
    rrca		;4fb7	Put 0 & 1 bits from (ScopeID) in 7 & 6 bits
    ld b,a		;4fb8	Save it to reg B
    ld a,(TypeID)	;4fb9	Load value type variable
    rlca		;4fbc
    rlca		;4fbd
    rlca		;4fbe	Move 3 lower bits from (TypeID) to bits 7-5
    or b		;4fbf	Add to reg A bits from reg B generated from (SegmID
    ex de,hl		;4fc0			de=(l01cch)
    ld hl,KindID	;4fc1
    or (hl)		;4fc4	Add to reg A bits from (KindID)
    ex de,hl		;4fc5	hl=(l01cch)
    dec hl		;4fc6	hl=(l01cch)-1
    ld (hl),a		;4fc7	Put reg A into memory to address stored in (l01cch)-1
    dec hl		;4fc8	hl=(l01cfh)-2
    ex de,hl		;4fc9			de=(l01cch)-2
    push de		;4fca \ Save (l01cch)-2
    ld hl,(DataID)	;4fcb	hl=(DataID)
    ex de,hl		;4fce	hl=(l01cch)-2	de=(DataID)
    ld (hl),d		;4fcf
    dec hl		;4fd0	hl=(l01cch)-3
    ld (hl),e		;4fd1	Put word (DataID) into memory to address stored in (l01cch)-2
    dec hl		;4fd2	hl=(l01cch)-4
    ex de,hl		;4fd3			de=(l01cch)-4
    ld hl,(EntryID)	;4fd4	hl=(EntryID)
    ex de,hl		;4fd7	hl=(l01cch)-4	de=(EntryID)
    ld (hl),d		;4fd8
    dec hl		;4fd9	hl=(l01cch)-5
    ld (hl),e		;4fda	Put word (EntryID) into memory to address stored in (l01cch)-4

;*  Put Name to memory

    dec hl		;4fdb	hl=(l01cch)-6 Destination address
    ld de,l01d6h	;4fdc	de=Pointer to start the name
;				c=(SizeID) Length of name
l4fdfh:		;<--;
      ld a,(de)	    ;	;4fdf
      ld (hl),a	    ;	;4fe0	(hl)=(de)
      dec hl	    ;	;4fe1	hl=hl-1
      dec de	    ;	;4fe2	de=de-1
      dec c	    ;	;4fe3	c=c-1
    jp nz,l4fdfh ;--+	;4fe4	if c.ne.0 Copy next character
;*
;*  Calculation storage size variable according to the type
;*
    ld a,(TypeID)	;4fe7
    cp 4		;4fea
    jp z,l4ff7h	 ;----; ;4fec	if (TypeID).eq.4 (INTEGER*4) --> ...
    inc a	      ; ;4fef	a=(TypeID)+1
    rlca	      ; ;4ff0	Multiply by 2
    or a	      ; ;4ff1	for compatibility with z80
    jp po,l4ff7h ;-;  ; ;4ff2	if (TypeID).ne.3 (Byte) --> ...
    ld a,1	   ;  ; ;4ff5	a=1
l4ff7h:	      ;<---+<-+
    ld (l02aah),a	;4ff7	(l02aah)=Storage size
    ld a,(KindID)	;4ffa
    cp 4		;4ffd
    pop de		;4fff / de=(l01cch)-2
    ret nz		;5000	if (KindID).ne.4 (Array) Return
    ld hl,(l021dh)	;5001	hl=(l021dh)
    ex de,hl		;5004	hl=(l01cch)-2	de=(l021dh)
    ld (hl),d		;5005
    dec hl		;5006	hl=(l01cch)-3
    ld (hl),e		;5007	Put word (l021dh) into memory to address stored in (l01cch)-2
    ld hl,(DataID)	;5008	hl=(DataID)
    ex de,hl		;500b	hl=(l021dh)	de=(DataID)
    dec hl		;500c
    dec hl		;500d	hl=(l021dh)-2
    ld (hl),d		;500e
    dec hl		;500f	hl=(l021dh)-3
    ld (hl),e		;5010	Put word (DataID) into memory to address stored in (l021dh)-2
    ret			;5011
;*
;*  ENTRY Reg a - Type_statement
;*    0-BLOCkdata	4-COMMon      0ah-BACKspace
;*	FUNCtion	5-EQUIvalence	  ENCOde(
;*	PROGram		6-DATA		  ENDFile
;*	SUBRoutine	8-?		  DECOde
;*    1-DIMEnsion	9-ASSIgn	  do
;*	DOUBleprecision	  CALL		  PAUSe
;*	EXTErnal	  CONTinue	  READ(
;*	IMPLicit	  FORMat	  REWInd
;*	INTEger		  GOTO		  STOP
;*	LOGIcal		  IF(		  WRITe(
;*	BYTE		  INCLude     0bh-END
;*	REAL		  RETUrn
;*
s_5012h:
    ld b,a		;5012	Save Type_statement
    ld de,PrInclude	;5013	Address program Processing INCLUDE
    ld hl,(CurAdr)	;5016	Address current program Processing statement
    call cmpHL_DE	;5019
    ld a,b		;501c	Restore Type_statement
    ret z		;501d	if (CurAdr).eq.PrInclude Return
 ;
    push af		;501e \ Save Type_statement
    sub 2		;501f
    jp m,l5033h	 ;--;	;5021	if Type_statement < 2 --> ...
    ld hl,l024dh    ;	;5024
    ld a,(hl)	    ;	;5027
    or a	    ;	;5028
    jp nz,l5033h ;--;	;5029	if (l024dh).ne.0 --> ...
    inc (hl)	    ;	;502c	(l024dh)=(l024dh)+1
    call s_354dh    ;	;502d	Build standard fortran header
    call s_4a19h    ;	;5030	Assign name "$MAIN" and put it to REL file
l5033h:		;<--+
    pop af		;5033 / Restore Type_statement
    ld hl,(l01cch)	;5034
    ld (l0279h),hl	;5037	(l0279h)=(l01cch)
    ld hl,l0277h	;503a	21 77 02
    push hl		;503d \
    ld (hl),a		;503e	(l0277h)=Type_statement
    cp 0ah		;503f
    jp c,l5048h ;---;	;5041	if Type_statement < 0ah --> ...
    dec (hl)	    ;	;5044	(l0277h)=(l0277h)-1
    call s_3169h    ;	;5045	cd 69 31
l5048h:		;<--+
    ld hl,(CurAdr)	;5048	Address current program Processing statement
    ld de,PrFormat	;504b	Address program Processing FORMAT
    call cmpHL_DE	;504e
    pop hl		;5051 / hl=l0277h
    ret z		;5052	if (CurAdr).eq.PrFormat Return
    ld a,(hl)		;5053
    ld hl,l0261h	;5054
    cp (hl)		;5057
    jp c,err127		;5058	if (l0277) < (l0261h) --> Error (127) Statement Out of Sequence
    ld hl,(l0263h)	;505b
    ld a,h		;505e
    or l		;505f
    jp nz,l507dh ;--;	;5060	if (l0263h).ne.0   --> ...
    ld a,(l0277h)   ;	;5063
    cp 0ah	    ;	;5066
    jp z,l507dh	 ;--;	;5068	if (l0277h).eq.0ah --> ...
    ld a,(l021fh)   ;	;506b
    or a	    ;	;506e
    jp nz,l507dh ;--;	;506f	if (l021fh).ne.0   --> ...
    ld a,(l0299h)   ;	;5072
    or a	    ;	;5075
    jp z,l507dh ;---;	;5076	if (l0299h).eq.0 --> skip error message
    call err_msg    ;	;5079	Warning (21)
    db 21	    ;	;507c	No Path to this Statement
l507dh:	      ;<----+
    ld de,PrGoto	;507d	Address program Processing GOTO
    ld hl,(CurAdr)	;5080	Address current program Processing statement
    call cmpHL_DE	;5083
    jp z,l50a7h	 ;--;	;5086	if (CurAdr).eq.PrGoto --> ...
    ld a,(l021fh)   ;	;5089
    or a	    ;	;508c
    jp z,l50a7h	 ;--;	;508d	if (l021fh).eq.0 --> ...
    ld hl,(CurAdr)  ;	;5090	Address current program Processing statement
    push hl	    ;	;5093 \ Save value
    ld hl,00000h    ;	;5094	hl=0
    ld (CurAdr),hl  ;	;5097	(CurAdr)=0 Clear variable
    call s_3169h    ;	;509a	cd 69 31
    pop hl	    ;	;509d / Restore value
    ld (CurAdr),hl  ;	;509e	(CurAdr)=(CurAdr)
    call s_3725h    ;	;50a1	cd 25 37
    call s_37c9h    ;	;50a4	Put 'JP Z,word' & word=0000 to REL file
l50a7h:		;<--+
    ld a,(l0277h)		;50a7
    cp 6			;50aa
    jp c,l5120h	    ;-------;	;50ac	if (l0277h) < 6	 --> ...
    ld a,(l0261h)	    ;	;50af
    cp 6		    ;	;50b2
    jp nc,l5115h      ;---; ;	;50b4	if (l0261h) >= 6 --> ...
    call s_59eeh	  ; ;	;50b7	Extract Attributes from the symbol table, entry (l031eh)
l50bah:		    ;<--; ; ;
    jp c,l50d2h	 ;----; ; ; ;	;50ba	if carry set (Found end of Symbol table) --> ...
    cp 6	      ; ; ; ;	;50bd
    jp nz,l50cch ;--; ; ; ; ;	;50bf	if (KindID).ne.6 (Common) --> ...
    ld bc,5	    ; ; ; ; ;	;50c2	REL type - Define COMMON size
    ld hl,(DataID)  ; ; ; ; ;	;50c5
    ex de,hl	    ; ; ; ; ;	;50c8
    call RELITEM    ; ; ; ; ;	;50c9	Give common size
l50cch:		;<--+ ; ; ; ;		Calculate address next symbol in the Symbols table;
    call s_59f4h      ; ; ; ;	;50cc	if (l01cch).<=.(l0206h) Extract Attributes from symbol table
    jp l50bah	   ;--)-+ ; ;	;50cf	--> ...
		      ;	  ; ;
l50d2h:		;<----+	  ; ;
    call s_59eeh	  ; ;	;50d2	Extract Attributes from the symbol table, entry (l031eh)
l50d5h:	      ;<--------; ; ;
    jp c,l50f8h	 ;----; ; ; ;	;50d5	if carry set (Found end of Symbol table) --> ...
    cp 3	      ; ; ; ;	;50d8
    jp c,l50f2h	 ;--; ; ; ; ;	;50da	if (KindID).<. 3 (Variable) --> ...
    cp 5	    ; ; ; ; ;	;50dd
    jp nc,l50f2h ;--; ; ; ; ;	;50df	if (KindID).>=. 5 (Routine) --> ...
    ld hl,(l01cch)  ; ; ; ; ;	;50e2
    ex de,hl	    ; ; ; ; ;	;50e5
    ld hl,(EntryID) ; ; ; ; ;	;50e6
    call cmpHL_DE   ; ; ; ; ;	;50e9	Compare HL with DE
    jp nz,l5154h  ;-)-)-)-)-)-; ;50ec	if (EntryID).ne.(l01cch) --> ...
    call s_0cf8h    ; ; ; ; ; ; ;50ef	cd f8 0c
l50f2h:		;<--+ ; ; ; ; ;		Calculate address next symbol in the Symbols table;
    call s_59f4h      ; ; ; ; ; ;50f2	if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
    jp l50d5h  ;------)-+ ; ; ; ;50f5	--> ...
		      ;	  ; ; ;
l50f8h:		;<----+	  ; ; ;
    call s_30c0h	  ; ; ; ;50f8	cd c0 30
    ld hl,(l0267h)	  ; ; ; ;50fb
    ld a,h		  ; ; ; ;50fe
    or l		  ; ; ; ;50ff
    jp z,l5115h	    ;-----; ; ; ;5100	if (l0267h).eq.0 --> ...
    ld a,(SubrFlg)	  ; ; ; ;5103
    or a		  ; ; ; ;5106
    jp nz,l5115h    ;-----; ; ; ;5107	if (SubrFlg).ne.0 (Subroutine) --> ...
    call ExtAttr	  ; ; ; ;510a	Extract Attributes from the symbol table
    ld a,3		  ; ; ; ;510d
    ld (KindID),a	  ; ; ; ;510f	(KindID)=3 (Variable)
    call PutAttr	  ; ; ; ;5112	Put Attributes in Symbol table
l5115h:		 ;<-------+ ; ;
    ld a,(l0277h)	    ; ; ;5115
    cp 8		    ; ; ;5118
    jp nz,l512dh ;--;	    ; ; ;511a	if (l0277h).ne.8 --> ...
    call s_37ceh    ;	    ; ; ;511d	Put 'JP word' & word=0000 to REL file
l5120h:	      ;<----)-; <---+ ;
    ld hl,(l0279h)  ; ;	      ; ;5120	hl=(l0279h)
    call ExtAttr    ; ;	      ; ;5123	Extract Attributes from the symbol table
    ld a,(l0277h)   ; ;	      ; ;5126
    ld (l0261h),a   ; ;	      ; ;5129	(l0261h)=(l0277h)
    ret		    ; ;	      ; ;512c
		    ; ;	      ;
l512dh:		;<--+ ;	      ;
    ld hl,(l0167h)    ;	      ; ;512d
    ld a,h	      ;	      ; ;5130
    or l	      ;	      ; ;5131
    jp z,l5120h	  ;---;	      ; ;5132	if (l0167h).eq.0 --> ...
    ld a,(l021fh)     ;	      ; ;5135
    or a	      ;	      ; ;5138
    jp nz,l5120h  ;---;	      ; ;5139	if (l021fh).ne.0 --> ...
    call s_3169h      ;	      ; ;513c	cd 69 31
    ld hl,(l0167h)    ;	      ; ;513f
    ld (DataID),hl    ;	      ; ;5142	(DataID)=(l0167h)
    xor a	      ;	      ; ;5145
    ld (TypeID),a     ;	      ; ;5146	(TypeID)=0 (INTEGER)
    ld h,a	      ;	      ; ;5149
    ld l,a	      ;	      ; ;514a	hl=0
    ld (l0167h),hl    ;	      ; ;514b	(l0167h)=0
    call s_49ceh      ;	      ; ;514e	cd ce 49
    jp l5120h	  ;---+	      ; ;5151	--> ...
			      ;
l5154h:		    ;<--------+
    ld a,(ScopeID)	;5154
    or a		;5157	if (ScopeID).ne.0
    jp nz,l50f2h	;5158	 --> Calculate address next symbol in the Symbols table...
    ld hl,(l01cch)	;515b
    ld (l01c2h),hl	;515e	(l01c2h)=(l01cch)
    ld hl,00000h	;5161
    ld (l028dh),hl	;5164	(l028dh)=0
    xor a		;5167
    ld (l0297h),a	;5168	(l0297h)=0
l516bh:		  ;<--;
    ld hl,(l028dh)    ; ;516b
    ex de,hl	      ; ;516e
    ld hl,(DataID)    ; ;516f
    push hl	      ; ;5172 \ Save (DataID)
    call subHL_DE     ; ;5173
    ld a,h	      ; ;5176
    or a	      ; ;5177
    jp m,l5184h ;---; ; ;5178	if (DataID) < (l028eh)	--> ...
    or l	    ; ; ;517b
    jp z,l5184h ;---; ; ;517c	if (DataID).eq.(l028eh) --> ...
    pop hl	    ; ; ;517f / Restore (DataID)
    push hl	    ; ; ;5180 \		    --------;
    ld (l028dh),hl  ; ; ;5181	(l028dh)=(DataID)   ;
l5184h:		;<--+ ;				    ;
    call s_5a24h      ; ;5184	cd 24 5a	    ;
    pop de	      ; ;5187 / de=(DataID) <-------+
    call subHL_DE     ; ;5188	hl=hl-de
    ld a,(l0297h)     ; ;518b
    or a	      ; ;518e
    jp z,l51a6h ;---; ; ;518f	if (l0297h).eq.0 --> ...
    ex de,hl	    ; ; ;5192	eb
    ld hl,(l028bh)  ; ; ;5193	2a 8b 02
    ex de,hl	    ; ; ;5196	eb
    push hl	    ; ; ;5197 \ ------------;
    call subHL_DE   ; ; ;5198	hl=hl-de    ;
    pop de	    ; ; ;519b / <-----------+
    ld a,h	    ; ; ;519c	7c
    or a	    ; ; ;519d	b7
    jp m,l51aeh ;-; ; ; ;519e	if < 0 --> ...
    or l	  ; ; ; ;51a1	b5
    jp z,l51aeh ;-; ; ; ;51a2	ca ae 51
    ex de,hl	  ; ; ; ;51a5	eb
l51a6h:	    ;<----)-+ ;
    ld a,1	  ;   ; ;51a6
    ld (l0297h),a ;   ; ;51a8	(l0297h)=1
    ld (l028bh),hl;   ; ;51ab	(l028bh)=
l51aeh:	      ;<--+   ;
    call s_16b9h      ; ;51ae	{call ExtAttr(EntryID); test hl=(l01c2h)-(EntryID)}
    jp nz,l516bh  ;---+ ;51b1	if (l01c2h).ne.(EntryID) --> ...
    ld hl,(l028dh)	;51b4
    ex de,hl		;51b7
    ld hl,(DatSiz)	;51b8	Load Data size
    add hl,de		;51bb
    ld (l028dh),hl	;51bc	(l028dh)=(DatSiz)+(l028dh)
    ex de,hl		;51bf
    ld hl,(l028bh)	;51c0
    add hl,de		;51c3
    ld (DatSiz),hl	;51c4	(DatSiz)=(l028bh)+(l028dh)
l51c7h:	    ;<------;
    ld a,2	    ;	;51c7
    ld (ScopeID),a  ;	;51c9	(ScopeID)=2
    ld hl,(DataID)  ;	;51cc
    ex de,hl	    ;	;51cf
    ld hl,(l028dh)  ;	;51d0
    call subHL_DE   ;	;51d3	hl=hl-de
    ld (DataID),hl  ;	;51d6	(DataID)=(l028dh)-(DataID)
    call PutAttr    ;	;51d9	Put Attributes in Symbol table
    call s_16b9h    ;	;51dc	{call ExtAttr(EntryID); test hl=(l01c2h)-(EntryID)}
    jp nz,l51c7h ;--+	;51df	if (l01c2h).ne.(EntryID) --> ...
    jp l50f2h		;51e2	--> Calculate address next symbol in the Symbols table ...
;
err127:
    call err_msg	;51e5	Error (127)
    db 127		;51e8	Statement Out of Sequence
;
;
;
s_51e9h:
    ld a,0ch		    ;51e9   a=0ch
    call s_55e1h	    ;51eb   cd e1 55
    xor a		    ;51ee
    ld (l01c8h),a	    ;51ef   (l01c8h)=0

l51f2h:		;<------;
    ld a,(l01c8h)	;   ;51f2
    add a,010h		;   ;51f5
    ld (l01c8h),a	;   ;51f7   (l01c8h)=(l01c8h)+16
    sbc a,a		;   ;51fa   a=a-a-Carry
    push af		;   ;51fb \
    pop bc		;   ;51fc / c=flags register
    ld a,c		;   ;51fd   79
    and 4		;   ;51fe   Test bit 2 00000100b
    ret nz		;   ;5200   if c.ne.0 Return
l5201h:	    ;<------;	;
    ld hl,(l0214h)  ;	;   ;5201   2a 14 02
    dec hl	    ;	;   ;5204
    dec hl	    ;	;   ;5205
    dec hl	    ;	;   ;5206
    dec hl	    ;	;   ;5207   hl=hl-4
    ld a,(hl)	    ;	;   ;5208   7e
    and 01fh	    ;	;   ;5209   00011111b
    ld e,a	    ;	;   ;520b
    ld d,0	    ;	;   ;520c   de=a
    ld hl,l04cah    ;	;   ;520e   21 ca 04
    add hl,de	    ;	;   ;5211   19
    ld a,(hl)	    ;	;   ;5212   7e
    ld hl,l01c8h    ;	;   ;5213   21 c8 01
    add a,(hl)	    ;	;   ;5216   86
    ld hl,l01b5h    ;	;   ;5217
    ld (hl),a	    ;	;   ;521a   (l01b5h)=a
    ld a,(l01b4h)   ;	;   ;521b
    cp (hl)	    ;	;   ;521e
    jp nc,l5257h ;--)-; ;   ;521f   if (l01b5h) >= (l01b4h)--> ...
l5222h:	     ;<-----)-)-)-;
    ld hl,(l0214h)  ; ; ; ; ;5222
    dec hl	    ; ; ; ; ;5225
    dec hl	    ; ; ; ; ;5226
    dec hl	    ; ; ; ; ;5227
    dec hl	    ; ; ; ; ;5228
    ld (l0214h),hl  ; ; ; ; ;5229   (l0214h)=(l0214h)-4
l522ch:		    ; ; ; ;
    call s_55ebh    ; ; ; ; ;522c   cd eb 55
    ld hl,l01c8h    ; ; ; ; ;522f
    add a,(hl)	    ; ; ; ; ;5232
    ld (l01b4h),a   ; ; ; ; ;5233   (l01b4h)=(l01c8h)+a
    ld a,b	    ; ; ; ; ;5236
    cp 0ch	    ; ; ; ; ;5237
    jp z,l51f2h ;---)-)-+ ; ;5239   if b.eq.0ch --> ...
    or a	    ; ;	  ; ;523c
    jp nz,l5201h ;--; ;	  ; ;523d   if b.ne.0 --> ...
    ld hl,l01c8h    ; ;	  ; ;5240
    ld a,(hl)	    ; ;	  ; ;5243
    sub 010h	    ; ;	  ; ;5244
    ld (hl),a	    ; ;	  ; ;5246   (l01c8h)=(l01c8h)-16
    ld hl,(l01a4h)  ; ;	  ; ;5247
    ex de,hl	    ; ;	  ; ;524a
    ld hl,(l0214h)  ; ;	  ; ;524b
    call cmpHL_DE   ; ;	  ; ;524e   Compare HL with DE
    jp nz,l5201h ;--+ ;	  ; ;5251   if (l0214h).ne.(l01a4h) --> ...
    ld (l01b5h),a     ;	  ; ;5254   (l01b5h)=
l5257h:		 ;<---+	  ;
    call s_5537h	  ; ;5257   cd 37 55
    ld a,(l0242h)	  ; ;525a
    cp 5		  ; ;525d
    jp c,l5291h	 ;----;	  ; ;525f   if (l0242h) < 5 --> ...
    cp 0bh	      ;	  ; ;5262
    jp nc,l52b3h ;--; ;	  ; ;5264   if (l0242h) >= 11 --> ...
    ld a,(l022fh)   ; ;	  ; ;5267
    or a	    ; ;	  ; ;526a
    jp z,l527bh ;-; ; ;	  ; ;526b   if (l022fh).eq.0 --> ...
    call s_55bch  ; ; ;	  ; ;526e   {(l0234h)<->(l0236h); (l01eah)<->(l01eah); (l01e7h)<->(l01e8h)}
    call s_5564h  ; ; ;	  ; ;5271   cd 64 55
    xor a	  ; ; ;	  ; ;5274   a=0
    call s_5591h  ; ; ;	  ; ;5275   cd 91 55
    call s_5537h  ; ; ;	  ; ;5278   cd 37 55
l527bh:	       ;<-+ ; ;	  ;
    ld a,(l0242h)   ; ;	  ; ;527b
    cp 6	    ; ;	  ; ;527e
    jp z,l52b3h	 ;--; ;	  ; ;5280   if (l0242h).eq.6 --> ...
    ld a,(l022eh)   ; ;	  ; ;5283
    or a	    ; ;	  ; ;5286
    jp z,l52b3h	 ;--; ;	  ; ;5287   if (l022eh).eq.0 --> ...
    call s_5572h    ; ;	  ; ;528a   cd 72 55
    xor a	    ; ;	  ; ;528d
    ld (l022eh),a   ; ;	  ; ;528e   (l022eh)=0
l5291h:	      ;<----)-+	  ;
    ld a,(l0242h)   ;	  ; ;5291
    cp 3	    ;	  ; ;5294
    jp nz,l52b3h ;--;	  ; ;5296   if (l0242h).ne.3 --> ...
    ld hl,(l0214h)  ;	  ; ;5299
    push hl	    ;	  ; ;529c \ Save (l0214h)
    inc hl	    ;	  ; ;529d
    inc hl	    ;	  ; ;529e
    inc hl	    ;	  ; ;529f
    inc hl	    ;	  ; ;52a0
    ld a,080h	    ;	  ; ;52a1
    xor (hl)	    ;	  ; ;52a3
    ld (hl),a	    ;	  ; ;52a4   ((l0214h)+4)=(l0242h).xor.10000000b
    ld hl,(l0234h)  ;	  ; ;52a5
    ld a,h	    ;	  ; ;52a8
    or l	    ;	  ; ;52a9
    pop hl	    ;	  ; ;52aa   Restore (l0214h)
    jp z,l5336h	    ;	  ; ;52ab   if (l0234h).eq.0 --> ...
    dec (hl)	    ;	  ; ;52ae
    dec (hl)	    ;	  ; ;52af   (l0214h)=(l0214h)-2
    call s_5537h    ;	  ; ;52b0   cd 37 55
l52b3h:		;<--+	  ;
    ld a,(l01b5h)	  ; ;52b3
    ld hl,l01b4h	  ; ;52b6
    cp (hl)		  ; ;52b9
    jp z,l5222h	 ;--------+ ;52ba   if (l01b5h).eq.(l01b4h) --> ...
    ld a,(l0242h)	    ;52bd
    or a		    ;52c0
    jp z,l536bh		    ;52c1   if (l0242h).eq.0  --> ...
    cp 3		    ;52c4
    jp c,l5471h		    ;52c6   if (l0242h) < 3   --> ...
    cp 8		    ;52c9
    jp c,l52d3h ;---;	    ;52cb   if (l0242h) < 8   --> ...
    cp 0bh	    ;	    ;52ce
    jp c,l5471h	    ;	    ;52d0   if (l0242h) < 0bh --> ...
l52d3h:		;<--+
    ld a,(l0242h)	    ;52d3
    dec a		    ;52d6   a=a-1
    jp z,l53d2h		    ;52d7   if (l0242h).eq.1   --> ...
    sub 4		    ;52da   a=a-4
    jp c,l5404h		    ;52dc   if (l0242h) < 5    --> { (l022eh)=(l022eh).xor.(l022fh) --> l532dh }
    sub 2		    ;52df   a=a-2
    jp c,l532dh		    ;52e1   if (l0242h) < 7    --> ...
    jp z,l540fh		    ;52e4   if (l0242h).eq.7   --> ...
    dec a		    ;52e7   a=a-1
    jp z,l532dh		    ;52e8   if (l0242h).eq.8   --> ...
    sub 3		    ;52eb   a=a-3
    jp c,l532dh		    ;52ed   if (l0242h) < 11   --> ...
    jp z,l5415h		    ;52f0   if (l0242h).eq.11  --> ...
    ld a,(l022eh)	    ;52f3
    or a		    ;52f6
    jp z,l5308h ;---;	    ;52f7   if (l022eh).eq.0   --> ...
    ld a,(l0242h)   ;	    ;52fa   3a 42 02
    ld e,a	    ;	    ;52fd
    ld d,0	    ;	    ;52fe   de=a
    ld hl,l04d0h    ;	    ;5300   hl= point to table
    add hl,de	    ;	    ;5303   19
    ld a,(hl)	    ;	    ;5304   7e
    ld (l0242h),a   ;	    ;5305   (l0242h)=
l5308h:		;<--+
    ld a,(l022eh)	    ;5308   3a 2e 02
    ld hl,l022fh	    ;530b   21 2f 02
    xor (hl)		    ;530e   ae
    xor 1		    ;530f   ee 01
    add a,a		    ;5311   87
    inc a		    ;5312   3c
    ld b,a		    ;5313   47
    xor a		    ;5314
    ld (l022eh),a	    ;5315   (l022eh)=0
    ld a,(l0242h)	    ;5318
    push af		    ;531b \ Save (l0242h) ------+
    ld a,b		    ;531c   78			;
    ld (l0242h),a	    ;531d   (l0242h)=		;
    call s_0ec6h	    ;5320   cd c6 0e		;
    ld hl,(l0234h)	    ;5323			;
    ld (l0236h),hl	    ;5326   (l0236h)=(l0234h)	;
    pop af		    ;5329 /		  <-----+
    ld (l0242h),a	    ;532a   Restore (l0242h)
l532dh:
    call s_0ec6h	    ;532d   cd c6 0e
    ld a,(l022eh)	    ;5330   a=(l022eh)
    call s_5591h	    ;5333   cd 91 55
l5336h:
    ld hl,(HeapPtr)	    ;5336
    dec hl		    ;5339
    dec hl		    ;533a
    dec hl		    ;533b
    dec hl		    ;533c
    ld (HeapPtr),hl	    ;533d   (HeapPtr)=(HeapPtr)-4
    ld hl,(l0214h)	    ;5340   2a 14 02
    ex de,hl		    ;5343   eb
l5344h:		;<--;
    ld l,e	    ;	    ;5344
    ld h,d	    ;	    ;5345   hl=de
    inc hl	    ;	    ;5346
    inc hl	    ;	    ;5347
    inc hl	    ;	    ;5348
    inc hl	    ;	    ;5349   hl=hl+4
    ld b,4	    ;	    ;534a   b=4
    call s_085ch    ;	    ;534c   Move B bytes from ^HL to ^DE
    ld hl,(HeapPtr) ;	    ;534f   2a 16 02
    call cmpHL_DE   ;	    ;5352   Compare HL with DE
    jp nc,l5344h ;--+	    ;5355   if HL >= DE --> ...
l5358h:
    call s_55ebh	    ;5358   cd eb 55
    ld a,b		    ;535b   78
    cp 0ch		    ;535c   fe 0c
    jp nz,l522ch	    ;535e   if a.ne.0ch --> ...
    ld hl,l01c8h	    ;5361
    ld a,(hl)		    ;5364
    sub 010h		    ;5365
    ld (hl),a		    ;5367   (l01c8h)=(l01c8h)-16
    jp l522ch		    ;5368   --> ...
;
l536bh:
    ld hl,(HeapPtr)	;536b
    ld de,-8		;536e
    add hl,de		;5371
    ld (HeapPtr),hl	;5372	(HeapPtr)=(HeapPtr)-8
    ld a,(l01c8h)	;5375
    or a		;5378
    jp nz,l539dh ;--;	;5379	if(l01c8h).ne.0 --> ...
    ld hl,(l0234h)  ;	;537c
    ld (l0243h),hl  ;	;537f	(l0243h)=(l0234h)
    ld a,(l022fh)   ;	;5382
    or a	    ;	;5385
    jp z,s_55a9h    ;	;5386	if (l022fh).eq.0 --> (l01cch)=(l0236h); (TypeID)=(l01ebh); (l022eh)=(l022fh); ret
    ld hl,(l0236h)  ;	;5389
    ld (l0234h),hl  ;	;538c	(l0234h)=(l0236h)
    call s_5564h    ;	;538f	cd 64 55
    xor a	    ;	;5392
    ld (l022eh),a   ;	;5393	(l022eh)=0
    ld hl,(l0234h)  ;	;5396
    ld (l01cch),hl  ;	;5399	(l01cch)=(l0234h)
    ret		    ;	;539c
		    ;
l539dh:		;<--+
    ld hl,(l0214h)	;539d	2a 14 02
    ex de,hl		;53a0	eb
l53a1h:		;<--;
    ld l,e	    ;	;53a1
    ld h,d	    ;	;53a2	hl=de
    ld bc,00008h    ;	;53a3
    add hl,bc	    ;	;53a6	hl=hl+8
    ld b,4	    ;	;53a7	b=4
    call s_085ch    ;	;53a9	Move B bytes from ^HL to ^DE
    ld hl,(HeapPtr) ;	;53ac	2a 16 02
    call cmpHL_DE   ;	;53af	Compare HL with DE
    jp nz,l53a1h ;--+	;53b2	HL ne DE
    ld hl,(l0236h)	;53b5	2a 36 02
    ex de,hl		;53b8	eb
    ld a,(l022fh)	;53b9	3a 2f 02
    rrca		;53bc	0f
    ld b,a		;53bd	47
    ld hl,(l0214h)	;53be	2a 14 02
    ld a,(hl)		;53c1	7e
    and 01fh		;53c2	00011111b
    or b		;53c4	b0
    ld (hl),a		;53c5	77
    inc hl		;53c6	23
    ld a,(l01ebh)	;53c7	3a eb 01
    ld (hl),a		;53ca	77
    inc hl		;53cb	23
    ld (hl),e		;53cc	73
    inc hl		;53cd	23
    ld (hl),d		;53ce	72
    jp l5358h		;53cf	--> ...
;
l53d2h:
    ld a,(l022fh)	;53d2
    or a		;53d5
    jp z,l53deh ;---;	;53d6	if (l022fh).eq.0 --> ...
    ld a,3	    ;	;53d9
    ld (l0242h),a   ;	;53db	(l0242h)=3
l53deh:		;<--+
    ld a,(l022eh)	;53de
    or a		;53e1
    jp z,l532dh		;53e2	if (l022eh).eq.0 --> ...
    ld hl,l0242h	;53e5
    ld a,4		;53e8
    sub (hl)		;53ea
    ld (hl),a		;53eb	(l0242h)=4-(l0242h)
    dec a		;53ec
    jp z,l532dh		;53ed	if (l0242h).eq.1 --> ...
    ld hl,(l0206h)	;53f0
    ex de,hl		;53f3
    ld hl,(l0234h)	;53f4
    call cmpHL_DE	;53f7	Compare HL with DE
    jp c,l532dh		;53fa	if (l0234h) < (l0206h) --> ...
    xor a		;53fd	a=0
    ld (l022eh),a	;53fe	(l022eh)=0
    jp l540fh	;---;	;5401	--> ...
		    ;
l5404h:		    ;
    ld hl,l022eh    ;	;5404
    ld a,(l022fh)   ;	;5407
    xor (hl)	    ;	;540a
    ld (hl),a	    ;	;540b	(l022eh)=(l022eh).xor.(l022fh)
    jp l532dh	    ;	;540c	--> ...
		    ;
l540fh:		;<--+
    call s_55bch	;540f	{(l0234h)<->(l0236h); (l01eah)<->(l01eah); (l01e7h)<->(l01e8h)}
    jp l532dh		;5412	--> ...
;
l5415h:
    ld hl,(l0236h)	;5415
    ex de,hl		;5418
    ld hl,(l0206h)	;5419
    call subHL_DE	;541c	hl=(l0206h)-(l0236h)
    jp c,l5441h	 ;--;	;541f	if (l0206h) < 0 (l0236h) --> ...
    ld a,(hl)	    ;	;5422	7e
    and 0fh	    ;	;5423	00001111b
    cp 0dh	    ;	;5425
    jp c,l5441h	 ;--;	;5427	if a < 0dh --> ...
    cp 13h	    ;	;542a
    jp nc,l5441h ;--;	;542c	if a >= 013h --> ...
    ex de,hl	    ;	;542f	de=(l0206h)-(l0236h)
    ld hl,l04d6h    ;	;5430	hl= Point to Table
    ld c,a	    ;	;5433
    ld b,0	    ;	;5434	bc=a
    add hl,bc	    ;	;5436	09
    ld b,(hl)	    ;	;5437	46
    ex de,hl	    ;	;5438	eb
    ld a,(hl)	    ;	;5439	7e
l543ah:		    ;
    and 0e0h	    ;	;543a	11100000b
    or b	    ;	;543c	b0
    ld (hl),a	    ;	;543d	77
    jp l5336h	    ;	;543e	--> ...
		    ;
l5441h:		;<--+
    call s_55bch	;5441	{(l0234h)<->(l0236h); (l01eah)<->(l01eah); (l01e7h)<->(l01e8h)}
    ld a,(l01eah)	;5444
    ld (l01ebh),a	;5447	(l01ebh)=(l01eah)
    ld a,(l022eh)	;544a
    or a		;544d
    call nz,s_5572h	;544e	if (l022eh).ne.0 call ...
    ld hl,(l0234h)	;5451
    ld (l0236h),hl	;5454	(l0236h)=(l0234h)
    ld a,15h		;5457
    ld (l0242h),a	;5459	(l0242h)=15h
    xor a		;545c
    ld (l022eh),a	;545d	(l022eh)=0
    jp l532dh		;5460	--> ...
;
;?  No execution path to here
    ld hl,(l0214h)	;5463	2a 14 02
    inc hl		;5466	23
    inc hl		;5467	23
    inc hl		;5468	23
    inc hl		;5469	23
    ld a,(hl)		;546a	7e
    xor 080h		;546b	10000000b
    ld (hl),a		;546d	77
    jp l5336h		;546e	--> ...
;
l5471h:
    ld a,(l0242h)	 ;5471
    ld (l0279h),a	 ;5474	(l0279h)=(l0242h)
    ld hl,(l0214h)	 ;5477
    ld (l0277h),hl	 ;547a	(l0277h)=(l0214h)
    xor a		 ;547d
    ld (l027bh),a	 ;547e	(l027bh)=0
l5481h:
    ld a,(l01e7h)	 ;5481
    dec a		 ;5484
    jp z,l549fh	  ;----; ;5485	if (l01e7h).eq.1 --> ...
    ld a,(l01e8h)      ; ;5488
    or a	       ; ;548b
    jp z,l54dfh	       ; ;548c	if (l01e8h).eq.0 --> ...
l548fh:		       ;
    ld a,(l022eh)      ; ;548f	a=(l022eh)
    call s_5591h       ; ;5492	cd 91 55
    call s_55a9h       ; ;5495	{(l01cch)=(l0236h); (TypeID)=(l01ebh); (l022eh)=(l022fh)}
    call s_5643h       ; ;5498	cd 43 56
    ld hl,l027bh       ; ;549b
    inc (hl)	       ; ;549e	(l027bh)=(l027bh)+1
l549fh:	    ;<---------;
    ld hl,(l0214h)     ; ;549f
    inc hl	       ; ;54a2
    inc hl	       ; ;54a3
    inc hl	       ; ;54a4
    inc hl	       ; ;54a5
    ld (l0214h),hl     ; ;54a6	(l0214h)=(l0214h)+4
    ex de,hl	       ; ;54a9
    ld hl,(HeapPtr)    ; ;54aa
    dec hl	       ; ;54ad
    dec hl	       ; ;54ae
    dec hl	       ; ;54af
    dec hl	       ; ;54b0
    ex de,hl	       ; ;54b1
    call cmpHL_DE      ; ;54b2	Compare HL with DE
    jp nc,l54c5h ;-;   ; ;54b5	if (l0214h) >= (HeapPtr)-4 --> ...
l54b8h:		;<-)-; ;
    call s_5537h   ; ; ; ;54b8	cd 37 55
    ld a,(l0242h)  ; ; ; ;54bb
    ld hl,l0279h   ; ; ; ;54be
    cp (hl)	   ; ; ; ;54c1
    jp z,l5481h	   ; ; ; ;54c2	if (l0242h).eq.(l0279h) --> ...
l54c5h:	       ;<--+ ; ;
    ld hl,(l0277h)   ; ; ;54c5
    ld (l0214h),hl   ; ; ;54c8	(l0214h)=(l0277h)
    ld a,(l027bh)    ; ; ;54cb
    or a	     ; ; ;54ce
    jp nz,l54d8h ;-; ; ; ;54cf	if (l027bh).ne.0 --> ...
    call s_5537h   ; ; ; ;54d2	cd 37 55
    jp l52d3h	   ; ; ; ;54d5	--> ...
		   ; ; ;
l54d8h:	      ;<---+ ; ;
    xor a	     ; ; ;54d8	a=0
    ld (l027bh),a    ; ; ;54d9	(l027bh)=0
    jp l54b8h	;----+ ; ;54dc	--> ...
		       ;
l54dfh:		       ;
    ld hl,(l0206h)     ; ;54df
    push hl	       ; ;54e2	Save (l0206h)
    ld hl,(l0234h)     ; ;54e3
    ex de,hl	       ; ;54e6
    ld hl,(l0236h)     ; ;54e7
    call cmpHL_DE      ; ;54ea	Compare HL with DE
    jp c,l54f2h ;---;  ; ;54ed	if (l0236h) < (l0234h)	    trap_ms (054f2h) ***
    pop de	    ;  ; ;54f0	Restore de=(l0206h)
    db 3eh	    ;  ; ;54f1	ld a,0e1h (in the original) trap_ms ***
l54f2h:		;<--+  ;
    pop hl	       ; ;54f2	Restore hl=(l0206h)
    jp z,l549fh	  ;----; ;54f3	if (l0236h).eq,(l0234h) --> ...
    call cmpHL_DE      ; ;54f6	Compare HL with DE
    jp nc,l549fh  ;----+ ;54f9	if HL >= DE --> ...
    jp l548fh		 ;54fc	--> ...
;
;
;
s_54ffh:
    call s_55ebh	;54ff	cd eb 55
    ld a,b		;5502	78
    ld (l0242h),a	;5503	32 42 02
    ld a,c		;5506	79
    ld (l01eah),a	;5507	32 ea 01
    ld hl,(l0214h)	;550a	2a 14 02
    ld a,(hl)		;550d	7e
    and 080h		;550e	1000000b
    rlca		;5510	Multiply by 2
    ld (l022eh),a	;5511	32 2e 02
    xor a		;5514	a=0
    ld (l01e7h),a	;5515	(l01e7h)=0
    inc hl		;5518	23
    inc hl		;5519	23
    ld e,(hl)		;551a	5e
    inc hl		;551b	23
    ld d,(hl)		;551c	56
    ld hl,(l0206h)	;551d
    ex de,hl		;5520
    ld (l0234h),hl	;5521
    call cmpHL_DE	;5524
    ret c		;5527	if (l0234h) < (l0206h) Return
    call ExtAttr	;5528	Extract Attributes from the symbol table
    dec a		;552b
    ret nz		;552c	if (KindID).ne.1 (Constant) Return
    ld a,(TypeID)	;552d
    or a		;5530
    ret nz		;5531	if (TypeID).ne.0 (INTEGER) Return
    inc a		;5532
    ld (l01e7h),a	;5533	(l01e7h)=(TypeID)+1
    ret			;5536
;
;
;
s_5537h:
    ld hl,(l0214h)	;5537
    push hl		;553a \ Save (l0214h)
    inc hl		;553b
    inc hl		;553c
    inc hl		;553d
    inc hl		;553e
    ld (l0214h),hl	;553f	(l0214h)=(l0214h)+4
    call s_54ffh	;5542	cd ff 54
    pop hl		;5545 /
    ld (l0214h),hl	;5546	Restore (l0214h)
    ld hl,(l0234h)	;5549
    ld (l0236h),hl	;554c	(l0236h)=(l0234h)
    ld a,(l01eah)	;554f
    ld (l01ebh),a	;5552	(l01ebh)=(l01eah)
    ld a,(l022eh)	;5555
    ld (l022fh),a	;5558	(l022fh)=(l01ebh)
    ld a,(l01e7h)	;555b
    ld (l01e8h),a	;555e	(l01e8h)=(l01e7h)
    jp s_54ffh		;5561	--> ...
;
;
;
s_5564h:
    ld hl,(l0234h)	;5564
    ld (l0236h),hl	;5567	(l0236h)=(l0234h)
    ld a,0ch		;556a
    ld (l0242h),a	;556c	(l0242h)=0ch
    jp s_0ec6h		;556f	--> ...
;
;
;
s_5572h:
    call s_5564h	;5572	cd 64 55
    ld hl,(l0234h)	;5575	2a 34 02
    ex de,hl		;5578	eb
    ld hl,(l0214h)	;5579	2a 14 02
    inc hl		;557c	23
    inc hl		;557d	23
    ld (hl),e		;557e	73
    inc hl		;557f	23
    ld (hl),d		;5580	72
    jp s_5537h		;5581	--> ...
;
;
;
s_5584h:
    ld hl,(l0214h)	;5584
    inc hl		;5587
    inc hl		;5588
    inc hl		;5589
    inc hl		;558a	hl=(l0214h)+4
    rra			;558b	1f
    ld a,(hl)		;558c	7e
    rla			;558d	17
    rrca		;558e	0f
    ld (hl),a		;558f	77
    ret			;5590
;
;
;
s_5591h:
    call s_5584h	;5591	cd 84 55
    ld hl,(l0234h)	;5594	2a 34 02
    ex de,hl		;5597	eb
    ld hl,(l0214h)	;5598
    inc hl		;559b
    inc hl		;559c
    inc hl		;559d
    inc hl		;559e
    inc hl		;559f	hl=(l0214h)+5
    ld a,(l01eah)	;55a0	3a ea 01
    ld (hl),a		;55a3	77
    inc hl		;55a4	23
    ld (hl),e		;55a5	73
    inc hl		;55a6	23
    ld (hl),d		;55a7	72
    ret			;55a8
;
;   (l01cch)=(l0236h); (TypeID)=(l01ebh); (l022eh)=(l022fh)
;
s_55a9h:
    ld hl,(l0236h)	;55a9
    ld (l01cch),hl	;55ac	(l01cch)=(l0236h)
    ld a,(l01ebh)	;55af
    ld (TypeID),a	;55b2	(TypeID)=(l01ebh)
    ld a,(l022fh)	;55b5
    ld (l022eh),a	;55b8	(l022eh)=(l022fh)
    ret			;55bb
;
;   (l0234h)<->(l0236h); (l01eah)<->(l01eah); (l01e7h)<->(l01e8h)
;
s_55bch:
    ld hl,(l0234h)	;55bc				    hl=(l0234h)
    ex de,hl		;55bf						de=(l0234h)
    ld hl,(l0236h)	;55c0				    hl=(l0236h)
    ld (l0234h),hl	;55c3	(l0234h)=(l0236h)
    ex de,hl		;55c6				    hl=(l0234h) de=(l0236h)
    ld (l0236h),hl	;55c7	(l0236h)=old value(l0234h)
    ld hl,l01eah	;55ca				    hl=l01eah
    ld de,l01ebh	;55cd						de=l01ebh
    ld b,(hl)		;55d0			b=(l01eah)
    ld a,(de)		;55d1
    ld (hl),a		;55d2	(l01eah)=(l01eah)
    ex de,hl		;55d3				    hl=l01ebh	de=l01eah
    ld (hl),b		;55d4	(l01ebh)=old value(l01eah)
    ld hl,l01e7h	;55d5				    hl=l01e7h
    ld de,l01e8h	;55d8						de=l01e8h
    ld b,(hl)		;55db			b=(l01e7h)
    ld a,(de)		;55dc
    ld (hl),a		;55dd	(l01e7h)=(l01e8h)
    ex de,hl		;55de				    hl=l01e8h	de=l01e7h
    ld (hl),b		;55df	(l01e8h)=old value(l01e7h)
    ret			;55e0
;
;   Entry Reg A = 0ch
;
s_55e1h:
    ld b,a		;55e1	b= 0000 1100b (0ch)
    ld hl,(l0214h)	;55e2	2a 14 02
    ld a,0e0h		;55e5	a= 1110 0000b
    and (hl)		;55e7	a6
    or b		;55e8	b0
    ld (hl),a		;55e9	(l0214h)=
    ret			;55ea
;
;
;
s_55ebh:
    ld hl,(l0214h)	;55eb
    ld a,01fh		;55ee
    and (hl)		;55f0
    ld b,a		;55f1	b=(l0214h).and.00011111b
    inc hl		;55f2	hl=(l0214h)+1
    ld c,(hl)		;55f3	c=(hl)
    ld hl,l04cah	;55f4
    ld e,b		;55f7
    ld d,0		;55f8	de=b
    add hl,de		;55fa	hl=l04cah+b
    ld a,(hl)		;55fb	7e
    ret			;55fc
;
;
;
s_55fdh:
    ld hl,(l01b2h)	;55fd	2a b2 01    hl=(l01b2h)	    de=PAR
    ex de,hl		;5600		    hl=PAR	    de=(l01b2h)

    ld hl,(l01b0h)	;5601	2a b0 01    hl=(l01b0h)
    call s_561dh	;5604	cd 1d 56    hl=(l01b0h)	    de=(l01b2h)+2   (^(l01b2h))=(l01b0h)

    ld hl,(l01aeh)	;5607	2a ae 01    hl=(l01aeh)
    call s_561ch	;560a	cd 1c 56    hl=(l01b2h)+2   de=(l01aeh)+2   (^(l01aeh))=(l01b2h)+2

    ld hl,(l01aah)	;560d	2a aa 01    hl=(l01aah)
    call s_561ch	;5610	cd 1c 56    hl=(l01aeh)+2   de=(l01aah)+2   (^(l01aah))=(l01aeh)+2

    ld hl,(l01a6h)	;5613	2a a6 01    hl=(l01a6h)
    call s_561ch	;5616	cd 1c 56    hl=(l01aah)+2   de=(l01a6h)+2   (^(l01a6h))=(l01aah)+2
    ld hl,(l01a8h)	;5619	2a a8 01    hl=(l01a8h)
;
;
;
s_561ch:
    ex de,hl		;561c	eb	    hl=(l01a6h)+2   de=(l01a8h)
;
s_561dh:
    ld (hl),e		;561d						     hl=(l01aeh)     de=(l01b2h)+2   hl=(l01aah)     de=(l01aeh)+2
    inc hl		;561e	hl=hl+1
    ld (hl),d		;561f		   (^ (l01a6h)+2)=(l01a8h)	     (^(l01aeh))=(l01b2h)+2	     (^(l01aah))=(l01aeh)+2
    inc hl		;5620	hl=hl+1	    hl=(l01a6h)+4		     hl=(l01aeh)+2		     hl=(l01aah)+2
    ex de,hl		;5621	eb	    hl=(l01a8h)	    de=(l01a6h)+4    hl=(l01b2h)+2   de=(l01aeh)+2   hl=(l01aeh)+2   de=(l01aah)+2
    ret			;5622
;
; Select COMMON block ?
;
s_5623h:
    ld hl,(l0176h)	;5623						hl=(l0176h)
    ex de,hl		;5626								de=(l0176h)
    ld hl,(EntryID)	;5627						hl=(EntryID)
    call cmpHL_DE	;562a	Compare HL with DE
    ret z		;562d	if (EntryID).eq.(l0176h) Return
    ex de,hl		;562e						hl=(l0176h)	de=(EntryID)
    ld hl,(l01cch)	;562f						hl=(l01cch)
    push hl		;5632 \
    ex de,hl		;5633						hl=(EntryID)	 de=(l01cch)
    ld (l0176h),hl	;5634	(l0176h)=(EntryID)
    call ExtAttr	;5637	Extract Attributes from the symbol table
    ld c,0001b		;563a	rel types - select COMMON BLOCK
    call RELITEM	;563c	Select common block
    pop hl		;563f / hl=(l01cch)
    jp ExtAttr		;5640	--> Extract Attributes from the symbol table
;
;
;
s_5643h:
    ld hl,(l0214h)	    ;5643   2a 14 02
    ld a,(l022eh)	    ;5646   3a 2e 02
    rrca		    ;5649   0f
    ld b,a		    ;564a   47
    ld a,(l0242h)	    ;564b   3a 42 02
    or b		    ;564e   b0
    ld (hl),a		    ;564f   77
    inc hl		    ;5650   23
    ld a,(TypeID)	    ;5651   Load value type variable
    ld (hl),a		    ;5654   77
    ex de,hl		    ;5655   eb
    ld hl,(l01cch)	    ;5656   2a cc 01
    inc de		    ;5659   13
    ex de,hl		    ;565a   eb
    ld (hl),e		    ;565b   73
    inc hl		    ;565c   23
    ld (hl),d		    ;565d   72
    ret			    ;565e
;*
;*  hl=hl-de
;*
subHL_DE:
    ld a,l		    ;565f
    sub e		    ;5660   Subtract LO
    ld l,a		    ;5661
    ld a,h		    ;5662
    sbc a,d		    ;5663   .. and HI
    ld h,a		    ;5664
    ret			    ;5665
;*
;*  Search statements
;*
l5666h:
    call s_4e49h	    ;5666   Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
    ld a,4		    ;5669   a=4
    call GetStr		    ;566b   Reading string length 4 characters
    ld hl,(l01ddh)	    ;566e
    ld a,h		    ;5671
    cp cr		    ;5672
    jp z,Firstep	    ;5674   if a.eq.cr --> First step of the compilation
    ld (l022bh),hl	    ;5677   (l022bh)=(l01ddh) Copy 1 and 2 bytes statement
    ld hl,(l01dbh)	    ;567a
    ld (l0229h),hl	    ;567d   (l0229h)=(l01dbh) Copy 3 and 4 bytes statement
    ld hl,l032ah	    ;5680   hl=Pointer Statements table
;*
;*  Comparing with line of the table
;*
l5683h:		  ;<-----;
    push hl		 ;  ;5683 \ Save current pointer in table
    ld b,4		 ;  ;5684   b=4 (number of checked characters)
    ld de,l022ch	 ;  ;5686   Address 1 byte source string
l5689h:			 ;
      ld a,(hl)		 ;  ;5689
      cp ' '		 ;  ;568a
      jp z,l5694h ;--;	 ;  ;568c   if (hl).eq.' '  --> ...
      ld a,(de)	     ;	 ;  ;568f
      cp (hl)	     ;	 ;  ;5690
      jp nz,l56c9h ;-)-; ;  ;5691   if (de).ne.(hl) --> ...
l5694h:		 ;<--+ ; ;
      inc hl	       ; ;  ;5694   hl=hl+1
      dec de	       ; ;  ;5695   de=de-1
      dec b	       ; ;  ;5696   b=b-1
    jp nz,l5689h       ; ;  ;5697   if b.ne.0 --> ...
    ld c,(hl)	       ; ;  ;569a   1 - Offset
    inc hl	       ; ;  ;569b
    ld a,(hl)	       ; ;  ;569c   2 - Type statement
    inc hl	       ; ;  ;569d
    ld e,(hl)	       ; ;  ;569e   3
    inc hl	       ; ;  ;569f
    ld d,(hl)	       ; ;  ;56a0   4 de=address program processing statement
    ex de,hl	       ; ;  ;56a1
    ld (CurAdr),hl     ; ;  ;56a2   Store the address program processing statement
    pop hl	       ; ;  ;56a5 / Restore current pointer
    dec c	       ; ;  ;56a6
    jp m,l56c2h ;----; ; ;  ;56a7   if c < 1 --> Found statement length of 4 characters
    push af	     ; ; ;  ;56aa \ Save Type statement
    ld b,0	     ; ; ;  ;56ab   b=0
    ld hl,l042ah     ; ; ;  ;56ad   hl=pointer Table Continuation of statements
    add hl,bc	     ; ; ;  ;56b0   Calculate position in the table
l56b1h:	      ;<---; ; ; ;
    push hl	   ; ; ; ;  ;56b1 \
    call g_n_chr   ; ; ; ;  ;56b2 +
    pop hl	   ; ; ; ;  ;56b5 /
    xor (hl)	   ; ; ; ;  ;56b6   ae
    rla		   ; ; ; ;  ;56b7   17
    inc a	   ; ; ; ;  ;56b8   3c
    dec a	   ; ; ; ;  ;56b9   3d
    jp nz,err101   ; ; ; ;  ;56ba   if ne.0 --> Error (101) Statement Unrecognizable or Misspelled
    inc hl	   ; ; ; ;  ;56bd   23
    jp nc,l56b1h ;-+ ; ; ;  ;56be   if >= --> Compare the following symbol
    pop af	     ; ; ;  ;56c1 / Restore Type statement
		     ; ; ;
;*  Found statement  ; ; ;
		     ; ; ;
l56c2h:		;<---+ ; ;
    call s_5012h       ; ;  ;56c2   cd 12 50
    ld hl,(CurAdr)     ; ;  ;56c5   Load address program processing statement
    jp (hl)	       ; ;  ;56c8   Switch to processing --> ...
		       ; ;
l56c9h:		;<-----+ ;
    pop hl		 ;  ;56c9 / Restore pointer in table
    ld de,00008h	 ;  ;56ca
    add hl,de		 ;  ;56cd   hl=hl+8
    ld de,l042ah	 ;  ;56ce   de=Adress first byte located after the table
    call cmpHL_DE	 ;  ;56d1   Compare HL with DE
    jp c,l5683h	    ;----+  ;56d4   if HL < DE --> Comparing with the next line of the table
err101:
    call err_msg	    ;56d7 + Error (101)
    db 101		    ;56da + Statement Unrecognizable or Misspelled
;*
;*  ENTRY
;*    Reg HL - Par
;*
s_56dbh:
    ld bc,010bh		    ;56db   Address modes CSEG, REL type - set LOCATION COUNTER
;*
;*  ENTRY
;*    Reg HL - Par
;*    Reg  B - Address_modes
;*    Reg  C - REL type
;*
s_56deh:
    ld a,b		    ;56de
    cp 2		    ;56df
    ld a,1		    ;56e1   a=1
    jp nz,l56e7h ;--;	    ;56e3   if Address modes.ne.2 (DSEG) --> trap_ms (056e7h) ***
    db 0feh	    ;	    ;56e6   cp 0afh (in the original)	     trap_ms ***
l56e7h:		;<--+
    xor a		    ;56e7   a=0
    ld (l01a3h),a	    ;56e8   (l01a3h)=0 (or 1)
    ex de,hl		    ;56eb				       de=Par
    ld hl,(PrgSiz)	    ;56ec			hl=(PrgSiz)
    ld (l021bh),hl	    ;56ef   (l021bh)=(PrgSiz)
    ex de,hl		    ;56f2			hl=Par	       de=(PrgSiz)
    ld (PrgSiz),hl	    ;56f3   (PrgSiz)=Par
    ex de,hl		    ;56f6			hl=Par	       de=(PrgSiz)
    jp RELITEM		    ;56f7   Give CSEG location counter
;*
;*
;*
s_56fah:
    pop hl		    ;56fa / e1
    ld (l025fh),hl	    ;56fb   (l025fh)=SP
    ex de,hl		    ;56fe		    hl=???		    de=(l025fh)
    ld (l025bh),hl	    ;56ff   (l025bh)=???    hl=(l025bh)
    ex de,hl		    ;5702		    hl=(l025fh)		    de=(l025bh)
    ld hl,(l0209h)	    ;5703		    hl=(l0209h)
    ld (l025dh),hl	    ;5706   (l025dh)=(l0209h)
    jp l571fh	;-------;   ;5709   --> ...
			;
l570ch:			;
    ld hl,(l025bh)	;   ;570c
    push hl		;   ;570f \ Save (l025bh)					SP=(l025bh)
    ld hl,(l025dh)	;   ;5710		    hl=(l025dh)
    ex de,hl		;   ;5713					    de=(l025dh)
    ld hl,(l0206h)	;   ;5714		    hl=(l0206h)
    call subHL_DE	;   ;5717		    hl=(l0206h)-(l025dh)
    pop de		;   ;571a / Restore (l025bh)			    de=(l025bh)
    dec hl		;   ;571b
    dec hl		;   ;571c   hl=hl-2	    hl=(l0206h)-(l025dh)-2
l571dh:	  ;<--------;	;
    dec hl	    ;	;   ;571d   hl=hl-1
l571eh:	     ;<-----)-; ;
    dec hl	    ; ; ;   ;571e   hl=hl-1
l571fh:		;<--)-)-+
    push de	    ; ;	    ;571f \ Save de	    hl=(l0209h)		    de=(l025bh)	 SP=(l025bh)
    ex de,hl	    ; ;	    ;5720		    hl=(l025bh)		    de=(l0209h)
    ld hl,(HeapEnd) ; ;	    ;5721		    hl=(HeapEnd)
    inc hl	    ; ;	    ;5724   hl=hl+1	    hl=(HeapEnd)+1
    ex de,hl	    ; ;	    ;5725		    hl=(l0209h)		    de=(HeapEnd)+1
    call cmpHL_DE   ; ;	    ;5726   Compare HL with DE
    pop de	    ; ;	    ;5729 / Restore de
    jp c,l574ah ;---)-)-;   ;572a   if HL < DE --> ...
    dec hl	    ; ; ;   ;572d
    dec hl	    ; ; ;   ;572e   hl=hl-2
    ld a,(hl)	    ; ; ;   ;572f   7e
    cp d	    ; ; ;   ;5730   ba
    jp nz,l571dh ;--+ ; ;   ;5731   if a.ne d --> ...
    dec hl	      ; ;   ;5734   hl=hl-1
    ld a,(hl)	      ; ;   ;5735   7e
    sub e	      ; ;   ;5736   93
    jp nz,l571eh ;----+ ;   ;5737   c2 1e 57
    inc hl		;   ;573a
    inc hl		;   ;573b
    inc hl		;   ;573c   hl=hl+3
    push hl		;   ;573d \ e5
    ex de,hl		;   ;573e   eb
    ld hl,(l0206h)	;   ;573f   2a 06 02
    call subHL_DE	;   ;5742   hl=hl-de
    ld (l025dh),hl	;   ;5745   (l025dh)=
    pop de		;   ;5748 / d1
    xor a		;   ;5749   a=0
l574ah:		;<------+
    ld hl,(l025fh)	    ;574a   2a 5f 02
    push hl		    ;574d \ Save (l025fh)
    ex de,hl		    ;574e   eb
    ret			    ;574f
;
;?				 !! No execution path to here !!
    push hl		    ;5750 \ Save ADDR
    ld bc,00002h	    ;5751   bc=2
    call ChkMem		    ;5754   Test Allocate A bytes of memory
    ld hl,(l01b0h)	    ;5757   hl=(l01b0h)
    inc hl		    ;575a   hl=(l01b0h)+1
    pop de		    ;575b / de=ADDR
    ld (hl),e		    ;575c   (hl)=ADDR
    inc hl		    ;575d   hl=(l01b0h)+2
    ld (hl),d		    ;575e
    ld (l01b0h),hl	    ;575f   (l01b0h)=(l01b0h)+2
    ret			    ;5762
;*
;*  Ending parsing statement
;*
l5763h:
    ld hl,(HeapPtr)	    ;5763
    ex de,hl		    ;5766
    ld hl,(HeapEnd)	    ;5767
    call subHL_DE	    ;576a   hl=hl-de
    ld de,190h		    ;576d   ????
    call cmpHL_DE	    ;5770   Compare HL with DE
    call c,s_3169h	    ;5773   if ((HeapEnd)-(HeapPtr)) < 190h call ...
    ld a,(l0298h)	    ;5776
    cp cr		    ;5779
    jp z,l5782h ;---;	    ;577b   if (l0298h).eq.cr --> Skip error message
err102:		    ;
    call err_msg    ;	    ;577e   Error (102)
    db 102	    ;	    ;5781   Illegal Statement Completion
l5782h:	       ;<---+
    ld hl,(l0263h)	    ;5782
    ld a,h		    ;5785
    or l		    ;5786
    jp z,Firstep	    ;5787   if(l0263h).eq.0 --> First step of the compilation
l578ah:		   ;<---;
    ld hl,(l01a4h)	;   ;578a   2a a4 01
    ld bc,00000h	;   ;578d   bc=0 counter
l5790h:	    ;<--------; ;
      ld de,-10	      ; ;   ;5790
      add hl,de	      ; ;   ;5793   hl=hl-10
      ld (l01b0h),hl  ; ;   ;5794   (l01b0h)=
      ld de,l66c6h    ; ;   ;5797   Address of the first byte of the data area
      call cmpHL_DE   ; ;   ;579a   Compare HL with DE
      jp c,Firstep    ; ;   ;579d   if (l01b0h) < l66c6h --> First step of the compilation
      push hl	      ; ;   ;57a0 \ e5
      push bc	      ; ;   ;57a1 \ c5
      call s_4788h    ; ;   ;57a2   cd 88 47
      ld hl,(l0263h)  ; ;   ;57a5
      ex de,hl	      ; ;   ;57a8
      ld hl,(l01b2h)  ; ;   ;57a9
      call cmpHL_DE   ; ;   ;57ac   Compare HL with DE
      jp z,l57b9h ;-; ; ;   ;57af   if (l01b2h).eq.(l0263h) --> ...
      ld b,h	    ; ; ;   ;57b2
      ld c,l	    ; ; ;   ;57b3   bc=hl
      pop hl	    ; ; ;   ;57b4 / e1
      pop hl	    ; ; ;   ;57b5 / e1
    jp l5790h	;---)-+ ;   ;57b6   --> ...
		    ;	;
l57b9h:	       ;<---+	;
    ld a,(DO_Flg)	;   ;57b9
    or a		;   ;57bc
    jp z,l57c4h	 ;--;	;   ;57bd   if (DO_Flg).eq.0 --> Skip error message
    call err_msg    ;	;   ;57c0   Warning (1)
    db 1	    ;	;   ;57c3   Illegal DO Termination
l57c4h:	       ;<---+	;
    call s_3169h	;   ;57c4   cd 69 31
    ld a,(l021fh)	;   ;57c7
    or a		;   ;57ca
    jp z,l57efh	 ;--;	;   ;57cb   if (l021fh).eq.0 --> ...
    ld hl,(l0167h)  ;	;   ;57ce
    ld a,h	    ;	;   ;57d1
    or l	    ;	;   ;57d2
    jp z,l57efh	 ;--;	;   ;57d3   if (l0167h).eq.0 --> ...
    ld (DataID),hl  ;	;   ;57d6   (DataID)=(l0167h)
    xor a	    ;	;   ;57d9
    ld (TypeID),a   ;	;   ;57da   (TypeID)=0 (INTEGER)
    ld (SegmID),a   ;	;   ;57dd   (SegmID)=0 (CSEG) Save Flag Address mode
    ld h,a	    ;	;   ;57e0
    ld l,a	    ;	;   ;57e1   hl=0
    ld (l0167h),hl  ;	;   ;57e2   (l0167h)=0
    call s_49ceh    ;	;   ;57e5   cd ce 49
    xor a	    ;	;   ;57e8   a=0
    ld (l0299h),a   ;	;   ;57e9   (l0299h)=0
    ld (l021fh),a   ;	;   ;57ec   (l021fh)=0
l57efh:	       ;<---+	;
    pop bc		;   ;57ef / c1
    pop hl		;   ;57f0 / e1
    ld a,b		;   ;57f1
    or c		;   ;57f2   test bc
    jp nz,l57fch ;--;	;   ;57f3   if bc.ne.0 --> ...
    call s_25bdh    ;	;   ;57f6   cd bd 25
    jp l578ah ;-----)---+   ;57f9   --> ...
		    ;
l57fch:	       ;<---+
    ld h,b		    ;57fc
    ld l,c		    ;57fd   hl=bc
    ld (l01b2h),hl	    ;57fe   (l01b2h)=bc
    call s_55fdh	    ;5801   cd fd 55
    call err_msg	    ;5804 + Error (103)
    db 103		    ;5807 + Illegal DO Nesting
;*
;*  Check the stack
;*
ChkStack:
    push de		    ;5808
    push hl		    ;5809
    ld hl,-20		    ;580a   hl=[ffec]
    add hl,sp		    ;580d	hl=SP-20
    ex de,hl		    ;580e		    de=SP-20
    ld hl,(TopDat)	    ;580f	hl=(TopDat)
    ex de,hl		    ;5812	hl=SP-20    de=(TopDat)
    call cmpHL_DE	    ;5813   Compare HL with DE
    pop hl		    ;5816
    pop de		    ;5817
    ret nc		    ;5818   if(SP-20 >= (TopDat)) Return
    call err_msg	    ;5819 + Error (134)
    db 134		    ;581c + Stack Overflow
;*
;*  First step of the compilation
;*
Firstep:
    ld hl,00000h	    ;581d   hl=0
    ld (l0263h),hl	    ;5820   (l0263h)=0
    ld hl,l010dh	    ;5823
    ld (hl),0		    ;5826   (l010dh)=0
    call s_14d4h	    ;5828 + g_n_chr; (l0173h)=chr
    jp c,l58b3h	 ;------;   ;582b + if chr Special character --> ...
    jp p,l586eh	 ;----; ;   ;582e + if chr Letter --> ...
    call PrLabel      ; ;   ;5831 + Processing label
    ld a,(ScopeID)    ; ;   ;5834
    or a	      ; ;   ;5837
    jp z,l583fh	 ;--; ; ;   ;5838   if(ScopeID).eq.0 --> Skip error message
    call err_msg    ; ; ;   ;583b   Warning (0)
    db 0	    ; ; ;   ;583e   Duplicate Statement Label
		    ; ; ;
l583fh:		 ;<-+ ; ;
    ld hl,(l01cch)    ; ;   ;583f
    push hl	      ; ;   ;5842 \
    ld (l0263h),hl    ; ;   ;5843   (l0263h)=(l01cch)
    call s_3169h      ; ;   ;5846   cd 69 31
    call s_2846h      ; ;   ;5849   cd 46 28
    pop hl	      ; ;   ;584c / hl=(l01cch)
    call ExtAttr      ; ;   ;584d   Extract Attributes from the symbol table
    call s_49ceh      ; ;   ;5850   cd ce 49
    ld a,(TypeID)     ; ;   ;5853
    or a	      ; ;   ;5856
    jp nz,l585dh ;--; ; ;   ;5857   if (TypeID).ne.0 (INTEGER) --> ...
    ld (l020bh),a   ; ; ;   ;585a   (l020bh)=0
l585dh:		 ;<-+ ; ;
    ld hl,(PrgSiz)    ; ;   ;585d   Load Program size
    ld (DataID),hl    ; ;   ;5860   (DataID)=(PrgSiz)
    ld hl,ScopeID     ; ;   ;5863
    ld (hl),2	      ; ;   ;5866   (ScopeID)=2
    call PutAttr      ; ;   ;5868   Put Attributes in Symbol table
    jp l5875h  ;----; ; ;   ;586b   --> ...
		    ; ; ;
l586eh:	  ;<--------)-; ;
    xor a	    ; ; ;   ;586e   a=0
    ld (l020bh),a   ; ; ;   ;586f   (l020bh)=0
    call s_2846h    ; ; ;   ;5872   cd 46 28
l5875h:		 ;<-+ ; ;
    ld a,(l021fh)     ; ;   ;5875
    or a	      ; ;   ;5878
    jp z,l58a2h ;---; ; ;   ;5879   if (l021fh).eq.0 --> ...
    ld hl,(l0167h)  ; ; ;   ;587c
    ld a,h	    ; ; ;   ;587f
    or l	    ; ; ;   ;5880
    jp z,l58a2h ;---; ; ;   ;5881   if (l0167h).eq.0 --> ...
    push hl	    ; ; ;   ;5884 \
    call s_3169h    ; ; ;   ;5885   cd 69 31
    pop hl	    ; ; ;   ;5888 /
    ld (DataID),hl  ; ; ;   ;5889   (DataID)=(l0167h)
    xor a	    ; ; ;   ;588c
    ld (TypeID),a   ; ; ;   ;588d   (TypeID)=0 (INTEGER)
    ld (SegmID),a   ; ; ;   ;5890   (SegmID)=0 (CSEG)	 Save Flag Address mode
    ld h,a	    ; ; ;   ;5893
    ld l,a	    ; ; ;   ;5894
    ld (l0167h),hl  ; ; ;   ;5895   (l0167h)=0
    call s_49ceh    ; ; ;   ;5898   cd ce 49
    xor a	    ; ; ;   ;589b
    ld (l0299h),a   ; ; ;   ;589c   (l0299h)=0
    ld (l021fh),a   ; ; ;   ;589f   (l021fh)=0
l58a2h:		 ;<-+ ; ;
    ld hl,00000h      ; ;   ;58a2
    ld (l020ch),hl    ; ;   ;58a5   (l020ch)=0
    ld a,(l0298h)     ; ;   ;58a8
    or a	      ; ;   ;58ab
    jp z,l58beh ;---; ; ;   ;58ac   if(l0298h).eq.0 --> ...
    call err_msg    ; ; ;   ;58af   Error (100)
    db 100	    ; ; ;   ;58b2   Illegal Statement Number
l58b3h:	    ;<------)-)-+
    or a	    ; ;	    ;58b3
    jp z,l586eh ;---)-;	    ;58b4   if chr.eq.0 --> ...
    xor a	    ; ;	    ;58b7
    ld (l0173h),a   ; ;	    ;58b8   (l0173h)=0
    jp l586eh	;---)-+	    ;58bb   --> ...
		    ;
l58beh:		 ;<-+
    ld a,(PosStm)	    ;58be
    ld (l028fh),a	    ;58c1   (l028fh)=(PosStm)
    ld (l01ceh),a	    ;58c4   (l01ceh)=(PosStm)
    ld hl,00000h	    ;58c7   hl=0
    ld (CurAdr),hl	    ;58ca   (CurAdr)=0
;*
;*  Parse END
;*
    ld bc,l58f1h	    ;58cd   bc= point to l58f1h
    push bc		    ;58d0   save to return
    call g_n_chr	    ;58d1 +
    cp 'E'		    ;58d4 +
    ret nz	 ;--;	    ;58d6 + if chr.ne.'E' Return to l58f1h
    call g_n_chr    ;	    ;58d7 +
    cp 'N'	    ;	    ;58da +
    ret nz	 ;--;	    ;58dc + if chr.ne.'N' Return to l58f1h
    call g_n_chr    ;	    ;58dd +
    cp 'D'	    ;	    ;58e0 +
    ret nz	 ;--;	    ;58e2 + if chr.ne.'D' Return to l58f1h
    call g_n_chr    ;	    ;58e3 +
    cp '/'	    ;	    ;58e6
    ret nz	 ;--;	    ;58e8   if chr.ne.'/' Return to l58f1h
    ld a,0bh	    ;	    ;58e9   a=0bh
    call s_5012h    ;	    ;58eb   cd 12 50
    jp l3bcbh	    ;	    ;58ee   --> Completion compile the module
		    ;
l58f1h:		;<--+
    call s_4e49h	    ;58f1   Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
    ld a,(l028fh)	    ;58f4
    ld (l01ceh),a	    ;58f7   (l01ceh)=(l028fh)
    ld b,0ffh		    ;58fa   b=0ffh
l58fch:		;<--;
    push bc	    ;	    ;58fc +
    call g_n_chr    ;	    ;58fd +
    pop bc	    ;	    ;5900 +
l5901h:	    ;<------)-;
    cp ')'	    ; ;		;5901
    jp z,l5954h	  ;-)-)-;	;5903	if chr.eq.')' --> ...
    cp '('	    ; ; .	;5906
    jp z,l5960h	 ;--)-)-)---;	;5908	if chr.eq.'(' --> ...
    cp ','	    ; ; .   ;	;590b
    jp z,l5961h ;---)-)-)-; ;	;590d	if chr.eq.',' --> ...
    cp '/'	    ; ; . ; ;	;5910
    jp z,l5666h	    ; ; . ; ;	;5912	if chr.eq.'/' --> Search statement
    cp '='	    ; ; . ; ;	;5915
    jp nz,l58fch ;--+ ; . ; ;	;5917	if chr.ne.'=' --> ...
    or b	      ; . ; ;	;591a
    jp p,l5666h	      ; . ; ;	;591b	if b > 0 --> Search statement
    call s_1cb5h      ; . ; ;	;591e	cd b5 1c
    call s_4e49h      ; . ; ;	;5921	Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
    ld a,(l0298h)     ; . ; ;	;5924
    cp ','	      ; . ; ;	;5927
    jp z,l0de9h	      ; . ; ;	;5929	if (l0298h).eq.',' --> Parse DO statement
    call PrName	      ; . ; ;	;592c	Processing name
    ld a,(l0298h)     ; . ; ;	;592f
    cp '='	      ; . ; ;	;5932
    jp z,l593fh	 ;--; ; . ; ;	;5934	if (l0298h).eq.'=' --> ...
    ld a,(KindID)   ; ; . ; ;	;5937
    cp 4	    ; ; . ; ;	;593a
    jp nz,l35efh    ; ; . ; ;	;593c	if (KindID).ne.4 (Array) --> ...
l593fh:	      ;<----+ ; . ; ;
    ld a,9	      ; . ; ;	;593f	a=9
    call s_5012h      ; . ; ;	;5941	cd 12 50
    ld a,(l028fh)     ; . ; ;	;5944
    ld (l01ceh),a     ; . ; ;	;5947	(l01ceh)=(l028fh)
    call s_4e49h      ; . ; ;	;594a	Init variables (PosStm),(l01ceh)=(l0173h)=0,Clear buffer ^l02b4h
    xor a	      ; . ; ;	;594d	a=0
    call s_14dbh      ; . ; ;	;594e	cd db 14
    jp l09e4h	      ; . ; ;	;5951	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
		      ; . ; ;
l5954h:	    ;<--------)-+ ; ;
    dec b	      ;	  ; ;	;5954	b=b-1
l5955h:	       ;<-----)-; ; ;
    push bc	      ; . ; ;	;5955 +
    call g_n_chr      ; . ; ;	;5956 +
    pop bc	      ; . ; ;	;5959 +
    jp nc,l5666h      ; . ; ;	;595a + if chr Letter or Digit --> Search statement
    jp l5901h	  ;---; . ; ;	;595d	--> ...
		      ; . ; ;
l5960h:	       ;<-----)-)-)-+
    inc b	      ; . ;	;5960	b=b+1
l5961h:	     ;<-------)-)-+
    inc b	      ; .	;5961	b=b+1
    dec b	      ; .	;5962
    jp nz,l5666h      ; .	;5963	if b.ne.0 --> Search statement
    push bc	      ; .	;5966 \ c5
    call s_1cb5h      ; .	;5967	cd b5 1c
    ld a,(l01cbh)     ; .	;596a
    inc a	      ; .	;596d
    jp nz,l5982h ;--; ; .	;596e	if (l01cbh).ne.-1 --> ...
l5971h:	   ;<-----; ; ; .
    call s_1a98h  ; ; ; .	;5971	cd 98 1a
    ld b,a	  ; ; ; .	;5974	Save a
    ld a,(PosStm) ; ; ; .	;5975	3a 07 01
    cp 73	  ; ; ; .	;5978
    jp z,l5982h ;-)-; ; .	;597a	if (PosStm).eq.73 --> ...
    ld a,b	  ; ; ; .	;597d	Restore a
    or a	  ; ; ; .	;597e
    jp nz,l5971h;-+ ; ; .	;597f	if b.ne.0 --> ...
l5982h:	    ;<------+ ; .
    pop bc	      ; .	;5982 / c1
    ld a,1	      ; .	;5983
    ld (l0173h),a     ; .	;5985	(l0173h)=1
    ld a,(l0242h)     ; .	;5988
    cp 2	      ; .	;598b
    ld a,02ah	      ; .	;598d
    jp z,l5901h	 ;----+ .	;598f	if (l0242h).eq.2 { a=02ah --> ...}
    jp l5955h ;---------+	;5992	--> ...
;*
;*  Processing SUBROUTINE (SUBROUTINE name(par1,par2,...,parn))
;*
PrSubroutine:
    ld a,1		;5995
    ld (SubrFlg),a	;5997	(SubrFlg)=1 (Subroutine)
;*
;*  Processing FUNCTION (FUNCTION name(par1,par2,...,parn))
;*
PrFunction:
    ld a,0ffh		;599a	a=0ffh
l599ch:
    push af		;599c \ Save (tmpvar)
    ld a,(l024dh)	;599d
    or a		;59a0	if(l024dh).ne.0
    jp nz,err127	;59a1	   --> Error (127) Statement Out of Sequence
    ld a,1		;59a4
    ld (l0261h),a	;59a6	(l0261h)=1
    ld (MainFlg),a	;59a9	(MainFlg)=1 (Subprogram)
    call PrName		;59ac	Processing name
    pop af		;59af / Restore (tmpvar)
    or a		;59b0
    jp m,l59b7h	  ;-;	;59b1	if (tmpvar) < 0 --> ...
    ld (TypeID),a   ;	;59b4	(TypeID)=(tmpvar)
l59b7h:		;<--+
    call s_0a09h	;59b7	cd 09 0a
    ld a,2		;59ba
    ld (ScopeID),a	;59bc	(ScopeID)=2
    call PutAttr	;59bf	Put Attributes in Symbol table
    ld hl,(l01cch)	;59c2
    ld (l0267h),hl	;59c5	(l0267h)=(l01cch)
    call s_4a28h	;59c8	Put name program to REL file
    ld c,0		;59cb	REL type - ENTRY SYMBOL
    call RELITEM	;59cd
    call s_4a69h	;59d0	cd 69 4a
    ld a,(SubrFlg)	;59d3	Load flag Subroutine
    or a		;59d6
    jp nz,l59e8h ;--;	;59d7	if (SubrFlg).ne.0 (Subroutine) --> ...
    ld hl,l02aah    ;	;59da
    ld a,(hl)	    ;	;59dd
    push af	    ;	;59de \ Save (l02aah)
    ld (hl),8	    ;	;59df	(l02aah)=8
    call s_0cfdh    ;	;59e1	cd fd 0c
    pop af	    ;	;59e4 / Restore (l02aah)
    ld (l02aah),a   ;	;59e5	(l02aah)=(l02aah)
l59e8h:		;<--+
    call s_1909h	;59e8	Processing of actual parameters subprogram
    jp l09e4h		;59eb	--> Clear (l0299h) & (DO_Flg) -> Ending parsing statement
;*
;*  Extract Attributes from the symbol table, entry (l031eh)
;*
s_59eeh:
    ld hl,(l031eh)	;59ee	2a 1e 03
    jp ExtAttr		;59f1	--> Extract Attributes from the symbol table
;*
;*  Calculate address next symbol in the Symbols table;
;*  if (l01cch).<=.(l0206h) Extract Attributes from the symbol table
;*
s_59f4h:
    ld hl,(l01cch)	;59f4
    ld a,(SizeID)	;59f7
    cpl			;59fa
    sub 5		;59fb
    ld c,a		;59fd
    ld b,0ffh		;59fe
    add hl,bc		;5a00
    ld (l01cch),hl	;5a01	(l01cch)=(l01cch)-(SizeID)-6
    ex de,hl		;5a04
    ld hl,(l0206h)	;5a05
    call cmpHL_DE	;5a08	Compare HL with DE
    ccf			;5a0b
    ret c		;5a0c	if (l0206h) >= (l01cch) Return
    jp s_4647h		;5a0d	--> Extract Attributes from the symbol table, entry( l01cch)
;*
;*  Check ','
;*
ChComma:
    ld a,','		;5a10 +
    jp ch_chr		;5a12 + Check character (a character for check)
;*
;*  Check '('
;*
s_5a15h:
    ld a,'('		;5a15 +
;*
;*  Check character (a character for check)
;*
ch_chr:
    ld hl,l0298h	;5a17 +
    cp (hl)		;5a1a +
    ret z		;5a1b + if a.eq.(l0298h) Return
err126:
    call err_msg	;5a1c + Error (126)
    db 126		;5a1f + Illegal Character for Syntax
;
err137:
    call err_msg	;5a20 + Error (137)
    db 137		;5a23 + File Not Found
;*
;*
;*
s_5a24h:
    ld a,(l02aah)	;5a24
    ld l,a		;5a27
    ld h,0		;5a28	hl=(l02aah)
    ld de,00001h	;5a2a	de=1
    ld a,(KindID)	;5a2d
    cp 4		;5a30
    ret nz		;5a32	if (KindID).ne.4 (Array) Return
    push hl		;5a33 \ Save hl
    call s_46e9h	;5a34	cd e9 46
    ld a,(l022dh)	;5a37	3a 2d 02
    cpl			;5a3a	2f
    ld hl,l0269h	;5a3b
    ld e,(hl)		;5a3e
    inc hl		;5a3f			hl=hl+1
    ld d,(hl)		;5a40	de=(l0269h)
    inc hl		;5a41			hl=hl+1
    inc a		;5a42	a=-(l022dh)
l5a43h:	    ;<------;
      inc a	    ;	;5a43	a=a+1
      jp z,l5a56h ;-)-; ;5a44	if a.eq.0 --> ...
      push af	    ; ; ;5a47 \ --------------;
      ld c,(hl)	    ; ; ;5a48	4e	      ;
      inc hl	    ; ; ;5a49	hl=hl+1	      ;
      ld b,(hl)	    ; ; ;5a4a	46	      ;
      inc hl	    ; ; ;5a4b	hl=hl+1	      ;
      push hl	    ; ; ;5a4c \ ------------; ;
      call s_4917h  ; ; ;5a4d	cd 17 49    ; ;
      ex de,hl	    ; ; ;5a50	eb	    ; ;
      pop hl	    ; ; ;5a51 / <-----------+ ;
      pop af	    ; ; ;5a52 / <-------------+
    jp l5a43h	;---+ ; ;5a53	--> ...
		      ;
l5a56h:	  ;<----------+
    ld b,d		;5a56
    ld c,e		;5a57	bc=de
    ex de,hl		;5a58	eb
    ex (sp),hl		;5a59	e3
    ex de,hl		;5a5a	eb
    call s_4917h	;5a5b	cd 17 49
    pop de		;5a5e / d1
    ret			;5a5f

;#################
;# END MODULE	 #
;#################

;#################
;# START MODULE	 #
;#################

RELflg:	    db	0	    ;5a60	REL file flag [0x80 is empty]
vStack:	    dw	0	    ;5a61	Stack
extdot:	    db	0	    ;5a63	Extension dot flag [0 is extension given]
ExtStk:	    db	0	    ;5a64	Extra stack page count
l5a65h:	    db	0	    ;5a65	list file selected ?
b_drive:		    ;	Drive *d*
l5a66h:	    db	0	    ;5a66	*n*
CpuFlg:	    db	0	    ;5a67	/I flag [0-z80]
enaLST:	    db	0	    ;5a68	/L flag [0 is not]
StkFlg:	    db	0	    ;5a69	/P flag
enaOBJ:	    db	0	    ;5a6a	REL flag [0 is not]
LstFlg:	    db	0	    ;5a6b	/C list file flag
CCPflg:	    db	0	    ;5a6c	CCP line indicator [0 is not]
HexFlg:	    db	0	    ;5a6d	/O  flag [0-hex]
NoCode:	    db	0	    ;5a6e	/N  flag
RomFlg:	    db	0	    ;5a6f	/M  flag
PRNCol:	    db	0	    ;5a70	Printer column

F$OBJ:	    ds	FCBlen	    ;5a71	REL file
F$LST:	    ds	FCBlen	    ;5a92	List file *f*
F$SRC:	    ds	FCBlen	    ;5ab3	Source file

	    ds	32	    ;5ad4   ???

TmpAdr:			    ;5af4   Address Start F80
;
; Filename
;
l5af4h:	    ds	_DRV	    ;5af4   Drive
l5af5h:	    ds	_NAM	    ;5af5   Point to name
l5afdh:	    ds	_EXT	    ;5afd   Point to extension
;
; Command buffer
;
ConBuf:	    db	CMDLEN	    ;5b00   Length of console buffer [50h]
ConSiz:	    db	0	    ;5b01   Length of command (resulting size after read)
ConLin:	    ds	CMDLEN-1    ;5b02   1st command character

ConPtr:	    dw	0	    ;5b51   Current command pointer

owrptr:	    dw	0	    ;5b53   REL buffer pointer
lwrptr:	    dw	0	    ;5b55   List buffer pointer
rdptr:	    dw	0	    ;5b57   Source buffer pointer
	    dw	0	    ;5b59   ???
;
;   Default extension filename
;
ExtREL:	    db	'REL'	    ;5b5b
ExtCRF:	    db	'CRF'	    ;5b5e
ExtPRN:	    db	'PRN'	    ;5b61
;
BF$OBJ: ds  RELlen*reclng   ;5b64   Object buffer
BF$LST: ds  LSTlen*reclng   ;5c64   List buffer
BF$SRC: ds  SRClen*reclng   ;5e64   Source buffer
;
l6064h: db  '?Command error',null
l6073h: db  '?File not found',null
l6083h: db  '?Can''t enter file',null
;
;   Print string from ^HL to console
;
PrString:
    ld a,(hl)		;6095	Get next
    and 07fh		;6096	Reset bit 7
    ret z		;6098	Zero is end
    call conout		;6099	.. print
    inc hl		;609c
    jp PrString		;609d
;
; -> Command error
;
l60a0h:
    ld hl,l6064h	;60a0	hl="Command error"
    jp l60afh		;60a3	Give message -> Restart
;
; -> File not found
;
l60a6h:
    ld hl,l6073h	;60a6	hl="?File not found"
    jp l60afh		;60a9	Give message -> Restart
;
; -> File not to be entered
;
l60ach:
    ld hl,l6083h	;60ac	hl="?Can't enter file"
l60afh:
    call PrString	;60af	Give message
    jp Restart		;60b2	--> Restart

;   %%% NO MYSTERIOUS CODE %%%

;
;   Parse command line (Continue main)
;
l60b5h:
    ld (TmpAdr),hl	;60b5	Save address Start F80

;   %%% NO MYSTERIOUS CODE %%%

    ld hl,(TPATOP)	;60b8	(BDOS+1) Get top of memory
    dec hl		;60bb
    ld sp,hl		;60bc	Set for stack
    dec hl		;60bd
    dec hl		;60be
    ld (vStack),hl	;60bf	Save address
    ld hl,(TmpAdr)	;60c2	Get entry address
    push hl		;60c5	Save return address
    ld a,(CCPflg)	;60c6	Get CCP line flag
    or a		;60c9	Test if from CCP
    jp nz,00000h	;60ca	.. yeap, exit
    ld (ExtStk),a	;60cd	(ExtStk)=0 Clear extra stack page count
;
;   Restart
;
Restart:	;<--;
    ld hl,(vStack)  ;	;60d0	Reload stack
    ld sp,hl	    ;	;60d3
    call ComLin	    ;	;60d4	Prepare command line
    ld a,(ConLin)   ;	;60d7	Get first character
    cp cr	    ;	;60da	Test empty command line (0dh)
    jr z,Restart ;--+	;60dc	.. yeap, retry
    xor a		;60de	a=0
    ld (PRNCol),a	;60df	Clear printer column
    ld (enaLST),a	;60e2	Clear /L option
    ld (NoCode),a	;60e5	Clear /N option
    ld (HexFlg),a	;60e8	Clear /O option
    ld (LstFlg),a	;60eb	Clear /C list file flag
    ld (enaOBJ),a	;60ee	Clear REL file flag
    ld (RomFlg),a	;60f1	Clear /M option
    inc a		;60f4	a=1
    ld (StkFlg),a	;60f5	Set /P flag
    ld bc,l60a0h	;60f8	bc='Command error'
    push bc		;60fb	Set error return
    xor a		;60fc	a=0
    ld (RELflg),a	;60fd	Set REL file found
    call parse_file	;6100	Scan line for filename and options
    ret c		;6103	if Error Return
    ld de,ExtREL	;6104	Set "REL"
    call set_EXT	;6107	.. as extension
    ld de,l5af5h	;610a	Point to name
    ld a,(de)		;610d
    cp ' '		;610e	.. check the specified name
    jp nz,l6118h ;--;	;6110	.. yeap
    ld a,080h	    ;	;6113	a=10000000b
    ld (RELflg),a   ;	;	Set no REL file
l6118h:		;<--+
    push hl		;6118
    ld hl,F$OBJ		;6119
    call s_6221h	;611c	Unpack REL file
    pop hl		;611f
    ld a,' '		;6120
    ld (l5af5h),a	;6122	Clear name and extension
    ld (l5afdh),a	;6125
    xor a		;6128	a=0
    ld (l5af4h),a	;6129	Set default drive
    ld a,c		;612c
    sub ','		;612d	Test file delimiter
    or a		;612f
    ld (enaOBJ),a	;6130	.. set REL file flag
    jp nz,l6142h ;--;	;6133	.. nope
    ld a,(RELflg)   ;	;6136	Get REL file flag
    xor 10000000b   ;	;6139	Toggle bit
    ld (enaOBJ),a   ;	;613b	0x00 if REL file empty
    call parse_file ;	;613e	Parse file
    ret c	    ;	;6141	return if Error
l6142h:		;<--+
    ld de,ExtPRN	;6142	Take .PRN
    ld a,(LstFlg)	;6145	Get list file flag
    or a		;6148	Test type
    jr z,l614eh	 ;--;	;6149
    ld de,ExtCRF    ;	;614b	Take .CRF
l614eh:		;<--+
    call set_EXT	;614e	.. set as extension
    ld de,l5af5h	;6151	Point to name
    ld a,(l5af4h)	;6154
    ld (l5a66h),a	;6157	Save drive *d*
    ld a,(de)		;615a
    sub ' '		;615b	Test empty file
    ld (l5a65h),a	;615d
    jr nz,l616ah ;--;	;6160	Nope
    ld a,(RELflg)   ;	;6162	Get REL file flag
    add a,01000000b ;	;6165	Insert bit
    ld (RELflg),a   ;	;6167
l616ah:		;<--+
    push hl		;616a
    ld hl,F$LST		;616b *f*
    call s_6221h	;616e	Unpack list file
    pop hl		;6171
    ld a,c		;6172	Get last character
    cp '='		;6173	Must be assignment
    scf			;6175
    ret nz		;6176
    call parse_file	;6177	Parse file
    cp 0dh		;617a	Must be last entry
    scf			;617c
    ret nz		;617d
    ld de,l0320h	;617e	Get .FOR
    call set_EXT	;6181	.. set as extension
    ld de,l5af4h	;6184
    ld a,(de)		;6187	Get drive
    inc de		;6188
    or a		;6189	Test character I/O
    jp m,l6192h ;---;	;618a	Yeap
    ld a,(de)	    ;	;618d
    cp ' '	    ;	;618e	Verify not empty source file
    scf		    ;	;6190
    ret z	    ;	;6191
l6192h:		;<--+
    push hl		;6192
    ld hl,F$SRC		;6193
    call s_6221h	;6196	Unpack source file
    pop hl		;6199
    ld a,(RELflg)	;619a	Get REL file flag
    add a,a		;619d	Test REL file empty
    ld hl,F$OBJ		;619e	Point to REL file
    call c,s_6203h	;61a1	Empty REL file, ^HL=Parsed FCB
    add a,a		;61a4
    ld hl,F$LST		;61a5	Point to list file *f*
    push af		;61a8
    ld a,(LstFlg)	;61a9	Get list file flag
    or a		;61ac	Test type
    jr z,l61c0h	 ;----; ;61ad	Got .PRN
    ld de,F$LST+_DRV+_NAM   ;61af   de=5a9bh *f*
    ld bc,ExtCRF      ; ;61b2	.. .CRF
    ld a,3	      ; ;61b5	a=_EXT
l61b7h:		;<--; ;
      push af	    ; ; ;61b7
      ld a,(bc)	    ; ; ;61b8	Set extension
      ld (de),a	    ; ; ;61b9
      inc de	    ; ; ;61ba
      inc bc	    ; ; ;61bb
      pop af	    ; ; ;61bc
      dec a	    ; ; ;61bd
    jr nz,l61b7h ;--+ ; ;61be
l61c0h:		;<----+
    pop af		;61c0	Test list file selected
    call c,s_6203h	;61c1	Empty list file, ^HL=Parsed FCB
    ld a,(enaLST)	;61c4
    or a		;61c7	Test /L
    jr nz,l61d3h ;--;	;61c8	if(enaLST).ne.0 -->
    ld a,(l5a65h)   ;	;61ca
    or a	    ;	;61cd	Test list file selected
    jr nz,l61d3h ;--;	;61ce	Yeap
    ld a,(l5a66h)   ;	;61d0	*d*
l61d3h:		;<--+
    ld (enaLST),a	;61d3	Set /L
    ld c,019h		;61d6	c=retdsk (Return current drive)
    call BDOS		;61d8	Get current disk
    push af		;61db
    ld c,00dh		;61dc	c=resdsk (Reset discs)
    call BDOS		;61de	Reset entire disk system
    pop af		;61e1
    ld e,a		;61e2
    ld c,00eh		;61e3	c=seldsk (Select disc)
    call BDOS		;61e5	.. log original one only
    xor a		;61e8	a=0
    ld (CCPbuf),a	;61e9	Force empty line
    call sreset		;61ec	Open source file
    call lrewrite	;61ef	Create list file
    call orewrite	;61f2	Create REL file
    pop hl		;61f5	Clean error return
    ld hl,(vStack)	;61f6	Get back top address
    inc hl		;61f9
    inc hl		;61fa
    ld a,(StkFlg)	;61fb	Get /P flag
    ld (ExtStk),a	;61fe	(ExtStk)=(StkFlg)
    ld b,a		;6201
    ret			;6202	Return to Start F80 (l06aeh)
;*
;*  Unpack ^HL with parsed FCB
;*
s_6203h:
    push af		    ;6203
    ld de,l5af4h	    ;6204   Point to FCB
    ld c,9		    ;6207   c=_DRV+_NAM
    ld a,(hl)		    ;6209   Get drive
    or a		    ;620a   Test empty
    jr nz,l621bh ;------;   ;620b   Nope, go copy
    ld a,(de)		;   ;620d
    or a		;   ;620e   Get parsed device
    jp m,l621bh	 ;------;   ;620f   Got not a file
l6212h:	       ;<--;<-; ;
      ld a,(de)	   ;  ; ;   ;6212
      ld (hl),a	   ;  ; ;   ;6213   Unpack FCB
      inc hl	   ;  ; ;   ;6214
      inc de	   ;  ; ;   ;6215
      dec c	   ;  ; ;   ;6216
    jr nz,l6212h ;-+  ; ;   ;6217
l6219h:		      ; ;
    pop af	      ; ;   ;6219
    ret		      ; ;   ;621a
l621bh:	      ;<------)-+
    dec c	      ;	    ;621b   Fix parameters
    inc hl	      ;	    ;621c
    inc de	      ;	    ;621d
    jp l6212h	 ;----+	    ;621e
;*
;*  Unpack file D:NAME_EXT from ^DE to ^HL
;*
s_6221h:
    dec de		    ;6221   .. fix for drive
    ld b,0ch		    ;6222   b=_DRV+_NAM+_EXT
l6224h:		;<--;
      ld a,(de)	    ;	    ;6224   .. unpack it
      ld (hl),a	    ;	    ;6225
      inc hl	    ;	    ;6226
      inc de	    ;	    ;6227
    djnz l6224h ;---+	    ;6228   dec b
    ret			    ;622a
;*
;*  Set extension of file
;*    ENTRY Reg DE points to extension
;*
set_EXT:
    ld a,(extdot)	    ;622b   Test dot given
    or a		    ;622e
    ret z		    ;622f   .. yeap
    push hl		    ;6230
    ld hl,l5afdh	    ;6231   hl=l3e22+_DRV+_NAM
    ld a,(hl)		    ;6234   .. test any extension here
    cp ' '		    ;6235
    jr nz,l6244h ;---;	    ;6237   .. yeap
    ld b,3	     ;	    ;6239   Set length
l623bh:	    ;<-----; ;
      ld a,(de)	   ; ;	    ;623b   .. unpack extension
      and 07fh	   ; ;	    ;623c   Reset bit 7
      ld (hl),a	   ; ;	    ;623e
      inc hl	   ; ;	    ;623f
      inc de	   ; ;	    ;6240
      dec b	   ; ;	    ;6241
    jr nz,l623bh ;-+ ;	    ;6242
l6244h:	      ;<-----+
    pop hl		    ;6244
    ret			    ;6245
;*
;*  Parse file - Accu holds delimiter character on exit
;*    Carry set indicates error
;*
parse_file:
l6246h:	       ;<----;
    call ChLine	     ;	    ;6246   Check line
    cp ':'	     ;	    ;6249   Test drive/device delimiter
    scf		     ;	    ;624b
    ld a,0	     ;	    ;624c
    jr nz,l6267h ;---)-;    ;624e   .. nope, set default drive
    ld a,b	     ; ;    ;6250   Get length of line
    or a	     ; ;    ;6251   Test empty
    jr z,l6246h ;----+ ;    ;6252   .. yeap, get next
    ex de,hl	       ;    ;6254   .. set pointer
    call GetnCh	       ;    ;6255   Get next char
    ld c,a	       ;    ;6258
    ld a,b	       ;    ;6259   Get back count
    dec a	       ;    ;625a   Test one character for drive
    ld a,c	       ;    ;625b
    jr nz,TstTTY ;---; ;    ;625c   Nope, must be device
    cp 'Z'+1	     ; ;    ;625e   Verify valid drive
    ret nc	     ; ;    ;6260
    cp 'A'	     ; ;    ;6261
    ret c	     ; ;    ;6263
    sub 'A'-1	     ; ;    ;6264   Build drive
    ex de,hl	     ; ;    ;6266
l6267h:	       ;<----)-+
    ld (l5af4h),a    ; ;    ;6267   Save drive
    call nc,ChLine   ; ;    ;626a   Check line
    ld a,b	     ; ;    ;626d   Get length
    cp 00bh	     ; ;    ;626e   Test length _NAM+_EXT
    jr c,l6274h ;--; ; ;    ;6270   In range
    ld b,0bh	   ; ; ;    ;6272   b=_NAM+_EXT.. truncate
l6274h:	       ;<--+ ; ;
    push bc	     ; ;    ;6274
    ex de,hl	     ; ;    ;6275
    push de	     ; ;    ;6276
    ld de,l5af5h     ; ;    ;6277   Point to filename
    inc b	     ; ;    ;627a
l627bh:		;<-; ; ;
      dec b	   ; ; ;    ;627b
      jr z,EndPrs;-)-)-)-;  ;627c
      call GetnCh  ; ; ; ;  ;627e   Get next char
      ld (de),a	   ; ; ; ;  ;6281   Unpack name of file
      inc de	   ; ; ; ;  ;6282
    jp l627bh  ;---+ ; ; ;  ;6283
		     ; ; ;
;*  Test devices     ; ; ;
		     ; ; ;
;*  1 - Test TTY     ; ; ;
		     ; ; ;
TstTTY:		;<---+ ; ;
    cp 'T'	       ; ;  ;6286   Test TTY
    jr nz,TstLST  ;--; ; ;  ;6288   .. nope
    call GetnCh	     ; ; ;  ;628a   Get next char
    cp 'T'	     ; ; ;  ;628d   Verify TTY
    scf		     ; ; ;  ;628f
    ret nz	     ; ; ;  ;6290
    call GetnCh	     ; ; ;  ;6291
    cp 'Y'	     ; ; ;  ;6294
    scf		     ; ; ;  ;6296
    ret nz	     ; ; ;  ;6297
    sbc a,a	     ; ; ;  ;6298   Return 0xFF
    ex de,hl	     ; ; ;  ;6299
    or a	     ; ; ;  ;629a
    jp l6267h ;------)-; ;  ;629b
		     ; ; ;
;*  2 - Test LST     ; ; ;
		     ; ; ;
TstLST:		;<---+ ; ;
    cp 'L'	       ; ;  ;629e   Test LST
    jr nz,TstRDR  ;--; ; ;  ;62a0   .. nope
    call GetnCh	     ; ; ;  ;62a2   Get next char
    cp 'S'	     ; ; ;  ;62a5   Verify LST
    scf		     ; ; ;  ;62a7
    ret nz	     ; ; ;  ;62a8
    call GetnCh	     ; ; ;  ;62a9
    cp 'T'	     ; ; ;  ;62ac
    scf		     ; ; ;  ;62ae
    ret nz	     ; ; ;  ;62af
    ld a,0feh	     ; ; ;  ;62b0   Return 0xFE
    ex de,hl	     ; ; ;  ;62b2
    or a	     ; ; ;  ;62b3
    jp l6267h ;------)-; ;  ;62b4
		     ; ; ;
;*  3 - Test RDR     ; ; ;
		     ; ; ;
TstRDR:		;<---+ ; ;
    cp 'R'	       ; ;  ;62b7   Test RDR
    scf		       ; ;  ;62b9
    ret nz	       ; ;  ;62ba   .. nope
    call GetnCh	       ; ;  ;62bb   Get next char
    cp 'D'	       ; ;  ;62be   Verify RDR
    scf		       ; ;  ;62c0
    ret nz	       ; ;  ;62c1
    cp 'R'	       ; ;  ;62c2
    scf		       ; ;  ;62c4
    ret nz	       ; ;  ;62c5
    ld a,0feh	       ; ;  ;62c6   Return 0xFE
    ex de,hl	       ; ;  ;62c8
    or a	       ; ;  ;62c9
    jp l6267h ;--------+ ;  ;62ca
			 ;
;*  End of parse	 ;
			 ;
EndPrs:		;<-------+
    pop hl		    ;62cd   End of parse
    pop bc		    ;62ce
    ld a,0ah		    ;62cf   a=_NAM+_EXT-1
    sub b		    ;62d1   Test length
    jr c,l62ddh ;----;	    ;62d2
    ex de,hl	     ;	    ;62d4
l62d5h:	    ;<-----; ;
      ld (hl),' '  ; ;	    ;62d5   Blank remainder
      inc hl	   ; ;	    ;62d7
      dec a	   ; ;	    ;62d8
    jp p,l62d5h ;--+ ;	    ;62d9
    ex de,hl	     ;	    ;62dc
l62ddh:		;<---+
    ld a,c		    ;62dd   Get back last character
    ld b,0		    ;62de
    sub '.'		    ;62e0   Test dot
    ld (extdot),a	    ;62e2   Set dot flag
    call z,ChLine	    ;	    Check line if dot
    ex de,hl		    ;62e8   .. get back start
    push de		    ;62e9
    ld de,l5afdh	    ;62ea   Point to extension
    ld a,b		    ;62ed
    cp 4		    ;62ee   _EXT+1 Test length
    jr c,l62f4h ;--;	    ;62f0
    ld b,3	   ;	    ;62f2   Set max extension
l62f4h:		;<-+
    inc b		    ;62f4
l62f5h:		;<----;
      dec b	      ;	    ;62f5
      jr z,l6300h ;---)-;   ;62f6   --> Set option flag
      call GetnCh     ; ;   ;62f8   Get extension character
      ld (de),a	      ; ;   ;62fb   Unpack it
      inc de	      ; ;   ;62fc
    jp l62f5h  ;------+ ;   ;62fd
			;
;*  Set option flag	;
			;
l6300h:	    ;<----------+
    pop hl		    ;6300
l6301h:
    ld a,c		    ;6301
    sub '/'		    ;6302   Test option prefix
    or a		    ;6304
    ld a,c		    ;6305
    ret nz		    ;6306   Nope
    call GetnCh		    ;6307   Get option char
    cp 'L'		    ;630a   Test /L listing
    jr nz,l6317h	    ;630c
    ld (enaLST),a	    ;630e   Enable list file
l6311h:
    call GetnCh		    ;6311   Get next char
    ld c,a		    ;6314   Save it
    jr l6301h		    ;6315   .. test more options
l6317h:
    cp 'N'		    ;6317   Test /N
    jr nz,l6320h	    ;6319
    ld (NoCode),a	    ;631b   Enable flag /N
    jr l6311h		    ;631e
l6320h:
    cp 'O'		    ;6320   Test /O octal listing
    jr nz,l6329h	    ;6322
    ld (HexFlg),a	    ;6324   Enable flag /O
    jr l6311h		    ;6327
l6329h:
    cp 'H'		    ;6329   Test /H
    jr nz,l6333h	    ;632b
    xor a		    ;632d   a=0
    ld (HexFlg),a	    ;632e   Enable flag /H
    jr l6311h		    ;6331
l6333h:
    cp 'C'		    ;6333   Test /C
    jr nz,l633ch	    ;6335
    ld (LstFlg),a	    ;6337   Enable flag /C
    jr l6311h		    ;633a
l633ch:
    cp 'M'		    ;633c   Test /M
    jr nz,l6345h	    ;633e
    ld (RomFlg),a	    ;6340   Enable flag /M
    jr l6311h		    ;6343
l6345h:
    cp 'P'		    ;6345   Test /P
    jr nz,l6352h	    ;6347
    ld a,(StkFlg)	    ;6349
    inc a		    ;634c   a=a+1 Advance /P count
    ld (StkFlg),a	    ;634d   Set flag /P
    jr l6311h		    ;6350
l6352h:
    cp 'I'		    ;6352   Test /I
    jr nz,l635bh	    ;6354
    ld (CpuFlg),a	    ;6356   Enable flag /I
    jr l6311h		    ;6359
l635bh:
    cp 'Z'		    ;635b   Test /Z
    jr nz,l6311h	    ;635d
    xor a		    ;635f   a=0
    ld (CpuFlg),a	    ;6360   Enable flag /Z
    jr l6311h		    ;6363
;*
;*  Count symbolic characters in ^HL
;*  On exit Accu and reg C hold closing character
;*  Reg B holds length of characters
;*  ^HL points to closing character
;*  ^DE holds start of character
;*
ChLine:
    ld b,0		    ;6365   Clear count
    push hl		    ;6367   Save pointer
l6368h:		;<--------;
      call GetnCh	  ; ;6368   Get next char
      cp 'Z'+1		  ; ;636b   Test range A..Z
      jr nc,l637eh  ;---; ; ;636d
      cp '0'		; ; ;636f   or 0..9
      jr c,l637eh   ;---; ; ;6371
      cp 'A'		; ; ;6373
      jr nc,l637bh ;-;	; ; ;6375
      cp '9'+1	     ;	; ; ;6377
      jr nc,l637eh ;-)--; ; ;6379
l637bh:	      ;<-----+	; ;
      inc b		; ; ;637b   Count characters
    jr l6368h	;-------)-+ ;637c
l637eh:	    ;<----------+
    ld c,a		    ;637e   Save closing one
    pop de		    ;637f   Get back start pointer
    ret			    ;6380
;*
;*  Prepare command line (no part of the code)
;*
ComLin:
    push bc		    ;6381
    push de		    ;6382
    ld hl,CCPbuf	    ;6383   Point to CCP line
    ld a,(hl)		    ;6386   Get length
    ld (hl),0		    ;6387   Clear for later
    or a		    ;6389   Test any in buffer
    ld b,a		    ;638a
l638bh:	      ;<----;
      jr z,l63aah ;-)---;   ;638b   Buffer empty
      inc hl	    ;	;   ;638d
      ld a,(hl)	    ;	;   ;638e
      cp ' '	    ;	;   ;638f   Skip leadinf blanks
      jr nz,l6396h;-)-; ;   ;6391
      dec b	    ; ; ;   ;6393
    jr l638bh	 ;--+ ; ;   ;6394
l6396h:	      ;<------+ ;
    ld de,ConSiz	;   ;6396   Init line
    ld a,b		;   ;6399   Get back remaining length
    dec hl		;   ;639a
    inc b		;   ;639b
l639ch:		;<--;	;
      ld (de),a	    ;	;   ;639c   Unpack CCP line
      inc de	    ;	;   ;639d
      inc hl	    ;	;   ;639e
      dec b	    ;	;   ;639f
      jr z,l63a5h ;-)-; ;   ;63a0
      ld a,(hl)	    ; ; ;   ;63a2
    jr l639ch	;---+ ; ;   ;63a3
l63a5h:		  ;<--+ ;
    ld (CCPflg),a	;   ;63a5   Set stop flag
    jr l63c9h	;-----; ;   ;63a8
l63aah:	      ;<------)-+
    xor a	      ;	    ;63aa
    ld (CCPflg),a     ;	    ;63ab   Reset stop flag
    ld a,(ExtStk)     ;	    ;63ae
    or a	      ;	    ;63b1
    jr nz,l63bch ;--; ;	    ;63b2
    call n_line	    ; ;	    ;63b4   Close console line
    ld a,'*'	    ; ;	    ;63b7
    call conout	    ; ;	    ;63b9   Indicate input requested
l63bch:		 ;<-+ ;
    ld c,0ah	      ;	    ;63bc   rdcon (Buffered console input)
    ld de,ConBuf      ;	    ;63be
    call BDOS	      ;	    ;63c1   Read line from keyboard
    ld a,lf	      ;	    ;63c4
    call conout	      ;	    ;63c6   close line
l63c9h:		;<----+
    pop de		    ;63c9
    pop bc		    ;63ca
    ld a,(ConSiz)	    ;63cb   Get length of command
    ld hl,ConLin	    ;63ce   Init command pointer
    push hl		    ;63d1
    ld (ConPtr),hl	    ;63d2   .. init console pointer
    add a,l		    ;63d5
    ld l,a		    ;63d6   Point to end
    ld a,0		    ;63d7
    adc a,h		    ;63d9
    ld h,a		    ;63da
    ld (hl),cr		    ;63db   Close command line
    inc hl		    ;63dd
    ld a,lf		    ;63de
    ld (hl),a		    ;63e0
    pop hl		    ;63e1
;
;   no part of the code
;
    ret			    ;63e2
;*
;*  Get next character from buffer ^HL
;*    Carry set indicates end of file
;*
GetnCh:
l63e3h:	      ;<--;
    ld a,(hl)	  ;	;63e3	Get character
    inc hl	  ;	;63e4
    cp ' '	  ;	;63e5	Skip blanks
    jr z,l63e3h ;-;	;63e7
    cp lf	  ;	;63e9	and line feeds
    jr z,l63e3h ;-+	;63eb
    cp cr		;63ed	Test return
    jr nz,TstEOF	;63ef	Nope -> Test end of file
    inc hl		;63f1
    ld (ConPtr),hl	;63f2	.. set pointer
    ret			;63f5
;*
;*  Put character on stack to console
;*
outCON:
    pop af		;63f6	Get character back
;*
;*  Put character in Accu to console
;*
conout:
    push hl		;63f7
    push de		;63f8
    push bc		;63f9
    push af		;63fa
    ld c,2		;63fb	c=conout (Console output)
;   and 07fh		;3029	Less hi bit
    ld e,a		;63fd
    call BDOS		;63fe	Put to console
    pop af		;6401
    pop bc		;6402
    pop de		;6403
    pop hl		;6404
    or a		;6405
    ret			;6406
;*
;*  Get character from command buffer
;*    EXIT  Accu holds character
;*    Carry set on end of file
;*    (Fall in error if so)
;*
getchr:
    push hl		;6407
    ld hl,(ConPtr)	;6408	Get command pointer
    dec hl		;640b
    ld a,(hl)		;640c	Get from buffer
    and 07fh		;640d	Less hi bit
    cp lf		;640f	Test end of line
    inc hl		;6411
    call z,ComLin	;6412	Get new command line if end
    inc hl		;6415
    ld (ConPtr),hl	;6416	Set new pointer
    dec hl		;6419
l641ah:
    ld a,(hl)		;641a	Get character
    pop hl		;641b
TstEOF:
    cp eof		;641c	Test end of file
    scf			;641e	Set carry to indicate error
    ret z		;641f	.. yeap
    or a		;6420	Clear carry
    ret			;6421
;*
;*  Close console line
;*
n_line:
    ld a,cr		;6422
    call conout		;6424	Put new line to console
    ld a,lf		;6427
    jp conout		;6429
;*
;*  Create list file
;*
lrewrite:
    push af		;642c
    push bc		;642d
    push de		;642e
    push hl		;642f
    ld de,BF$LST	;6430	Get FCB list buffer
    ld hl,00000h	;6433
    ld (lwrptr),hl	;6436	Clear buffer position
    ld hl,F$LST		;6439	Point to list file *f*
    ld a,(enaLST)	;643c	Get /L option
    jp Create_file	;643f	Create file
;*
;*  Create REL file
;*
orewrite:
    push af		;6442
    push bc		;6443
    push de		;6444
    push hl		;6445
    ld de,BF$OBJ	;6446	Get FCB object buffer
    ld hl,00000h	;6449
    ld (owrptr),hl	;644c	Clear buffer position
    ld hl,F$OBJ		;644f	Point to REL file
    ld a,(enaOBJ)	;6452	Get /R option
;*
;*  Create file
;*    ENTRY Reg DE points to file buffer
;*	    Reg HL points to FCB
;*	    Accu   holds enable flag
;*
Create_file:
    or a		;6455	Test file enabled
    jr z,l6485h	 ;--;	;6456	.. nope
    push hl	    ;	;6458
    ld c,1ah	    ;	;6459	c=setdma (Set DMA address)
    call BDOS	    ;	;645b	Set disk buffer
    pop hl	    ;	;645e
    ld a,(hl)	    ;	;645f	Test character device
    or a	    ;	;6460
    jp m,l6485h	 ;--;	;6461	.. yeap
    call clr_FCB    ;	;6464	Prepare FCB
    push de	    ;	;6467
    ld c,13h	    ;	;6468	c=delete (delete file)
    call BDOS	    ;	;646a	Delete existent file
    pop de	    ;	;646d
    push de	    ;	;646e
    ld c,16h	    ;	;646f	c=make (create file)
    call BDOS	    ;	;6471	Create new file
    inc a	    ;	;6474	Test success
    jp z,l60ach	    ;	;6475	.. error -> File not to be entered
    pop hl	    ;	;6478
		    ;
;*  Open file ^DE   ;
		    ;
l6479h:		    ;
    call clr_FCB    ;	;6479	Clear parts of FCB
    ld c,0fh	    ;	;647c	c=open (Open file)
    call BDOS	    ;	;647e	Reopen file
    inc a	    ;	;6481	Test success
    jp z,l60a6h	    ;	;6482	.. error -> File not found
l6485h:		;<--+
    pop hl		;6485
    pop de		;6486
    pop bc		;6487
    pop af		;6488
    ret			;6489
;*
;*  Open source file
;*
sreset:
    push af		    ;648a
    push bc		    ;648b
    push de		    ;648c
    push hl		    ;648d
    ld hl,SRClen*reclng	    ;648e   hl=0200h
    ld (rdptr),hl	    ;6491   Init source buffer position
    ld de,BF$SRC	    ;6494
    ld c,1ah		    ;6497   c=setdma (Set DMA address)
    call BDOS		    ;6499   Set disk buffer
    ld hl,F$SRC		    ;649c   Point to source device
    ld a,(hl)		    ;649f   Test char device (CON/RDR)
    or a		    ;64a0
    jp m,l6485h		    ;64a1   .. Yeap, skip it
    jp l6479h		    ;64a4   --> Open file
;*
;*  Clear parts of FCB in ^HL
;*
clr_FCB:
    push hl		;64a7
    push de		;64a8
    ld de,0000ch	;64a9	de=_EX
    add hl,de		;64ac	Point to extent
    xor a		;64ad
    ld d,4		;64ae
l64b0h:		;<--;
      ld (hl),a	    ;	;64b0	.. clear next bytes
      inc hl	    ;	;64b1
      dec d	    ;	;64b2
    jr nz,l64b0h ;--+	;64b3
    ld de,00010h	;64b5	de=_CR-_EX-4
    add hl,de		;64b8
    ld (hl),a		;64b9	Clear current record
    pop hl		;64ba
    pop de		;64bb
    ret			;64bc
;*
;*  Close source file
;*
sclose:
    push af		;64bd
    push de		;64be
    ld de,F$SRC		;64bf	Point to source device
    ld a,(de)		;64c2
    or a		;64c3	Test CON/RDR
    jp m,l64ddh	 ;--;	;64c4	.. yeap
    push bc	    ;	;64c7
    push hl	    ;	;64c8
    push de	    ;	;64c9
    ld de,BF$SRC    ;	;64ca
    ld c,1ah	    ;	;64cd	c=setdma (Set DMA address)
    call BDOS	    ;	;64cf	Set disk buffer
    pop de	    ;	;64d2
    db 1	    ;	;64d3	ld bc,0e5c5h (in the original)	trap_ms
		    ;
;*  Close file ^DE  ;
		    ;
l64d4h:		    ;
    push bc	    ;	;64d4
    push hl	    ;	;64d5
    ld c,10h	    ;	;64d6	c=close
    call BDOS	    ;	;64d8	.. close file
    pop hl	    ;	;64db
    pop bc	    ;	;64dc
l64ddh:		;<--+
    pop de		;64dd
    pop af		;64de
    ret			;64df
;*
;*  Close list file
;*
lclose:
    push af		;64e0
    ld a,(enaLST)	;64e1	Test list file /L
    or a		;64e4
    jp z,l6219h		;64e5	if(enaLST).eq.0 --> ..nope
    push de		;64e8
    ld a,(F$LST)	;64e9	Get list device *f*
    inc a		;64ec	Test console
    jr z,l64ddh		;64ed	.. yeap
    jp m,l6567h		;64ef	.. skip if other
    ld a,cr		;64f2	a=cr
    call lput		;64f4	Give new line
    ld a,lf		;64f7	a=lf
    call lput		;64f9
    ld a,eof		;64fc	a=eof
    call lput		;64fe	.. close file
    push hl		;6501
    ld hl,(lwrptr)	;6502	Get buffer pointer
    ld de,BF$LST	;6505	Get buffer
    push bc		;6508
    ld bc,F$LST		;6509	Point to list file *f*
    call Calc_num_rec	;650c	Empty buffer
    ld de,BF$LST	;650f
    ld c,1ah		;6512	c=setdma (Set DMA address)
    call BDOS		;6514	Set disk buffer
    pop bc		;6517
    pop hl		;6518
    ld de,F$LST		;6519	Point to list file *f*
    jp l64d4h		;651c	Close file ^DE	trap_ms (064d4h) ***
;*
;*  Close REL file
;*
oclose:
    push af		;651f
    ld a,(enaOBJ)	;6520	Test REL file enabled
    or a		;6523
    jp z,l6219h		;6524	.. no REL file
    push de		;6527
    ld a,(F$OBJ)	;6528	Get REL file device
    or a		;652b	Test file
    jp m,l64ddh		;652c	.. nope
    ld a,eof		;652f	a=eof
    call oput		;6531	Write end of file
    push hl		;6534
    ld hl,(owrptr)	;6535	Get REL buffer pointer
    ld de,BF$OBJ	;6538	Get buffer
    push bc		;653b
    ld bc,F$OBJ		;653c	Point to REL file
    call Calc_num_rec	;653f	Empty buffer
    ld de,BF$OBJ	;6542
    ld c,1ah		;6545	c=setdma (Set DMA address)
    call BDOS		;6547	Set disk buffer
    pop bc		;654a
    pop hl		;654b
    ld de,F$OBJ		;654c	Point to REL file
    jp l64d4h		;654f	Close file ^DE	trap_ms (064d4h) ***
;*
;*  Calculate number of records
;*
Calc_num_rec:
    ld a,h		;6552
    or l		;6553	Test any in buffer
    ret z		;6554	Nope
    ld a,l		;6555
    and reclng-1	;6556	Mask pointer
    jr z,l655ch	 ;--;	;6558
    add a,reclng    ;	;655a	Add carry
l655ch:		;<--+
    rla			;655c
    rla			;655d
    and 3		;655e
    add hl,hl		;6560
    add a,h		;6561	Calculate record count
    ld h,b		;6562	Get FCB
    ld l,c		;6563
    jp wrtrec		;6564	Write buffer to disk
;*
;*  Close printer page
;*
l6567h:
    ld a,cr		;6567	a=cr
    call lput		;6569	Close line
    ld a,lf		;656c	a=lf
    call lput		;656e
    ld a,ff		;6571	a=ff
    call lput		;6573	.. give form feed
    pop de		;6576
    pop af		;6577
    ret			;6578
;*
;*  Put character to list device
;*
lput:
    push af		    ;6579   Save character
    ld a,(enaLST)	    ;657a
    or a		    ;657d   Test list file enabled /L
    jp z,l6219h		    ;657e   if(enaLST).eq.0 --> (pop af ret)
    ld a,(F$LST)	    ;6581   Get list device  *f*
    inc a		    ;6584
    jp z,outCON		    ;6585   0xFF is CON
    jp m,outLST		    ;6588   0xFE is LST
    ex (sp),hl		    ;658b
    push hl		    ;658c
    push de		    ;658d
    ld hl,(lwrptr)	    ;658e   Get list buffer pointer
    ld a,h		    ;6591
    cp HIGH(LSTlen*reclng)  ;6592   Test buffer filled (2)
    call z,lwrrec	    ;6594   .. write record if filled
    inc hl		    ;6597   Advance position
    ld (lwrptr),hl	    ;6598
    ld de,BF$LST-1	    ;659b   de=5c63h *f*
    add hl,de		    ;659e
    pop de		    ;659f
    pop af		    ;65a0
    push af		    ;65a1
    and 07fh		    ;65a2   Reset bit 7
    ld (hl),a		    ;65a4   .. store character
    pop af		    ;65a5
    pop hl		    ;65a6
    ret			    ;65a7
;*
;*  Write buffer to list file
;*
lwrrec:			    ;	    Init parameters
    ld de,BF$LST	    ;65a8     Point to list buffer
    ld hl,F$LST		    ;65ab     Point to list file *f*
    ld a,LSTlen		    ;65ae     Set length (a=4)
;*
;*  Write A records to file ^HL with buffer ^DE
;*
wrtrec:
    push af		;65b0
    push bc		;65b1
    push de		;65b2
    push hl		;65b3
    ld c,01ah		;65b4	c=setdma (Set DMA address)
    call BDOS		;65b6	Set disk buffer
    pop de		;65b9
    push de		;65ba
    ld c,015h		;65bb	c=wrseq (Write next record)
    call BDOS		;65bd	Write record
    or a		;65c0	Test success
    jp nz,dskful	;65c1	Nope, disk full
    pop de		;65c4
    pop hl		;65c5
    ld bc,reclng	;65c6	bc=080h
    add hl,bc		;65c9	Advance to next address
    ex de,hl		;65ca
    pop bc		;65cb
    pop af		;65cc
    dec a		;65cd	Count down
    jr nz,wrtrec	;65ce
    ld hl,00000h	;65d0	Return base position
    ret			;65d3
;*
;*  Write buffer to REL file
;*
owrrec:			;	Init parameters:
    ld de,BF$OBJ	;65d4	  Point to object buffer
    ld a,RELlen		;65d7	  Set length (a=2)
    ld hl,F$OBJ		;65d9	  Point to object file
    jp wrtrec		;65dc	Write buffer
;*
;*  Put byte to REL file
;*
oput:
    push af		;65df	Save byte
    ld a,(enaOBJ)	;65e0	Test REL file enabled
    or a		;65e3
    jp z,l6219h		;65e4	.. nope
    ld a,(F$OBJ)	;65e7	Test character device
    or a		;65ea
    jp m,outCON		;65eb	.. yeap, Put character to console
    ex (sp),hl		;65ee
    push hl		;65ef
    push de		;65f0
    ld hl,(owrptr)	;65f1	Get ut character to console
    ld a,h		;65f4
    dec a		;65f5	Test buffer filled
    call z,owrrec	;65f6	.. write buffer if so
    inc hl		;65f9
    ld (owrptr),hl	;65fa	Update pointer
    ld de,BF$OBJ-1	;65fd	de=5b63h
    add hl,de		;6600	Get address
    pop de		;6601
    pop af		;6602
    ld (hl),a		;6603	Store byte
    pop hl		;6604
    ret			;6605
;*
;*  Get character from source file
;*  Carry set indicates end of file
;*
sget:
    ld a,(F$SRC)	    ;6606   Point to source file
    inc a		    ;6609   Test char device
    jp z,getchr		    ;660a   0xFF is from console
    jp m,getio		    ;660d   0xFE is from auxiliary device
    push hl		    ;6610
    push de		    ;6611
    ld hl,(rdptr)	    ;6612   Get source buffer pointer
    ld a,h		    ;6615   Test buffer done
    cp HIGH(SRClen*reclng)  ;6616   2
    call z,rdrec	    ;6618   .. yeap, read new record
    inc hl		    ;661b
    ld (rdptr),hl	    ;661c   Update pointer
    ld de,BF$SRC-1	    ;661f   de=5e63h
    add hl,de		    ;6622   Position buffer
    pop de		    ;6623
    jp l641ah		    ;6624   Get character
;*
;*  Read buffer from source file
;*
rdrec:
    ld de,BF$SRC	;6627	Point to buffer
    ld a,SRClen		;662a	Get record count (a=4)
l662ch:		;<--;
    push af	    ;	;662c
    push de	    ;	;662d
    push bc	    ;	;662e
    ld c,01ah	    ;	;662f	c=setdma (Set DMA address)
    call BDOS	    ;	;6631	Set buffer
    ld de,F$SRC	    ;	;6634	Point to source file
    ld c,014h	    ;	;6637	c=rdseq (read next record)
    call BDOS	    ;	;6639	Read from source file
    pop bc	    ;	;663c
    pop de	    ;	;663d
    dec a	    ;	;663e	Test end of file
    jr z,l664eh ;---)-; ;663f	Yeap
    ld hl,reclng    ; ; ;6641	hl=080h
    add hl,de	    ; ; ;6644	Advance address
    ex de,hl	    ; ; ;6645
    pop af	    ; ; ;6646
    dec a	    ; ; ;6647
    jr nz,l662ch ;--+ ; ;6648
l664ah:		      ;
    ld hl,00000h ;<-; ; ;664a	Return zero position
    ret		    ; ; ;664d
		    ; ;
l664eh:		;<--)-+
    pop af	    ;	;664e
    ld a,eof	    ;	;664f	a=eof
    ld (de),a	    ;	;6651	Set end of file
    jp l664ah ;-----+	;6652
;*
;*  0xFF is to console from lput
;*
outLST:
    pop af		;6655	Get character
    push hl		;6656
    push de		;6657
    push bc		;6658
    push af		;6659
    ld c,5		;665a	c=lstout Set BDOS code
;   and 07fh			Clear high bit
    ld e,a		;665c	Save character
    ld hl,PRNCol	;665d	Point to printer column
    cp ' '		;6660	Test printable
    jr nc,l666eh ;--;	;6662	Yeap
    sub cr	    ;	;6664	Test start of line
    jr z,l666ch ;-; ;	;6666	Yeap
    inc a	  ; ;	;6668	Test form feed
    jr z,l666ch ;-; ;	;6669	Yeap
    ld a,(hl)	  ; ;	;666b	Get current column
l666ch:	      ;<--+ ;
    dec a	    ;	;666c	Get previous column
    ld (hl),a	    ;	;666d	Save
l666eh:	      ;<----+
    inc (hl)		;666e	Advance column
    ld a,e		;666f	Get character
    cp tab		;6670	Test tabulator
    jr nz,l6681h ;----; ;6672	Nope
l6674h:	      ;<----; ;
      ld a,' '	    ; ; ;6674
      call lput	    ; ; ;6676	Put ' ' to list device
      ld a,(hl)	    ; ; ;6679	Get position
      and 007h	    ; ; ;667a	Test tab stop 00000111b
    jr nz,l6674h ;--+ ; ;667c	Nope
    jp l6684h	 ;-;  ; ;667e
		   ;  ;
l6681h:	     ;<----)--+
    call BDOS	   ;	;6681	Put to printer
l6684h:	     ;<----+
    pop af		;6684
    pop bc		;6685
    pop de		;6686
    pop hl		;6687
    ret			;6688
;*
;*  Get character from paper tape reader (auxiliary device)
;*
getio:
    push hl		;6689
    push de		;668a
    push bc		;668b
    ld c,3		;668c	c=rdr
    call BDOS		;668e	Get character
    pop bc		;6691
    pop de		;6692
    pop hl		;6693
    cp eof		;6694	Test end of file
    scf			;6696	Set carry to indicate error
    ret z		;6697
    or a		;6698	Clear carry
    ret			;6699
;
s_669ah:
    ret			;669a
;*
;*  Print message disk full
;*
dskful:
    ld hl,l66bah	;669b	'DISK '
    call PrString	;669e	Give error message
    pop de		;66a1
    ld a,(de)		;66a2	Get drive
    add a,'A'-1		;66a3	Make ASCII
    cp 'A'-1		;66a5	Test default drive
    jr nz,l66abh ;--;	;66a7	Nope
    ld a,' '	    ;	;66a9	Print blank if default
l66abh:		;<--+
    call conout		;66ab	Print drive
    ld hl,l66c0h	;66ae	' FULL'
    call PrString	;66b1	Give error message
    call n_line		;66b4
    jp 00000h		;66b7	jp OS
;
l66bah: db  'DISK ',null    ;66ba
l66c0h: db  ' FULL',null    ;66c0

;#################
;# END MODULE	 #
;#################

;#################
;# START MODULE	 #
;#################
;
;   Table service data in the symbol table
;
l66c6h:
    db 0,0,0,0		    ;66c6   (l01b0h)(l01a4h)(l0214h)(HeapPtr) [66c6]
    dw 0,0		    ;66ca
    db 11h		    ;66ce   00 010 001
    db 4		    ;66cf
offs0	equ $-l66c6h
;
    db 0ffh,0ffh,0ffh,0ffh  ;66d0
    dw 0,0		    ;66d4
    db 11h		    ;66d8   00 010 001
    db 4		    ;66d9		     [FA0E]
offs1	equ $-l66c6h
;
    db 0,0,0,0		    ;66da
    dw 0,0		    ;66de
    db 1		    ;66e2   00 000 001
    db 4		    ;66e3   (l02b0h)	     [FA18]
offs2	equ $-l66c6h
;
    defb 1,0,0,0	    ;66e4
    dw 0,0		    ;66e8
    db 1		    ;66ec   00 000 001
    db 4		    ;66ed   (l023eh)	     [FA2C]
offs3	equ $-l66c6h
;
    db 2,0,0,0		    ;66ee
    dw 0,0		    ;66f2
    db 1		    ;66f6   00 000 001
    db 4		    ;66f7   (l02a0h)	     [FA36]
offs4	equ $-l66c6h
;
    db 0,0,0,0		    ;66f8
    dw 0,0		    ;66fc
    db 9		    ;6700   00 001 001
    db 4		    ;6701   (l02b2h)	     [FA40]
offs5	equ $-l66c6h
;
    db 0,0,0,0,0,0,0,0	    ;6702
    dw 0,0		    ;670a
    db 019h		    ;670e   00 011 001
    db 8		    ;670f   (l02aeh)	     [FA4E]
offs6	equ $-l66c6h
;
    db 0,0,0,81h	    ;6710
    dw 0,0		    ;6714
    db 9		    ;6718   00 001 001
    db 4		    ;6719   (l0240h)	     [FA58]
offs7	equ $-l66c6h
;
    db 0,0,0,0,0,0,0,81h    ;671a
    dw 0,0		    ;6722
    db 19h		    ;6726   00 011 001
    db 8		    ;6727   (l023ch)(l031ch) [FA66]
lent1	equ $-l66c6h	    ;00062h
;
;   Table Intrinsic Functions in the symbol table
;
	;-Name
	;
IntrFun:
    db 'SBA',	0,0, 0,0, 0dh, 3     ;6728  'ABS'  [fa67]
    db 'SBAI',	0,0, 0,0, 05h, 4     ;6731  'IABS' [fa70]
    db 'TNIA',	0,0, 0,0, 0dh, 4     ;673b  'AINT'
    db 'TNI',	0,0, 0,0, 05h, 3     ;6745  'INT'
    db 'TNIDI', 0,0, 0,0, 05h, 5     ;674e  'IDINT'
    db 'DOMA',	0,0, 0,0, 0dh, 4     ;6759  'AMOD'
    db 'DOM',	0,0, 0,0, 05h, 3     ;6763  'MOD'
    db 'TAOLF', 0,0, 0,0, 0dh, 5     ;674e  'FLOAT'
    db 'XIFI',	0,0, 0,0, 05h, 4     ;6777  'IFIX'
    db 'NGIS',	0,0, 0,0, 0dh, 4     ;6781  'SIGN'
    db 'NGISI', 0,0, 0,0, 05h, 5     ;678b  'ISIGN'
    db 'MID',	0,0, 0,0, 0dh, 3     ;6796  'DIM'
    db 'MIDI',	0,0, 0,0, 05h, 4     ;679f  'IDIM'
    db 'ELGNS', 0,0, 0,0, 0dh, 5     ;67a9  'SNGLE'
    db 'PXE',	0,0, 0,0, 0dh, 3     ;67b4  'EXP'
    db 'GOLA',	0,0, 0,0, 0dh, 4     ;673b  'ALOG'
    db '01GOLA',0,0, 0,0, 0dh, 6     ;67c7  'ALOG10'
    db 'NIS',	0,0, 0,0, 0dh, 3     ;67d3  'SIN'
    db 'SOC',	0,0, 0,0, 0dh, 3     ;67dc  'COS'
    db 'HNAT',	0,0, 0,0, 0dh, 4     ;67e5  'TANH'
    db 'TRQS',	0,0, 0,0, 0dh, 4     ;67ef  'SQRT'
    db 'NATA',	0,0, 0,0, 0dh, 4     ;67f9  'ATAN'
    db '2NATA', 0,0, 0,0, 0dh, 5     ;6803  'ATAN2'
    db 'KEEP',	0,0, 0,0, 15h, 4     ;680e  'PEEK'
    db 'PNI',	0,0, 0,0, 15h, 3     ;6818  'INP'
    db 'SBAD',	0,0, 0,0, 1dh, 4     ;6821  'DABS'
    db 'NGISD', 0,0, 0,0, 1dh, 5     ;682b  'DSIGN'
    db 'ELBD',	0,0, 0,0, 1dh, 4     ;6836  'DBLE'
    db 'PXED',	0,0, 0,0, 1dh, 4     ;6840  'DEXP'
    db 'GOLD',	0,0, 0,0, 1dh, 4     ;684a  'DLOG'
    db '01GOLD',0,0, 0,0, 1dh, 6     ;6854  'DLOG10'
    db 'NISD',	0,0, 0,0, 1dh, 4     ;6860  'DSIN'
    db 'SOCD',	0,0, 0,0, 1dh, 4     ;686a  'DCOS'
    db 'TRQSD', 0,0, 0,0, 1dh, 5     ;6874  'DSQRT'
    db 'NATAD', 0,0, 0,0, 1dh, 5     ;687f  'DATAN'
    db '2NATAD',0,0, 0,0, 1dh, 6     ;688a  'DATAN2'
    db 'DOMD',	0,0, 0,0, 1dh, 4     ;6896  'DMOD'
    db '0I$',	0,0, 0,0, 0dh, 3     ;68a0  '$I0'   Transfers integers into the I/O buffer
    db '1I$',	0,0, 0,0, 0dh, 3     ;68a9  '$I1'   Transfers real numbers
    db '2I$',	0,0, 0,0, 0dh, 3     ;68b2  '$I2'   Transfers logicals
    db '4I$',	0,0, 0,0, 0dh, 3     ;68bb  '$I4'   Transfers extended integers (4 bytes)
    db '3I$',	0,0, 0,0, 0dh, 3     ;68c4  '$I3'   Transfers double precision numbers
    db '1XAMD', 0,0, 0,0, 1dh, 5     ;68cd  'DMAX1'
    db '1NIMD', 0,0, 0,0, 1dh, 5     ;68d8  'DMIN1'
    db '0NIMA', 0,0, 0,0, 0dh, 5     ;68e3  'AMIN0'
    db '1NIMA', 0,0, 0,0, 0dh, 5     ;68ee  'AMIN1'
    db '0NIM',	0,0, 0,0, 05h, 4     ;68f9  'MIN0'
    db '1NIM',	0,0, 0,0, 05h, 4     ;6903  'MIN1'
    db '1XAM',	0,0, 0,0, 05h, 4     ;690d  'MAX1'
    db '0XAM',	0,0, 0,0, 05h, 4     ;6917  'MAX0'
    db '1XAMA', 0,0, 0,0, 0dh, 5     ;6921  'AMAX1'
    db '0XAMA', 0,0, 0,0, 0dh, 5     ;692c  'AMAX0'

lent2	equ $-IntrFun		     ;0020fh

;#################
;# END MODULE	 #
;#################

    end
;-----------------------------------------------
.COMMENT *

    defb 030h	    ;6937   30	0
    defb 000h	    ;6938   00	.
    defb 000h	    ;6939   00	.
    defb 000h	    ;693a   00	.
    defb 000h	    ;693b   00	.
    defb 000h	    ;693c   00	.
    defb 000h	    ;693d   00	.
    defb 000h	    ;693e   00	.
    defb 000h	    ;693f   00	.
    defb 000h	    ;6940   00	.
    defb 000h	    ;6941   00	.
    defb 000h	    ;6942   00	.
    defb 000h	    ;6943   00	.
    defb 000h	    ;6944   00	.
    defb 000h	    ;6945   00	.
    defb 000h	    ;6946   00	.
    defb 000h	    ;6947   00	.
    defb 000h	    ;6948   00	.
    defb 000h	    ;6949   00	.
    defb 000h	    ;694a   00	.
    defb 000h	    ;694b   00	.
    defb 000h	    ;694c   00	.
    defb 000h	    ;694d   00	.
    defb 000h	    ;694e   00	.
    defb 000h	    ;694f   00	.
    defb 000h	    ;6950   00	.
    defb 000h	    ;6951   00	.
    defb 000h	    ;6952   00	.
    defb 000h	    ;6953   00	.
    defb 000h	    ;6954   00	.
    defb 000h	    ;6955   00	.
    defb 000h	    ;6956   00	.
    defb 000h	    ;6957   00	.
    defb 000h	    ;6958   00	.
    defb 000h	    ;6959   00	.
    defb 000h	    ;695a   00	.
    defb 000h	    ;695b   00	.
    defb 01ah	    ;695c   1a	.
    defb 01ah	    ;695d   1a	.
    defb 01ah	    ;695e   1a	.
    defb 01ah	    ;695f   1a	.
    defb 01ah	    ;6960   1a	.
    defb 01ah	    ;6961   1a	.
    defb 01ah	    ;6962   1a	.
    defb 01ah	    ;6963   1a	.
    defb 01ah	    ;6964   1a	.
    defb 01ah	    ;6965   1a	.
    defb 01ah	    ;6966   1a	.
    defb 01ah	    ;6967   1a	.
    defb 01ah	    ;6968   1a	.
    defb 01ah	    ;6969   1a	.
    defb 01ah	    ;696a   1a	.
    defb 01ah	    ;696b   1a	.
    defb 01ah	    ;696c   1a	.
    defb 01ah	    ;696d   1a	.
    defb 01ah	    ;696e   1a	.
    defb 01ah	    ;696f   1a	.
    defb 01ah	    ;6970   1a	.
    defb 01ah	    ;6971   1a	.
    defb 01ah	    ;6972   1a	.
    defb 01ah	    ;6973   1a	.
    defb 01ah	    ;6974   1a	.
    defb 01ah	    ;6975   1a	.
    defb 01ah	    ;6976   1a	.
    defb 01ah	    ;6977   1a	.
    defb 01ah	    ;6978   1a	.
    defb 01ah	    ;6979   1a	.
    defb 01ah	    ;697a   1a	.
    defb 01ah	    ;697b   1a	.
    defb 01ah	    ;697c   1a	.
    defb 01ah	    ;697d   1a	.
    defb 01ah	    ;697e   1a	.
    defb 01ah	    ;697f   1a	.
    defb 041h	    ;6980   41	A
    defb 054h	    ;6981   54	T
    defb 041h	    ;6982   41	A
    defb 044h	    ;6983   44	D
    defb 000h	    ;6984   00	.
    defb 000h	    ;6985   00	.
    defb 000h	    ;6986   00	.
    defb 000h	    ;6987   00	.
    defb 01dh	    ;6988   1d	.
    defb 005h	    ;6989   05	.
    defb 032h	    ;698a   32	2
    defb 04eh	    ;698b   4e	N
    defb 041h	    ;698c   41	A
    defb 054h	    ;698d   54	T
    defb 041h	    ;698e   41	A
    defb 044h	    ;698f   44	D
    defb 000h	    ;6990   00	.
    defb 000h	    ;6991   00	.
    defb 000h	    ;6992   00	.
    defb 000h	    ;6993   00	.
    defb 01dh	    ;6994   1d	.
    defb 006h	    ;6995   06	.
    defb 044h	    ;6996   44	D
    defb 04fh	    ;6997   4f	O
    defb 04dh	    ;6998   4d	M
    defb 044h	    ;6999   44	D
    defb 000h	    ;699a   00	.
    defb 000h	    ;699b   00	.
    defb 000h	    ;699c   00	.
    defb 000h	    ;699d   00	.
    defb 01dh	    ;699e   1d	.
    defb 004h	    ;699f   04	.
    defb 030h	    ;69a0   30	0
    defb 049h	    ;69a1   49	I
    defb 024h	    ;69a2   24	$
    defb 000h	    ;69a3   00	.
    defb 000h	    ;69a4   00	.
    defb 000h	    ;69a5   00	.
    defb 000h	    ;69a6   00	.
    defb 00dh	    ;69a7   0d	.
    defb 003h	    ;69a8   03	.
    defb 031h	    ;69a9   31	1
    defb 049h	    ;69aa   49	I
    defb 024h	    ;69ab   24	$
    defb 000h	    ;69ac   00	.
    defb 000h	    ;69ad   00	.
    defb 000h	    ;69ae   00	.
    defb 000h	    ;69af   00	.
    defb 00dh	    ;69b0   0d	.
    defb 003h	    ;69b1   03	.
    defb 032h	    ;69b2   32	2
    defb 049h	    ;69b3   49	I
    defb 024h	    ;69b4   24	$
    defb 000h	    ;69b5   00	.
    defb 000h	    ;69b6   00	.
    defb 000h	    ;69b7   00	.
    defb 000h	    ;69b8   00	.
    defb 00dh	    ;69b9   0d	.
    defb 003h	    ;69ba   03	.
    defb 034h	    ;69bb   34	4
    defb 049h	    ;69bc   49	I
    defb 024h	    ;69bd   24	$
    defb 000h	    ;69be   00	.
    defb 000h	    ;69bf   00	.
    defb 000h	    ;69c0   00	.
    defb 000h	    ;69c1   00	.
    defb 00dh	    ;69c2   0d	.
    defb 003h	    ;69c3   03	.
    defb 033h	    ;69c4   33	3
    defb 049h	    ;69c5   49	I
    defb 024h	    ;69c6   24	$
    defb 000h	    ;69c7   00	.
    defb 000h	    ;69c8   00	.
    defb 000h	    ;69c9   00	.
    defb 000h	    ;69ca   00	.
    defb 00dh	    ;69cb   0d	.
    defb 003h	    ;69cc   03	.
    defb 031h	    ;69cd   31	1
    defb 058h	    ;69ce   58	X
    defb 041h	    ;69cf   41	A
    defb 04dh	    ;69d0   4d	M
    defb 044h	    ;69d1   44	D
    defb 000h	    ;69d2   00	.
    defb 000h	    ;69d3   00	.
    defb 000h	    ;69d4   00	.
    defb 000h	    ;69d5   00	.
    defb 01dh	    ;69d6   1d	.
    defb 005h	    ;69d7   05	.
    defb 031h	    ;69d8   31	1
    defb 04eh	    ;69d9   4e	N
    defb 049h	    ;69da   49	I
    defb 04dh	    ;69db   4d	M
    defb 044h	    ;69dc   44	D
    defb 000h	    ;69dd   00	.
    defb 000h	    ;69de   00	.
    defb 000h	    ;69df   00	.
    defb 000h	    ;69e0   00	.
    defb 01dh	    ;69e1   1d	.
    defb 005h	    ;69e2   05	.
    defb 030h	    ;69e3   30	0
    defb 04eh	    ;69e4   4e	N
    defb 049h	    ;69e5   49	I
    defb 04dh	    ;69e6   4d	M
    defb 041h	    ;69e7   41	A
    defb 000h	    ;69e8   00	.
    defb 000h	    ;69e9   00	.
    defb 000h	    ;69ea   00	.
    defb 000h	    ;69eb   00	.
    defb 00dh	    ;69ec   0d	.
    defb 005h	    ;69ed   05	.
    defb 031h	    ;69ee   31	1
    defb 04eh	    ;69ef   4e	N
    defb 049h	    ;69f0   49	I
    defb 04dh	    ;69f1   4d	M
    defb 041h	    ;69f2   41	A
    defb 000h	    ;69f3   00	.
    defb 000h	    ;69f4   00	.
    defb 000h	    ;69f5   00	.
    defb 000h	    ;69f6   00	.
    defb 00dh	    ;69f7   0d	.
    defb 005h	    ;69f8   05	.
    defb 030h	    ;69f9   30	0
    defb 04eh	    ;69fa   4e	N
    defb 049h	    ;69fb   49	I
    defb 04dh	    ;69fc   4d	M
    defb 000h	    ;69fd   00	.
    defb 000h	    ;69fe   00	.
    defb 000h	    ;69ff   00	.
    defb 08fh	    ;6a00   8f	.
    defb 0e7h	    ;6a01   e7	.
    defb 089h	    ;6a02   89	.
    defb 0e8h	    ;6a03   e8	.
    defb 09ch	    ;6a04   9c	.
    defb 0e8h	    ;6a05   e8	.
    defb 02eh	    ;6a06   2e	.
    defb 076h	    ;6a07   76	v
    defb 005h	    ;6a08   05	.
    defb 0a0h	    ;6a09   a0	.
    defb 08ah	    ;6a0a   8a	.
    defb 098h	    ;6a0b   98	.
    defb 0c3h	    ;6a0c   c3	.
    defb 079h	    ;6a0d   79	y
    defb 06fh	    ;6a0e   6f	o
    defb 0aah	    ;6a0f   aa	.
    defb 032h	    ;6a10   32	2
    defb 03ah	    ;6a11   3a	:
    defb 027h	    ;6a12   27	'
    defb 0e8h	    ;6a13   e8	.
    defb 061h	    ;6a14   61	a
    defb 053h	    ;6a15   53	S
    defb 067h	    ;6a16   67	g
    defb 0f9h	    ;6a17   f9	.
    defb 082h	    ;6a18   82	.
    defb 0d2h	    ;6a19   d2	.
    defb 05dh	    ;6a1a   5d	]
    defb 000h	    ;6a1b   00	.
    defb 0b7h	    ;6a1c   b7	.
    defb 01ah	    ;6a1d   1a	.
    defb 004h	    ;6a1e   04	.
    defb 0ddh	    ;6a1f   dd	.
    defb 0c5h	    ;6a20   c5	.
    defb 0aeh	    ;6a21   ae	.
    defb 000h	    ;6a22   00	.
    defb 094h	    ;6a23   94	.
    defb 0eeh	    ;6a24   ee	.
    defb 002h	    ;6a25   02	.
    defb 0b8h	    ;6a26   b8	.
    defb 0d9h	    ;6a27   d9	.
    defb 020h	    ;6a28   20
    defb 064h	    ;6a29   64	d
    defb 077h	    ;6a2a   77	w
    defb 099h	    ;6a2b   99	.
    defb 066h	    ;6a2c   66	f
    defb 03ch	    ;6a2d   3c	<
    defb 02ah	    ;6a2e   2a	*
    defb 0ddh	    ;6a2f   dd	.
    defb 005h	    ;6a30   05	.
    defb 060h	    ;6a31   60	`
    defb 06bh	    ;6a32   6b	k
    defb 0aah	    ;6a33   aa	.
    defb 032h	    ;6a34   32	2
    defb 03ah	    ;6a35   3a	:
    defb 027h	    ;6a36   27	'
    defb 02ch	    ;6a37   2c	,
    defb 036h	    ;6a38   36	6
    defb 0afh	    ;6a39   af	.
    defb 07bh	    ;6a3a   7b	{
    defb 040h	    ;6a3b   40	@
    defb 0e9h	    ;6a3c   e9	.
    defb 02eh	    ;6a3d   2e	.
    defb 080h	    ;6a3e   80	.
    defb 09bh	    ;6a3f   9b	.
    defb 00dh	    ;6a40   0d	.
    defb 082h	    ;6a41   82	.
    defb 0eeh	    ;6a42   ee	.
    defb 062h	    ;6a43   62	b
    defb 057h	    ;6a44   57	W
    defb 000h	    ;6a45   00	.
    defb 02ah	    ;6a46   2a	*
    defb 0b5h	    ;6a47   b5	.
    defb 01ah	    ;6a48   1a	.
    defb 0fah	    ;6a49   fa	.
    defb 0deh	    ;6a4a   de	.
    defb 020h	    ;6a4b   20
    defb 064h	    ;6a4c   64	d
    defb 077h	    ;6a4d   77	w
    defb 036h	    ;6a4e   36	6
    defb 02ch	    ;6a4f   2c	,
    defb 045h	    ;6a50   45	E
    defb 0e6h	    ;6a51   e6	.
    defb 055h	    ;6a52   55	U
    defb 0d1h	    ;6a53   d1	.
    defb 0e6h	    ;6a54   e6	.
    defb 0c0h	    ;6a55   c0	.
    defb 0cdh	    ;6a56   cd	.
    defb 054h	    ;6a57   54	T
    defb 065h	    ;6a58   65	e
    defb 055h	    ;6a59   55	U
    defb 016h	    ;6a5a   16	.
    defb 097h	    ;6a5b   97	.
    defb 08fh	    ;6a5c   8f	.
    defb 0e9h	    ;6a5d   e9	.
    defb 07dh	    ;6a5e   7d	}
    defb 0bah	    ;6a5f   ba	.
    defb 027h	    ;6a60   27	'
    defb 05dh	    ;6a61   5d	]
    defb 0a6h	    ;6a62   a6	.
    defb 0c7h	    ;6a63   c7	.
    defb 0efh	    ;6a64   ef	.
    defb 03fh	    ;6a65   3f	?
    defb 09fh	    ;6a66   9f	.
    defb 0a7h	    ;6a67   a7	.
    defb 07bh	    ;6a68   7b	{
    defb 07eh	    ;6a69   7e	~
    defb 03ch	    ;6a6a   3c	<
    defb 04fh	    ;6a6b   4f	O
    defb 044h	    ;6a6c   44	D
    defb 0e7h	    ;6a6d   e7	.
    defb 0a4h	    ;6a6e   a4	.
    defb 018h	    ;6a6f   18	.
    defb 0eah	    ;6a70   ea	.
    defb 0e2h	    ;6a71   e2	.
    defb 0c5h	    ;6a72   c5	.
    defb 026h	    ;6a73   26	&
    defb 0abh	    ;6a74   ab	.
    defb 08ah	    ;6a75   8a	.
    defb 098h	    ;6a76   98	.
    defb 0c3h	    ;6a77   c3	.
    defb 0bch	    ;6a78   bc	.
    defb 035h	    ;6a79   35	5
    defb 055h	    ;6a7a   55	U
    defb 019h	    ;6a7b   19	.
    defb 09dh	    ;6a7c   9d	.
    defb 013h	    ;6a7d   13	.
    defb 074h	    ;6a7e   74	t
    defb 017h	    ;6a7f   17	.
    defb 096h	    ;6a80   96	.
    defb 0a1h	    ;6a81   a1	.
    defb 0c8h	    ;6a82   c8	.
    defb 072h	    ;6a83   72	r
    defb 055h	    ;6a84   55	U
    defb 0b4h	    ;6a85   b4	.
    defb 00eh	    ;6a86   0e	.
    defb 0d8h	    ;6a87   d8	.
    defb 01ah	    ;6a88   1a	.
    defb 084h	    ;6a89   84	.
    defb 062h	    ;6a8a   62	b
    defb 0a8h	    ;6a8b   a8	.
    defb 08bh	    ;6a8c   8b	.
    defb 017h	    ;6a8d   17	.
    defb 09bh	    ;6a8e   9b	.
    defb 0ach	    ;6a8f   ac	.
    defb 04ah	    ;6a90   4a	J
    defb 09dh	    ;6a91   9d	.
    defb 006h	    ;6a92   06	.
    defb 09ch	    ;6a93   9c	.
    defb 041h	    ;6a94   41	A
    defb 028h	    ;6a95   28	(
    defb 086h	    ;6a96   86	.
    defb 0bah	    ;6a97   ba	.
    defb 078h	    ;6a98   78	x
    defb 0b1h	    ;6a99   b1	.
    defb 0c9h	    ;6a9a   c9	.
    defb 02ah	    ;6a9b   2a	*
    defb 0dbh	    ;6a9c   db	.
    defb 006h	    ;6a9d   06	.
    defb 070h	    ;6a9e   70	p
    defb 0b3h	    ;6a9f   b3	.
    defb 0a9h	    ;6aa0   a9	.
    defb 0cah	    ;6aa1   ca	.
    defb 0e8h	    ;6aa2   e8	.
    defb 09ch	    ;6aa3   9c	.
    defb 050h	    ;6aa4   50	P
    defb 00ch	    ;6aa5   0c	.
    defb 075h	    ;6aa6   75	u
    defb 0f1h	    ;6aa7   f1	.
    defb 062h	    ;6aa8   62	b
    defb 093h	    ;6aa9   93	.
    defb 055h	    ;6aaa   55	U
    defb 04bh	    ;6aab   4b	K
    defb 0bbh	    ;6aac   bb	.
    defb 081h	    ;6aad   81	.
    defb 07eh	    ;6aae   7e	~
    defb 035h	    ;6aaf   35	5
    defb 008h	    ;6ab0   08	.
    defb 055h	    ;6ab1   55	U
    defb 059h	    ;6ab2   59	Y
    defb 095h	    ;6ab3   95	.
    defb 0c5h	    ;6ab4   c5	.
    defb 0e5h	    ;6ab5   e5	.
    defb 063h	    ;6ab6   63	c
    defb 07ah	    ;6ab7   7a	z
    defb 09fh	    ;6ab8   9f	.
    defb 0eeh	    ;6ab9   ee	.
    defb 049h	    ;6aba   49	I
    defb 097h	    ;6abb   97	.
    defb 0e9h	    ;6abc   e9	.
    defb 0f1h	    ;6abd   f1	.
    defb 0fbh	    ;6abe   fb	.
    defb 0cfh	    ;6abf   cf	.
    defb 0e7h	    ;6ac0   e7	.
    defb 0e9h	    ;6ac1   e9	.
    defb 09eh	    ;6ac2   9e	.
    defb 01fh	    ;6ac3   1f	.
    defb 0cfh	    ;6ac4   cf	.
    defb 013h	    ;6ac5   13	.
    defb 0d1h	    ;6ac6   d1	.
    defb 039h	    ;6ac7   39	9
    defb 059h	    ;6ac8   59	Y
    defb 006h	    ;6ac9   06	.
    defb 05fh	    ;6aca   5f	_
    defb 077h	    ;6acb   77	w
    defb 045h	    ;6acc   45	E
    defb 08fh	    ;6acd   8f	.
    defb 02ah	    ;6ace   2a	*
    defb 062h	    ;6acf   62	b
    defb 08eh	    ;6ad0   8e	.
    defb 0bbh	    ;6ad1   bb	.
    defb 0f5h	    ;6ad2   f5	.
    defb 0a6h	    ;6ad3   a6	.
    defb 02ah	    ;6ad4   2a	*
    defb 0a3h	    ;6ad5   a3	.
    defb 073h	    ;6ad6   73	s
    defb 082h	    ;6ad7   82	.
    defb 08dh	    ;6ad8   8d	.
    defb 0beh	    ;6ad9   be	.
    defb 0ceh	    ;6ada   ce	.
    defb 0adh	    ;6adb   ad	.
    defb 0aeh	    ;6adc   ae	.
    defb 095h	    ;6add   95	.
    defb 06bh	    ;6ade   6b	k
    defb 067h	    ;6adf   67	g
    defb 0a0h	    ;6ae0   a0	.
    defb 037h	    ;6ae1   37	7
    defb 008h	    ;6ae2   08	.
    defb 036h	    ;6ae3   36	6
    defb 01fh	    ;6ae4   1f	.
    defb 0eah	    ;6ae5   ea	.
    defb 02bh	    ;6ae6   2b	+
    defb 0a0h	    ;6ae7   a0	.
    defb 0dah	    ;6ae8   da	.
    defb 0b6h	    ;6ae9   b6	.
    defb 005h	    ;6aea   05	.
    defb 07ah	    ;6aeb   7a	z
    defb 083h	    ;6aec   83	.
    defb 0a0h	    ;6aed   a0	.
    defb 0bbh	    ;6aee   bb	.
    defb 03ch	    ;6aef   3c	<
    defb 0ebh	    ;6af0   eb	.
    defb 001h	    ;6af1   01	.
    defb 0d5h	    ;6af2   d5	.
    defb 0b6h	    ;6af3   b6	.
    defb 02dh	    ;6af4   2d	-
    defb 0b8h	    ;6af5   b8	.
    defb 0d9h	    ;6af6   d9	.
    defb 054h	    ;6af7   54	T
    defb 065h	    ;6af8   65	e
    defb 074h	    ;6af9   74	t
    defb 04eh	    ;6afa   4e	N
    defb 048h	    ;6afb   48	H
    defb 0d9h	    ;6afc   d9	.
    defb 0c1h	    ;6afd   c1	.
    defb 033h	    ;6afe   33	3
    defb 01eh	    ;6aff   1e	.
    defb 055h	    ;6b00   55	U
    defb 0dbh	    ;6b01   db	.
    defb 0b6h	    ;6b02   b6	.
    defb 040h	    ;6b03   40	@
    defb 06fh	    ;6b04   6f	o
    defb 010h	    ;6b05   10	.
    defb 0b2h	    ;6b06   b2	.
    defb 034h	    ;6b07   34	4
    defb 0d4h	    ;6b08   d4	.
    defb 05dh	    ;6b09   5d	]
    defb 00eh	    ;6b0a   0e	.
    defb 0aah	    ;6b0b   aa	.
    defb 06dh	    ;6b0c   6d	m
    defb 05bh	    ;6b0d   5b	[
    defb 060h	    ;6b0e   60	`
    defb 035h	    ;6b0f   35	5
    defb 008h	    ;6b10   08	.
    defb 0d9h	    ;6b11   d9	.
    defb 0e6h	    ;6b12   e6	.
    defb 0cbh	    ;6b13   cb	.
    defb 090h	    ;6b14   90	.
    defb 077h	    ;6b15   77	w
    defb 01bh	    ;6b16   1b	.
    defb 054h	    ;6b17   54	T
    defb 06ah	    ;6b18   6a	j
    defb 035h	    ;6b19   35	5
    defb 0d0h	    ;6b1a   d0	.
    defb 09bh	    ;6b1b   9b	.
    defb 0aah	    ;6b1c   aa	.
    defb 08ch	    ;6b1d   8c	.
    defb 0ceh	    ;6b1e   ce	.
    defb 009h	    ;6b1f   09	.
    defb 087h	    ;6b20   87	.
    defb 053h	    ;6b21   53	S
    defb 07dh	    ;6b22   7d	}
    defb 0cah	    ;6b23   ca	.
    defb 033h	    ;6b24   33	3
    defb 050h	    ;6b25   50	P
    defb 0a9h	    ;6b26   a9	.
    defb 0fdh	    ;6b27   fd	.
    defb 002h	    ;6b28   02	.
    defb 0ach	    ;6b29   ac	.
    defb 006h	    ;6b2a   06	.
    defb 061h	    ;6b2b   61	a
    defb 0e8h	    ;6b2c   e8	.
    defb 018h	    ;6b2d   18	.
    defb 07fh	    ;6b2e   7f	
    defb 0a9h	    ;6b2f   a9	.
    defb 0b6h	    ;6b30   b6	.
    defb 06dh	    ;6b31   6d	m
    defb 081h	    ;6b32   81	.
    defb 0bdh	    ;6b33   bd	.
    defb 041h	    ;6b34   41	A
    defb 018h	    ;6b35   18	.
    defb 06ah	    ;6b36   6a	j
    defb 0ddh	    ;6b37   dd	.
    defb 06dh	    ;6b38   6d	m
    defb 012h	    ;6b39   12	.
    defb 0a8h	    ;6b3a   a8	.
    defb 0b6h	    ;6b3b   b6	.
    defb 06dh	    ;6b3c   6d	m
    defb 081h	    ;6b3d   81	.
    defb 0b3h	    ;6b3e   b3	.
    defb 0a9h	    ;6b3f   a9	.
    defb 0cah	    ;6b40   ca	.
    defb 0e8h	    ;6b41   e8	.
    defb 09ch	    ;6b42   9c	.
    defb 050h	    ;6b43   50	P
    defb 074h	    ;6b44   74	t
    defb 04fh	    ;6b45   4f	O
    defb 083h	    ;6b46   83	.
    defb 006h	    ;6b47   06	.
    defb 054h	    ;6b48   54	T
    defb 0dbh	    ;6b49   db	.
    defb 0b6h	    ;6b4a   b6	.
    defb 040h	    ;6b4b   40	@
    defb 06fh	    ;6b4c   6f	o
    defb 010h	    ;6b4d   10	.
    defb 042h	    ;6b4e   42	B
    defb 016h	    ;6b4f   16	.
    defb 0bah	    ;6b50   ba	.
    defb 0c5h	    ;6b51   c5	.
    defb 083h	    ;6b52   83	.
    defb 06ah	    ;6b53   6a	j
    defb 0dbh	    ;6b54   db	.
    defb 016h	    ;6b55   16	.
    defb 058h	    ;6b56   58	X
    defb 00dh	    ;6b57   0d	.
    defb 042h	    ;6b58   42	B
    defb 018h	    ;6b59   18	.
    defb 0bch	    ;6b5a   bc	.
    defb 066h	    ;6b5b   66	f
    defb 03ch	    ;6b5c   3c	<
    defb 0aah	    ;6b5d   aa	.
    defb 0b6h	    ;6b5e   b6	.
    defb 06dh	    ;6b5f   6d	m
    defb 081h	    ;6b60   81	.
    defb 0d5h	    ;6b61   d5	.
    defb 054h	    ;6b62   54	T
    defb 065h	    ;6b63   65	e
    defb 074h	    ;6b64   74	t
    defb 04eh	    ;6b65   4e	N
    defb 058h	    ;6b66   58	X
    defb 0a2h	    ;6b67   a2	.
    defb 0f5h	    ;6b68   f5	.
    defb 059h	    ;6b69   59	Y
    defb 00fh	    ;6b6a   0f	.
    defb 0aah	    ;6b6b   aa	.
    defb 06dh	    ;6b6c   6d	m
    defb 05bh	    ;6b6d   5b	[
    defb 070h	    ;6b6e   70	p
    defb 037h	    ;6b6f   37	7
    defb 083h	    ;6b70   83	.
    defb 0b0h	    ;6b71   b0	.
    defb 00ch	    ;6b72   0c	.
    defb 0beh	    ;6b73   be	.
    defb 0eeh	    ;6b74   ee	.
    defb 02dh	    ;6b75   2d	-
    defb 028h	    ;6b76   28	(
    defb 0ddh	    ;6b77   dd	.
    defb 032h	    ;6b78   32	2
    defb 01eh	    ;6b79   1e	.
    defb 067h	    ;6b7a   67	g
    defb 083h	    ;6b7b   83	.
    defb 0b0h	    ;6b7c   b0	.
    defb 00ch	    ;6b7d   0c	.
    defb 0beh	    ;6b7e   be	.
    defb 0eeh	    ;6b7f   ee	.
    defb 023h	    ;6b80   23	#
    defb 028h	    ;6b81   28	(
    defb 0ddh	    ;6b82   dd	.
    defb 032h	    ;6b83   32	2
    defb 01eh	    ;6b84   1e	.
    defb 057h	    ;6b85   57	W
    defb 053h	    ;6b86   53	S
    defb 095h	    ;6b87   95	.
    defb 0d1h	    ;6b88   d1	.
    defb 039h	    ;6b89   39	9
    defb 061h	    ;6b8a   61	a
    defb 019h	    ;6b8b   19	.
    defb 07ch	    ;6b8c   7c	|
    defb 0ddh	    ;6b8d   dd	.
    defb 06bh	    ;6b8e   6b	k
    defb 050h	    ;6b8f   50	P
    defb 0bah	    ;6b90   ba	.
    defb 065h	    ;6b91   65	e
    defb 03ch	    ;6b92   3c	<
    defb 0aeh	    ;6b93   ae	.
    defb 006h	    ;6b94   06	.
    defb 061h	    ;6b95   61	a
    defb 019h	    ;6b96   19	.
    defb 07ch	    ;6b97   7c	|
    defb 0ddh	    ;6b98   dd	.
    defb 027h	    ;6b99   27	'
    defb 050h	    ;6b9a   50	P
    defb 0bah	    ;6b9b   ba	.
    defb 065h	    ;6b9c   65	e
    defb 03ch	    ;6b9d   3c	<
    defb 0ceh	    ;6b9e   ce	.
    defb 006h	    ;6b9f   06	.
    defb 061h	    ;6ba0   61	a
    defb 019h	    ;6ba1   19	.
    defb 07ch	    ;6ba2   7c	|
    defb 0ddh	    ;6ba3   dd	.
    defb 067h	    ;6ba4   67	g
    defb 0a0h	    ;6ba5   a0	.
    defb 074h	    ;6ba6   74	t
    defb 0cbh	    ;6ba7   cb	.
    defb 078h	    ;6ba8   78	x
    defb 0dch	    ;6ba9   dc	.
    defb 09bh	    ;6baa   9b	.
    defb 0aah	    ;6bab   aa	.
    defb 08ch	    ;6bac   8c	.
    defb 0ceh	    ;6bad   ce	.
    defb 009h	    ;6bae   09	.
    defb 0cbh	    ;6baf   cb	.
    defb 0e0h	    ;6bb0   e0	.
    defb 0ebh	    ;6bb1   eb	.
    defb 0aeh	    ;6bb2   ae	.
    defb 000h	    ;6bb3   00	.
    defb 0a5h	    ;6bb4   a5	.
    defb 0bbh	    ;6bb5   bb	.
    defb 000h	    ;6bb6   00	.
    defb 06eh	    ;6bb7   6e	n
    defb 06fh	    ;6bb8   6f	o
    defb 010h	    ;6bb9   10	.
    defb 096h	    ;6bba   96	.
    defb 0c1h	    ;6bbb   c1	.
    defb 0d7h	    ;6bbc   d7	.
    defb 05dh	    ;6bbd   5d	]
    defb 001h	    ;6bbe   01	.
    defb 04ah	    ;6bbf   4a	J
    defb 0b7h	    ;6bc0   b7	.
    defb 08ch	    ;6bc1   8c	.
    defb 0c7h	    ;6bc2   c7	.
    defb 0d9h	    ;6bc3   d9	.
    defb 020h	    ;6bc4   20
    defb 02ch	    ;6bc5   2c	,
    defb 083h	    ;6bc6   83	.
    defb 0afh	    ;6bc7   af	.
    defb 0bbh	    ;6bc8   bb	.
    defb 002h	    ;6bc9   02	.
    defb 0d4h	    ;6bca   d4	.
    defb 0d2h	    ;6bcb   d2	.
    defb 07ah	    ;6bcc   7a	z
    defb 0e8h	    ;6bcd   e8	.
    defb 0cfh	    ;6bce   cf	.
    defb 0a6h	    ;6bcf   a6	.
    defb 02ah	    ;6bd0   2a	*
    defb 0a3h	    ;6bd1   a3	.
    defb 073h	    ;6bd2   73	s
    defb 0c2h	    ;6bd3   c2	.
    defb 032h	    ;6bd4   32	2
    defb 0f8h	    ;6bd5   f8	.
    defb 0dah	    ;6bd6   da	.
    defb 09fh	    ;6bd7   9f	.
    defb 022h	    ;6bd8   22	"
    defb 0cah	    ;6bd9   ca	.
    defb 09fh	    ;6bda   9f	.
    defb 022h	    ;6bdb   22	"
    defb 0e0h	    ;6bdc   e0	.
    defb 00ch	    ;6bdd   0c	.
    defb 042h	    ;6bde   42	B
    defb 09eh	    ;6bdf   9e	.
    defb 0d9h	    ;6be0   d9	.
    defb 0c4h	    ;6be1   c4	.
    defb 078h	    ;6be2   78	x
    defb 054h	    ;6be3   54	T
    defb 0a1h	    ;6be4   a1	.
    defb 065h	    ;6be5   65	e
    defb 03ch	    ;6be6   3c	<
    defb 0deh	    ;6be7   de	.
    defb 00ch	    ;6be8   0c	.
    defb 082h	    ;6be9   82	.
    defb 0afh	    ;6bea   af	.
    defb 0adh	    ;6beb   ad	.
    defb 06eh	    ;6bec   6e	n
    defb 000h	    ;6bed   00	.
    defb 0d5h	    ;6bee   d5	.
    defb 0b6h	    ;6bef   b6	.
    defb 02dh	    ;6bf0   2d	-
    defb 0b0h	    ;6bf1   b0	.
    defb 09ah	    ;6bf2   9a	.
    defb 0aah	    ;6bf3   aa	.
    defb 08ch	    ;6bf4   8c	.
    defb 0ceh	    ;6bf5   ce	.
    defb 009h	    ;6bf6   09	.
    defb 0feh	    ;6bf7   fe	.
    defb 0d3h	    ;6bf8   d3	.
    defb 0ebh	    ;6bf9   eb	.
    defb 06eh	    ;6bfa   6e	n
    defb 0e3h	    ;6bfb   e3	.
    defb 051h	    ;6bfc   51	Q
    defb 06dh	    ;6bfd   6d	m
    defb 0dbh	    ;6bfe   db	.
    defb 002h	    ;6bff   02	.
    defb 0abh	    ;6c00   ab	.
    defb 041h	    ;6c01   41	A
    defb 0f0h	    ;6c02   f0	.
    defb 09fh	    ;6c03   9f	.
    defb 0feh	    ;6c04   fe	.
    defb 08bh	    ;6c05   8b	.
    defb 0cdh	    ;6c06   cd	.
    defb 03dh	    ;6c07   3d	=
    defb 0aah	    ;6c08   aa	.
    defb 06dh	    ;6c09   6d	m
    defb 05bh	    ;6c0a   5b	[
    defb 060h	    ;6c0b   60	`
    defb 06fh	    ;6c0c   6f	o
    defb 010h	    ;6c0d   10	.
    defb 0eah	    ;6c0e   ea	.
    defb 053h	    ;6c0f   53	S
    defb 0ddh	    ;6c10   dd	.
    defb 0e5h	    ;6c11   e5	.
    defb 083h	    ;6c12   83	.
    defb 02dh	    ;6c13   2d	-
    defb 054h	    ;6c14   54	T
    defb 0dbh	    ;6c15   db	.
    defb 0b6h	    ;6c16   b6	.
    defb 0c0h	    ;6c17   c0	.
    defb 09bh	    ;6c18   9b	.
    defb 0a9h	    ;6c19   a9	.
    defb 0cah	    ;6c1a   ca	.
    defb 0e8h	    ;6c1b   e8	.
    defb 09ch	    ;6c1c   9c	.
    defb 0f0h	    ;6c1d   f0	.
    defb 0a5h	    ;6c1e   a5	.
    defb 0d3h	    ;6c1f   d3	.
    defb 036h	    ;6c20   36	6
    defb 002h	    ;6c21   02	.
    defb 0aah	    ;6c22   aa	.
    defb 06dh	    ;6c23   6d	m
    defb 05bh	    ;6c24   5b	[
    defb 060h	    ;6c25   60	`
    defb 036h	    ;6c26   36	6
    defb 008h	    ;6c27   08	.
    defb 055h	    ;6c28   55	U
    defb 059h	    ;6c29   59	Y
    defb 095h	    ;6c2a   95	.
    defb 0f5h	    ;6c2b   f5	.
    defb 03fh	    ;6c2c   3f	?
    defb 01fh	    ;6c2d   1f	.
    defb 0a7h	    ;6c2e   a7	.
    defb 047h	    ;6c2f   47	G
    defb 0deh	    ;6c30   de	.
    defb 0a7h	    ;6c31   a7	.
    defb 047h	    ;6c32   47	G
    defb 0f6h	    ;6c33   f6	.
    defb 033h	    ;6c34   33	3
    defb 0e1h	    ;6c35   e1	.
    defb 0f1h	    ;6c36   f1	.
    defb 05fh	    ;6c37   5f	_
    defb 03fh	    ;6c38   3f	?
    defb 01eh	    ;6c39   1e	.
    defb 027h	    ;6c3a   27	'
    defb 00eh	    ;6c3b   0e	.
    defb 097h	    ;6c3c   97	.
    defb 07fh	    ;6c3d   7f	
    defb 079h	    ;6c3e   79	y
    defb 0fch	    ;6c3f   fc	.
    defb 007h	    ;6c40   07	.
    defb 097h	    ;6c41   97	.
    defb 07fh	    ;6c42   7f	
    defb 063h	    ;6c43   63	c
    defb 0a6h	    ;6c44   a6	.
    defb 0b8h	    ;6c45   b8	.
    defb 07ch	    ;6c46   7c	|
    defb 04ch	    ;6c47   4c	L
    defb 0efh	    ;6c48   ef	.
    defb 0d3h	    ;6c49   d3	.
    defb 0fdh	    ;6c4a   fd	.
    defb 05fh	    ;6c4b   5f	_
    defb 0ffh	    ;6c4c   ff	.
    defb 0f8h	    ;6c4d   f8	.
    defb 0bbh	    ;6c4e   bb	.
    defb 02ah	    ;6c4f   2a	*
    defb 0ffh	    ;6c50   ff	.
    defb 0fch	    ;6c51   fc	.
    defb 021h	    ;6c52   21	!
    defb 0e5h	    ;6c53   e5	.
    defb 0c3h	    ;6c54   c3	.
    defb 097h	    ;6c55   97	.
    defb 04ch	    ;6c56   4c	L
    defb 022h	    ;6c57   22	"
    defb 09ch	    ;6c58   9c	.
    defb 07ch	    ;6c59   7c	|
    defb 096h	    ;6c5a   96	.
    defb 08bh	    ;6c5b   8b	.
    defb 073h	    ;6c5c   73	s
    defb 070h	    ;6c5d   70	p
    defb 018h	    ;6c5e   18	.
    defb 08ah	    ;6c5f   8a	.
    defb 0cch	    ;6c60   cc	.
    defb 0cbh	    ;6c61   cb	.
    defb 08dh	    ;6c62   8d	.
    defb 0f1h	    ;6c63   f1	.
    defb 0c1h	    ;6c64   c1	.
    defb 02fh	    ;6c65   2f	/
    defb 056h	    ;6c66   56	V
    defb 067h	    ;6c67   67	g
    defb 09ch	    ;6c68   9c	.
    defb 07ch	    ;6c69   7c	|
    defb 096h	    ;6c6a   96	.
    defb 064h	    ;6c6b   64	d
    defb 09dh	    ;6c6c   9d	.
    defb 0e7h	    ;6c6d   e7	.
    defb 006h	    ;6c6e   06	.
    defb 0feh	    ;6c6f   fe	.
    defb 072h	    ;6c70   72	r
    defb 0fdh	    ;6c71   fd	.
    defb 06eh	    ;6c72   6e	n
    defb 0d7h	    ;6c73   d7	.
    defb 070h	    ;6c74   70	p
    defb 0c8h	    ;6c75   c8	.
    defb 0b3h	    ;6c76   b3	.
    defb 0ech	    ;6c77   ec	.
    defb 06fh	    ;6c78   6f	o
    defb 07eh	    ;6c79   7e	~
    defb 0ffh	    ;6c7a   ff	.
    defb 0a6h	    ;6c7b   a6	.
    defb 02ah	    ;6c7c   2a	*
    defb 0abh	    ;6c7d   ab	.
    defb 032h	    ;6c7e   32	2
    defb 0bah	    ;6c7f   ba	.
    defb 05eh	    ;6c80   5e	^
    defb 078h	    ;6c81   78	x
    defb 089h	    ;6c82   89	.
    defb 0aeh	    ;6c83   ae	.
    defb 067h	    ;6c84   67	g
    defb 03ch	    ;6c85   3c	<
    defb 02ah	    ;6c86   2a	*
    defb 06dh	    ;6c87   6d	m
    defb 06bh	    ;6c88   6b	k
    defb 060h	    ;6c89   60	`
    defb 06eh	    ;6c8a   6e	n
    defb 010h	    ;6c8b   10	.
    defb 0ech	    ;6c8c   ec	.
    defb 0b0h	    ;6c8d   b0	.
    defb 049h	    ;6c8e   49	I
    defb 0d9h	    ;6c8f   d9	.
    defb 0ddh	    ;6c90   dd	.
    defb 076h	    ;6c91   76	v
    defb 0a7h	    ;6c92   a7	.
    defb 052h	    ;6c93   52	R
    defb 0a7h	    ;6c94   a7	.
    defb 081h	    ;6c95   81	.
    defb 06dh	    ;6c96   6d	m
    defb 083h	    ;6c97   83	.
    defb 060h	    ;6c98   60	`
    defb 087h	    ;6c99   87	.
    defb 03ch	    ;6c9a   3c	<
    defb 0cfh	    ;6c9b   cf	.
    defb 0edh	    ;6c9c   ed	.
    defb 090h	    ;6c9d   90	.
    defb 094h	    ;6c9e   94	.
    defb 00eh	    ;6c9f   0e	.
    defb 009h	    ;6ca0   09	.
    defb 098h	    ;6ca1   98	.
    defb 09bh	    ;6ca2   9b	.
    defb 0aah	    ;6ca3   aa	.
    defb 08ch	    ;6ca4   8c	.
    defb 0aeh	    ;6ca5   ae	.
    defb 017h	    ;6ca6   17	.
    defb 074h	    ;6ca7   74	t
    defb 0b6h	    ;6ca8   b6	.
    defb 0a9h	    ;6ca9   a9	.
    defb 073h	    ;6caa   73	s
    defb 05bh	    ;6cab   5b	[
    defb 067h	    ;6cac   67	g
    defb 04ah	    ;6cad   4a	J
    defb 087h	    ;6cae   87	.
    defb 004h	    ;6caf   04	.
    defb 0cch	    ;6cb0   cc	.
    defb 00dh	    ;6cb1   0d	.
    defb 082h	    ;6cb2   82	.
    defb 0ceh	    ;6cb3   ce	.
    defb 0adh	    ;6cb4   ad	.
    defb 0bfh	    ;6cb5   bf	.
    defb 002h	    ;6cb6   02	.
    defb 04ah	    ;6cb7   4a	J
    defb 087h	    ;6cb8   87	.
    defb 004h	    ;6cb9   04	.
    defb 0cch	    ;6cba   cc	.
    defb 00dh	    ;6cbb   0d	.
    defb 042h	    ;6cbc   42	B
    defb 0cah	    ;6cbd   ca	.
    defb 0f4h	    ;6cbe   f4	.
    defb 090h	    ;6cbf   90	.
    defb 032h	    ;6cc0   32	2
    defb 050h	    ;6cc1   50	P
    defb 0d1h	    ;6cc2   d1	.
    defb 07ah	    ;6cc3   7a	z
    defb 060h	    ;6cc4   60	`
    defb 0dbh	    ;6cc5   db	.
    defb 054h	    ;6cc6   54	T
    defb 065h	    ;6cc7   65	e
    defb 074h	    ;6cc8   74	t
    defb 0bdh	    ;6cc9   bd	.
    defb 090h	    ;6cca   90	.
    defb 032h	    ;6ccb   32	2
    defb 0ddh	    ;6ccc   dd	.
    defb 0a5h	    ;6ccd   a5	.
    defb 00ch	    ;6cce   0c	.
    defb 094h	    ;6ccf   94	.
    defb 00eh	    ;6cd0   0e	.
    defb 009h	    ;6cd1   09	.
    defb 098h	    ;6cd2   98	.
    defb 01bh	    ;6cd3   1b	.
    defb 084h	    ;6cd4   84	.
    defb 0d4h	    ;6cd5   d4	.
    defb 06dh	    ;6cd6   6d	m
    defb 09ah	    ;6cd7   9a	.
    defb 0ech	    ;6cd8   ec	.
    defb 013h	    ;6cd9   13	.
    defb 094h	    ;6cda   94	.
    defb 00eh	    ;6cdb   0e	.
    defb 009h	    ;6cdc   09	.
    defb 0dch	    ;6cdd   dc	.
    defb 0beh	    ;6cde   be	.
    defb 041h	    ;6cdf   41	A
    defb 0c8h	    ;6ce0   c8	.
    defb 08ah	    ;6ce1   8a	.
    defb 02ch	    ;6ce2   2c	,
    defb 064h	    ;6ce3   64	d
    defb 09bh	    ;6ce4   9b	.
    defb 0dah	    ;6ce5   da	.
    defb 0abh	    ;6ce6   ab	.
    defb 068h	    ;6ce7   68	h
    defb 03dh	    ;6ce8   3d	=
    defb 030h	    ;6ce9   30	0
    defb 037h	    ;6cea   37	7
    defb 055h	    ;6ceb   55	U
    defb 019h	    ;6cec   19	.
    defb 05dh	    ;6ced   5d	]
    defb 02fh	    ;6cee   2f	/
    defb 064h	    ;6cef   64	d
    defb 01bh	    ;6cf0   1b	.
    defb 0ddh	    ;6cf1   dd	.
    defb 0a5h	    ;6cf2   a5	.
    defb 00ch	    ;6cf3   0c	.
    defb 094h	    ;6cf4   94	.
    defb 00eh	    ;6cf5   0e	.
    defb 009h	    ;6cf6   09	.
    defb 098h	    ;6cf7   98	.
    defb 01bh	    ;6cf8   1b	.
    defb 084h	    ;6cf9   84	.
    defb 0ech	    ;6cfa   ec	.
    defb 08bh	    ;6cfb   8b	.
    defb 04dh	    ;6cfc   4d	M
    defb 019h	    ;6cfd   19	.
    defb 0a0h	    ;6cfe   a0	.
    defb 074h	    ;6cff   74	t
    defb 048h	    ;6d00   48	H
    defb 0c0h	    ;6d01   c0	.
    defb 0dch	    ;6d02   dc	.
    defb 020h	    ;6d03   20
    defb 05ch	    ;6d04   5c	\
    defb 04fh	    ;6d05   4f	O
    defb 0beh	    ;6d06   be	.
    defb 02eh	    ;6d07   2e	.
    defb 032h	    ;6d08   32	2
    defb 050h	    ;6d09   50	P
    defb 0d1h	    ;6d0a   d1	.
    defb 07ah	    ;6d0b   7a	z
    defb 060h	    ;6d0c   60	`
    defb 06eh	    ;6d0d   6e	n
    defb 0aah	    ;6d0e   aa	.
    defb 032h	    ;6d0f   32	2
    defb 0bah	    ;6d10   ba	.
    defb 05eh	    ;6d11   5e	^
    defb 018h	    ;6d12   18	.
    defb 036h	    ;6d13   36	6
    defb 0deh	    ;6d14   de	.
    defb 06eh	    ;6d15   6e	n
    defb 0b2h	    ;6d16   b2	.
    defb 0edh	    ;6d17   ed	.
    defb 04eh	    ;6d18   4e	N
    defb 045h	    ;6d19   45	E
    defb 0ebh	    ;6d1a   eb	.
    defb 0c1h	    ;6d1b   c1	.
    defb 0f5h	    ;6d1c   f5	.
    defb 00dh	    ;6d1d   0d	.
    defb 0c2h	    ;6d1e   c2	.
    defb 0b0h	    ;6d1f   b0	.
    defb 0f1h	    ;6d20   f1	.
    defb 099h	    ;6d21   99	.
    defb 0aeh	    ;6d22   ae	.
    defb 041h	    ;6d23   41	A
    defb 0e9h	    ;6d24   e9	.
    defb 090h	    ;6d25   90	.
    defb 0c0h	    ;6d26   c0	.
    defb 0f5h	    ;6d27   f5	.
    defb 00dh	    ;6d28   0d	.
    defb 042h	    ;6d29   42	B
    defb 071h	    ;6d2a   71	q
    defb 0cdh	    ;6d2b   cd	.
    defb 08ah	    ;6d2c   8a	.
    defb 005h	    ;6d2d   05	.
    defb 050h	    ;6d2e   50	P
    defb 0f5h	    ;6d2f   f5	.
    defb 05dh	    ;6d30   5d	]
    defb 00dh	    ;6d31   0d	.
    defb 0fdh	    ;6d32   fd	.
    defb 0b6h	    ;6d33   b6	.
    defb 0a9h	    ;6d34   a9	.
    defb 0cah	    ;6d35   ca	.
    defb 0e8h	    ;6d36   e8	.
    defb 07ah	    ;6d37   7a	z
    defb 0a1h	    ;6d38   a1	.
    defb 018h	    ;6d39   18	.
    defb 00eh	    ;6d3a   0e	.
    defb 019h	    ;6d3b   19	.
    defb 0e3h	    ;6d3c   e3	.
    defb 051h	    ;6d3d   51	Q
    defb 0e9h	    ;6d3e   e9	.
    defb 090h	    ;6d3f   90	.
    defb 080h	    ;6d40   80	.
    defb 0b9h	    ;6d41   b9	.
    defb 041h	    ;6d42   41	A
    defb 028h	    ;6d43   28	(
    defb 0eah	    ;6d44   ea	.
    defb 02ch	    ;6d45   2c	,
    defb 00fh	    ;6d46   0f	.
    defb 080h	    ;6d47   80	.
    defb 0d2h	    ;6d48   d2	.
    defb 021h	    ;6d49   21	!
    defb 081h	    ;6d4a   81	.
    defb 0ebh	    ;6d4b   eb	.
    defb 01bh	    ;6d4c   1b	.
    defb 084h	    ;6d4d   84	.
    defb 0d0h	    ;6d4e   d0	.
    defb 0a5h	    ;6d4f   a5	.
    defb 02ch	    ;6d50   2c	,
    defb 000h	    ;6d51   00	.
    defb 04ah	    ;6d52   4a	J
    defb 087h	    ;6d53   87	.
    defb 004h	    ;6d54   04	.
    defb 06ch	    ;6d55   6c	l
    defb 09bh	    ;6d56   9b	.
    defb 0aah	    ;6d57   aa	.
    defb 08ch	    ;6d58   8c	.
    defb 0aeh	    ;6d59   ae	.
    defb 017h	    ;6d5a   17	.
    defb 0c2h	    ;6d5b   c2	.
    defb 0ddh	    ;6d5c   dd	.
    defb 076h	    ;6d5d   76	v
    defb 0c7h	    ;6d5e   c7	.
    defb 078h	    ;6d5f   78	x
    defb 054h	    ;6d60   54	T
    defb 03ah	    ;6d61   3a	:
    defb 024h	    ;6d62   24	$
    defb 060h	    ;6d63   60	`
    defb 06eh	    ;6d64   6e	n
    defb 010h	    ;6d65   10	.
    defb 0bah	    ;6d66   ba	.
    defb 025h	    ;6d67   25	%
    defb 0cbh	    ;6d68   cb	.
    defb 02dh	    ;6d69   2d	-
    defb 0a0h	    ;6d6a   a0	.
    defb 0a2h	    ;6d6b   a2	.
    defb 0f5h	    ;6d6c   f5	.
    defb 0c0h	    ;6d6d   c0	.
    defb 0b6h	    ;6d6e   b6	.
    defb 041h	    ;6d6f   41	A
    defb 0e8h	    ;6d70   e8	.
    defb 0f2h	    ;6d71   f2	.
    defb 027h	    ;6d72   27	'
    defb 0bbh	    ;6d73   bb	.
    defb 001h	    ;6d74   01	.
    defb 094h	    ;6d75   94	.
    defb 00eh	    ;6d76   0e	.
    defb 009h	    ;6d77   09	.
    defb 098h	    ;6d78   98	.
    defb 09bh	    ;6d79   9b	.
    defb 0aah	    ;6d7a   aa	.
    defb 08ch	    ;6d7b   8c	.
    defb 0aeh	    ;6d7c   ae	.
    defb 017h	    ;6d7d   17	.
    defb 0bah	    ;6d7e   ba	.
    defb 0fah	    ;6d7f   fa	.
    defb 09ah	    ;6d80   9a	.
    defb 015h	    ;6d81   15	.
    defb 045h	    ;6d82   45	E
    defb 087h	    ;6d83   87	.
    defb 0d2h	    ;6d84   d2	.
    defb 021h	    ;6d85   21	!
    defb 001h	    ;6d86   01	.
    defb 073h	    ;6d87   73	s
    defb 083h	    ;6d88   83	.
    defb 0e0h	    ;6d89   e0	.
    defb 037h	    ;6d8a   37	7
    defb 0b6h	    ;6d8b   b6	.
    defb 0c9h	    ;6d8c   c9	.
    defb 000h	    ;6d8d   00	.
    defb 0a5h	    ;6d8e   a5	.
    defb 043h	    ;6d8f   43	C
    defb 002h	    ;6d90   02	.
    defb 0e6h	    ;6d91   e6	.
    defb 006h	    ;6d92   06	.
    defb 0c1h	    ;6d93   c1	.
    defb 02fh	    ;6d94   2f	/
    defb 0d7h	    ;6d95   d7	.
    defb 02ch	    ;6d96   2c	,
    defb 0efh	    ;6d97   ef	.
    defb 086h	    ;6d98   86	.
    defb 0a4h	    ;6d99   a4	.
    defb 0a2h	    ;6d9a   a2	.
    defb 0f5h	    ;6d9b   f5	.
    defb 0c0h	    ;6d9c   c0	.
    defb 0dch	    ;6d9d   dc	.
    defb 054h	    ;6d9e   54	T
    defb 065h	    ;6d9f   65	e
    defb 074h	    ;6da0   74	t
    defb 0bdh	    ;6da1   bd	.
    defb 0e0h	    ;6da2   e0	.
    defb 06bh	    ;6da3   6b	k
    defb 05bh	    ;6da4   5b	[
    defb 067h	    ;6da5   67	g
    defb 01eh	    ;6da6   1e	.
    defb 054h	    ;6da7   54	T
    defb 0b4h	    ;6da8   b4	.
    defb 01eh	    ;6da9   1e	.
    defb 098h	    ;6daa   98	.
    defb 01bh	    ;6dab   1b	.
    defb 004h	    ;6dac   04	.
    defb 05fh	    ;6dad   5f	_
    defb 067h	    ;6dae   67	g
    defb 00bh	    ;6daf   0b	.
    defb 0e3h	    ;6db0   e3	.
    defb 051h	    ;6db1   51	Q
    defb 0e9h	    ;6db2   e9	.
    defb 090h	    ;6db3   90	.
    defb 080h	    ;6db4   80	.
    defb 0b9h	    ;6db5   b9	.
    defb 041h	    ;6db6   41	A
    defb 0f0h	    ;6db7   f0	.
    defb 075h	    ;6db8   75	u
    defb 096h	    ;6db9   96	.
    defb 007h	    ;6dba   07	.
    defb 040h	    ;6dbb   40	@
    defb 0e9h	    ;6dbc   e9	.
    defb 090h	    ;6dbd   90	.
    defb 080h	    ;6dbe   80	.
    defb 06dh	    ;6dbf   6d	m
    defb 053h	    ;6dc0   53	S
    defb 095h	    ;6dc1   95	.
    defb 0d1h	    ;6dc2   d1	.
    defb 0f5h	    ;6dc3   f5	.
    defb 082h	    ;6dc4   82	.
    defb 0afh	    ;6dc5   af	.
    defb 0f3h	    ;6dc6   f3	.
    defb 061h	    ;6dc7   61	a
    defb 0f3h	    ;6dc8   f3	.
    defb 004h	    ;6dc9   04	.
    defb 04ah	    ;6dca   4a	J
    defb 087h	    ;6dcb   87	.
    defb 004h	    ;6dcc   04	.
    defb 0cch	    ;6dcd   cc	.
    defb 00dh	    ;6dce   0d	.
    defb 0c2h	    ;6dcf   c2	.
    defb 05dh	    ;6dd0   5d	]
    defb 0e8h	    ;6dd1   e8	.
    defb 052h	    ;6dd2   52	R
    defb 016h	    ;6dd3   16	.
    defb 040h	    ;6dd4   40	@
    defb 0e9h	    ;6dd5   e9	.
    defb 090h	    ;6dd6   90	.
    defb 080h	    ;6dd7   80	.
    defb 0b9h	    ;6dd8   b9	.
    defb 041h	    ;6dd9   41	A
    defb 0b8h	    ;6dda   b8	.
    defb 00bh	    ;6ddb   0b	.
    defb 05dh	    ;6ddc   5d	]
    defb 0cah	    ;6ddd   ca	.
    defb 0c2h	    ;6dde   c2	.
    defb 0bah	    ;6ddf   ba	.
    defb 057h	    ;6de0   57	W
    defb 03ah	    ;6de1   3a	:
    defb 024h	    ;6de2   24	$
    defb 060h	    ;6de3   60	`
    defb 06eh	    ;6de4   6e	n
    defb 0aah	    ;6de5   aa	.
    defb 032h	    ;6de6   32	2
    defb 0bah	    ;6de7   ba	.
    defb 05eh	    ;6de8   5e	^
    defb 0b8h	    ;6de9   b8	.
    defb 0abh	    ;6dea   ab	.
    defb 0b3h	    ;6deb   b3	.
    defb 03ch	    ;6dec   3c	<
    defb 0f4h	    ;6ded   f4	.
    defb 00bh	    ;6dee   0b	.
    defb 04ah	    ;6def   4a	J
    defb 087h	    ;6df0   87	.
    defb 004h	    ;6df1   04	.
    defb 0cch	    ;6df2   cc	.
    defb 04dh	    ;6df3   4d	M
    defb 055h	    ;6df4   55	U
    defb 0feh	    ;6df5   fe	.
    defb 0f9h	    ;6df6   f9	.
    defb 043h	    ;6df7   43	C
    defb 0cah	    ;6df8   ca	.
    defb 087h	    ;6df9   87	.
    defb 02fh	    ;6dfa   2f	/
    defb 099h	    ;6dfb   99	.
    defb 044h	    ;6dfc   44	D
    defb 038h	    ;6dfd   38	8
    defb 0f9h	    ;6dfe   f9	.
    defb 02ch	    ;6dff   2c	,
    defb 017h	    ;6e00   17	.
    defb 0d7h	    ;6e01   d7	.
    defb 0c3h	    ;6e02   c3	.
    defb 061h	    ;6e03   61	a
    defb 028h	    ;6e04   28	(
    defb 032h	    ;6e05   32	2
    defb 02fh	    ;6e06   2f	/
    defb 0abh	    ;6e07   ab	.
    defb 063h	    ;6e08   63	c
    defb 07ch	    ;6e09   7c	|
    defb 0f0h	    ;6e0a   f0	.
    defb 08bh	    ;6e0b   8b	.
    defb 0d5h	    ;6e0c   d5	.
    defb 019h	    ;6e0d   19	.
    defb 027h	    ;6e0e   27	'
    defb 09fh	    ;6e0f   9f	.
    defb 025h	    ;6e10   25	%
    defb 0e9h	    ;6e11   e9	.
    defb 077h	    ;6e12   77	w
    defb 073h	    ;6e13   73	s
    defb 003h	    ;6e14   03	.
    defb 07fh	    ;6e15   7f	
    defb 0b9h	    ;6e16   b9	.
    defb 07eh	    ;6e17   7e	~
    defb 0b7h	    ;6e18   b7	.
    defb 06bh	    ;6e19   6b	k
    defb 038h	    ;6e1a   38	8
    defb 0e4h	    ;6e1b   e4	.
    defb 059h	    ;6e1c   59	Y
    defb 0f6h	    ;6e1d   f6	.
    defb 037h	    ;6e1e   37	7
    defb 0bfh	    ;6e1f   bf	.
    defb 07fh	    ;6e20   7f	
    defb 053h	    ;6e21   53	S
    defb 095h	    ;6e22   95	.
    defb 055h	    ;6e23   55	U
    defb 0a9h	    ;6e24   a9	.
    defb 077h	    ;6e25   77	w
    defb 0c2h	    ;6e26   c2	.
    defb 08bh	    ;6e27   8b	.
    defb 0deh	    ;6e28   de	.
    defb 031h	    ;6e29   31	1
    defb 03eh	    ;6e2a   3e	>
    defb 028h	    ;6e2b   28	(
    defb 06dh	    ;6e2c   6d	m
    defb 06bh	    ;6e2d   6b	k
    defb 060h	    ;6e2e   60	`
    defb 06eh	    ;6e2f   6e	n
    defb 010h	    ;6e30   10	.
    defb 0ech	    ;6e31   ec	.
    defb 072h	    ;6e32   72	r
    defb 0b5h	    ;6e33   b5	.
    defb 045h	    ;6e34   45	E
    defb 0edh	    ;6e35   ed	.
    defb 056h	    ;6e36   56	V
    defb 065h	    ;6e37   65	e
    defb 07dh	    ;6e38   7d	}
    defb 000h	    ;6e39   00	.
    defb 0e6h	    ;6e3a   e6	.
    defb 006h	    ;6e3b   06	.
    defb 0c1h	    ;6e3c   c1	.
    defb 02eh	    ;6e3d   2e	.
    defb 057h	    ;6e3e   57	W
    defb 05bh	    ;6e3f   5b	[
    defb 0d4h	    ;6e40   d4	.
    defb 06eh	    ;6e41   6e	n
    defb 055h	    ;6e42   55	U
    defb 0a9h	    ;6e43   a9	.
    defb 0d3h	    ;6e44   d3	.
    defb 0c0h	    ;6e45   c0	.
    defb 0dch	    ;6e46   dc	.
    defb 054h	    ;6e47   54	T
    defb 0a5h	    ;6e48   a5	.
    defb 0deh	    ;6e49   de	.
    defb 009h	    ;6e4a   09	.
    defb 076h	    ;6e4b   76	v
    defb 059h	    ;6e4c   59	Y
    defb 06ah	    ;6e4d   6a	j
    defb 06dh	    ;6e4e   6d	m
    defb 00bh	    ;6e4f   0b	.
    defb 054h	    ;6e50   54	T
    defb 06ch	    ;6e51   6c	l
    defb 03dh	    ;6e52   3d	=
    defb 0b0h	    ;6e53   b0	.
    defb 06dh	    ;6e54   6d	m
    defb 010h	    ;6e55   10	.
    defb 062h	    ;6e56   62	b
    defb 0d4h	    ;6e57   d4	.
    defb 0ddh	    ;6e58   dd	.
    defb 0f2h	    ;6e59   f2	.
    defb 009h	    ;6e5a   09	.
    defb 0cah	    ;6e5b   ca	.
    defb 0b6h	    ;6e5c   b6	.
    defb 001h	    ;6e5d   01	.
    defb 0d8h	    ;6e5e   d8	.
    defb 036h	    ;6e5f   36	6
    defb 008h	    ;6e60   08	.
    defb 031h	    ;6e61   31	1
    defb 0eah	    ;6e62   ea	.
    defb 06eh	    ;6e63   6e	n
    defb 0f9h	    ;6e64   f9	.
    defb 004h	    ;6e65   04	.
    defb 0d5h	    ;6e66   d5	.
    defb 0c5h	    ;6e67   c5	.
    defb 0afh	    ;6e68   af	.
    defb 0c0h	    ;6e69   c0	.
    defb 0dch	    ;6e6a   dc	.
    defb 054h	    ;6e6b   54	T
    defb 0a5h	    ;6e6c   a5	.
    defb 0deh	    ;6e6d   de	.
    defb 009h	    ;6e6e   09	.
    defb 071h	    ;6e6f   71	q
    defb 0e8h	    ;6e70   e8	.
    defb 0fch	    ;6e71   fc	.
    defb 00ah	    ;6e72   0a	.
    defb 028h	    ;6e73   28	(
    defb 0dbh	    ;6e74   db	.
    defb 006h	    ;6e75   06	.
    defb 0e8h	    ;6e76   e8	.
    defb 0e7h	    ;6e77   e7	.
    defb 006h	    ;6e78   06	.
    defb 021h	    ;6e79   21	!
    defb 0fah	    ;6e7a   fa	.
    defb 02eh	    ;6e7b   2e	.
    defb 0afh	    ;6e7c   af	.
    defb 001h	    ;6e7d   01	.
    defb 095h	    ;6e7e   95	.
    defb 05ah	    ;6e7f   5a	Z
    defb 00dh	    ;6e80   0d	.
    defb 0cch	    ;6e81   cc	.
    defb 00dh	    ;6e82   0d	.
    defb 042h	    ;6e83   42	B
    defb 0f4h	    ;6e84   f4	.
    defb 05dh	    ;6e85   5d	]
    defb 05eh	    ;6e86   5e	^
    defb 0f7h	    ;6e87   f7	.
    defb 0a0h	    ;6e88   a0	.
    defb 06ch	    ;6e89   6c	l
    defb 01bh	    ;6e8a   1b	.
    defb 0a0h	    ;6e8b   a0	.
    defb 0dfh	    ;6e8c   df	.
    defb 036h	    ;6e8d   36	6
    defb 055h	    ;6e8e   55	U
    defb 0a9h	    ;6e8f   a9	.
    defb 077h	    ;6e90   77	w
    defb 082h	    ;6e91   82	.
    defb 0eeh	    ;6e92   ee	.
    defb 0c2h	    ;6e93   c2	.
    defb 062h	    ;6e94   62	b
    defb 0f3h	    ;6e95   f3	.
    defb 00ch	    ;6e96   0c	.
    defb 055h	    ;6e97   55	U
    defb 0c4h	    ;6e98   c4	.
    defb 01ch	    ;6e99   1c	.
    defb 0fah	    ;6e9a   fa	.
    defb 05dh	    ;6e9b   5d	]
    defb 083h	    ;6e9c   83	.
    defb 0a0h	    ;6e9d   a0	.
    defb 097h	    ;6e9e   97	.
    defb 0b0h	    ;6e9f   b0	.
    defb 016h	    ;6ea0   16	.
    defb 043h	    ;6ea1   43	C
    defb 044h	    ;6ea2   44	D
    defb 015h	    ;6ea3   15	.
    defb 031h	    ;6ea4   31	1
    defb 007h	    ;6ea5   07	.
    defb 0b6h	    ;6ea6   b6	.
    defb 00dh	    ;6ea7   0d	.
    defb 042h	    ;6ea8   42	B
    defb 04ah	    ;6ea9   4a	J
    defb 08ch	    ;6eaa   8c	.
    defb 0bfh	    ;6eab   bf	.
    defb 054h	    ;6eac   54	T
    defb 0eah	    ;6ead   ea	.
    defb 034h	    ;6eae   34	4
    defb 030h	    ;6eaf   30	0
    defb 037h	    ;6eb0   37	7
    defb 055h	    ;6eb1   55	U
    defb 0a9h	    ;6eb2   a9	.
    defb 077h	    ;6eb3   77	w
    defb 042h	    ;6eb4   42	B
    defb 04ah	    ;6eb5   4a	J
    defb 08ch	    ;6eb6   8c	.
    defb 0bfh	    ;6eb7   bf	.
    defb 054h	    ;6eb8   54	T
    defb 017h	    ;6eb9   17	.
    defb 0bfh	    ;6eba   bf	.
    defb 002h	    ;6ebb   02	.
    defb 073h	    ;6ebc   73	s
    defb 083h	    ;6ebd   83	.
    defb 090h	    ;6ebe   90	.
    defb 04eh	    ;6ebf   4e	N
    defb 02fh	    ;6ec0   2f	/
    defb 05fh	    ;6ec1   5f	_
    defb 0b6h	    ;6ec2   b6	.
    defb 067h	    ;6ec3   67	g
    defb 050h	    ;6ec4   50	P
    defb 045h	    ;6ec5   45	E
    defb 0cch	    ;6ec6   cc	.
    defb 0e1h	    ;6ec7   e1	.
    defb 0b6h	    ;6ec8   b6	.
    defb 06fh	    ;6ec9   6f	o
    defb 010h	    ;6eca   10	.
    defb 0d2h	    ;6ecb   d2	.
    defb 069h	    ;6ecc   69	i
    defb 039h	    ;6ecd   39	9
    defb 0f9h	    ;6ece   f9	.
    defb 0bch	    ;6ecf   bc	.
    defb 047h	    ;6ed0   47	G
    defb 0d9h	    ;6ed1   d9	.
    defb 036h	    ;6ed2   36	6
    defb 000h	    ;6ed3   00	.
    defb 0dbh	    ;6ed4   db	.
    defb 0a6h	    ;6ed5   a6	.
    defb 02ah	    ;6ed6   2a	*
    defb 0f5h	    ;6ed7   f5	.
    defb 04eh	    ;6ed8   4e	N
    defb 048h	    ;6ed9   48	H
    defb 0a7h	    ;6eda   a7	.
    defb 07ah	    ;6edb   7a	z
    defb 028h	    ;6edc   28	(
    defb 000h	    ;6edd   00	.
    defb 065h	    ;6ede   65	e
    defb 0dbh	    ;6edf   db	.
    defb 000h	    ;6ee0   00	.
    defb 0f3h	    ;6ee1   f3	.
    defb 0dch	    ;6ee2   dc	.
    defb 020h	    ;6ee3   20
    defb 0a4h	    ;6ee4   a4	.
    defb 053h	    ;6ee5   53	S
    defb 03dh	    ;6ee6   3d	=
    defb 014h	    ;6ee7   14	.
    defb 080h	    ;6ee8   80	.
    defb 04ah	    ;6ee9   4a	J
    defb 09dh	    ;6eea   9d	.
    defb 006h	    ;6eeb   06	.
    defb 0e6h	    ;6eec   e6	.
    defb 006h	    ;6eed   06	.
    defb 021h	    ;6eee   21	!
    defb 09dh	    ;6eef   9d	.
    defb 0eah	    ;6ef0   ea	.
    defb 0a1h	    ;6ef1   a1	.
    defb 000h	    ;6ef2   00	.
    defb 054h	    ;6ef3   54	T
    defb 017h	    ;6ef4   17	.
    defb 0bfh	    ;6ef5   bf	.
    defb 082h	    ;6ef6   82	.
    defb 0ebh	    ;6ef7   eb	.
    defb 09bh	    ;6ef8   9b	.
    defb 0aah	    ;6ef9   aa	.
    defb 0d4h	    ;6efa   d4	.
    defb 03bh	    ;6efb   3b	;
    defb 021h	    ;6efc   21	!
    defb 09dh	    ;6efd   9d	.
    defb 04eh	    ;6efe   4e	N
    defb 08ch	    ;6eff   8c	.
    defb 00fh	    ;6f00   0f	.
    defb 02ah	    ;6f01   2a	*
    defb 0b5h	    ;6f02   b5	.
    defb 01ah	    ;6f03   1a	.
    defb 0d8h	    ;6f04   d8	.
    defb 036h	    ;6f05   36	6
    defb 008h	    ;6f06   08	.
    defb 087h	    ;6f07   87	.
    defb 0a1h	    ;6f08   a1	.
    defb 0a8h	    ;6f09   a8	.
    defb 0b3h	    ;6f0a   b3	.
    defb 03bh	    ;6f0b   3b	;
    defb 0e7h	    ;6f0c   e7	.
    defb 094h	    ;6f0d   94	.
    defb 06dh	    ;6f0e   6d	m
    defb 003h	    ;6f0f   03	.
    defb 0b0h	    ;6f10   b0	.
    defb 06dh	    ;6f11   6d	m
    defb 010h	    ;6f12   10	.
    defb 0aeh	    ;6f13   ae	.
    defb 08bh	    ;6f14   8b	.
    defb 0b6h	    ;6f15   b6	.
    defb 085h	    ;6f16   85	.
    defb 006h	    ;6f17   06	.
    defb 055h	    ;6f18   55	U
    defb 0c4h	    ;6f19   c4	.
    defb 01ch	    ;6f1a   1c	.
    defb 0d8h	    ;6f1b   d8	.
    defb 036h	    ;6f1c   36	6
    defb 055h	    ;6f1d   55	U
    defb 0a9h	    ;6f1e   a9	.
    defb 077h	    ;6f1f   77	w
    defb 0c2h	    ;6f20   c2	.
    defb 070h	    ;6f21   70	p
    defb 060h	    ;6f22   60	`
    defb 0fch	    ;6f23   fc	.
    defb 0a5h	    ;6f24   a5	.
    defb 08ah	    ;6f25   8a	.
    defb 098h	    ;6f26   98	.
    defb 043h	    ;6f27   43	C
    defb 0bfh	    ;6f28   bf	.
    defb 06dh	    ;6f29   6d	m
    defb 010h	    ;6f2a   10	.
    defb 08ah	    ;6f2b   8a	.
    defb 098h	    ;6f2c   98	.
    defb 027h	    ;6f2d   27	'
    defb 0dfh	    ;6f2e   df	.
    defb 0f4h	    ;6f2f   f4	.
    defb 0bdh	    ;6f30   bd	.
    defb 02ah	    ;6f31   2a	*
    defb 062h	    ;6f32   62	b
    defb 00eh	    ;6f33   0e	.
    defb 06eh	    ;6f34   6e	n
    defb 0dfh	    ;6f35   df	.
    defb 020h	    ;6f36   20
    defb 084h	    ;6f37   84	.
    defb 02ch	    ;6f38   2c	,
    defb 024h	    ;6f39   24	$
    defb 0dfh	    ;6f3a   df	.
    defb 0ach	    ;6f3b   ac	.
    defb 0bdh	    ;6f3c   bd	.
    defb 02ah	    ;6f3d   2a	*
    defb 062h	    ;6f3e   62	b
    defb 00eh	    ;6f3f   0e	.
    defb 0fdh	    ;6f40   fd	.
    defb 0dch	    ;6f41   dc	.
    defb 054h	    ;6f42   54	T
    defb 0a5h	    ;6f43   a5	.
    defb 0deh	    ;6f44   de	.
    defb 009h	    ;6f45   09	.
    defb 05dh	    ;6f46   5d	]
    defb 0c3h	    ;6f47   c3	.
    defb 0f8h	    ;6f48   f8	.
    defb 04bh	    ;6f49   4b	K
    defb 005h	    ;6f4a   05	.
    defb 0abh	    ;6f4b   ab	.
    defb 0a1h	    ;6f4c   a1	.
    defb 0dfh	    ;6f4d   df	.
    defb 035h	    ;6f4e   35	5
    defb 008h	    ;6f4f   08	.
    defb 05dh	    ;6f50   5d	]
    defb 033h	    ;6f51   33	3
    defb 0bch	    ;6f52   bc	.
    defb 0bch	    ;6f53   bc	.
    defb 0f5h	    ;6f54   f5	.
    defb 02fh	    ;6f55   2f	/
    defb 04eh	    ;6f56   4e	N
    defb 0a5h	    ;6f57   a5	.
    defb 04eh	    ;6f58   4e	N
    defb 003h	    ;6f59   03	.
    defb 073h	    ;6f5a   73	s
    defb 083h	    ;6f5b   83	.
    defb 0d0h	    ;6f5c   d0	.
    defb 035h	    ;6f5d   35	5
    defb 0c3h	    ;6f5e   c3	.
    defb 0cbh	    ;6f5f   cb	.
    defb 05bh	    ;6f60   5b	[
    defb 0ffh	    ;6f61   ff	.
    defb 0d2h	    ;6f62   d2	.
    defb 0abh	    ;6f63   ab	.
    defb 022h	    ;6f64   22	"
    defb 0e6h	    ;6f65   e6	.
    defb 0c0h	    ;6f66   c0	.
    defb 0b6h	    ;6f67   b6	.
    defb 0a9h	    ;6f68   a9	.
    defb 04ah	    ;6f69   4a	J
    defb 0bdh	    ;6f6a   bd	.
    defb 013h	    ;6f6b   13	.
    defb 0bah	    ;6f6c   ba	.
    defb 066h	    ;6f6d   66	f
    defb 0f0h	    ;6f6e   f0	.
    defb 059h	    ;6f6f   59	Y
    defb 00dh	    ;6f70   0d	.
    defb 0cah	    ;6f71   ca	.
    defb 0b6h	    ;6f72   b6	.
    defb 001h	    ;6f73   01	.
    defb 0d8h	    ;6f74   d8	.
    defb 036h	    ;6f75   36	6
    defb 008h	    ;6f76   08	.
    defb 05dh	    ;6f77   5d	]
    defb 033h	    ;6f78   33	3
    defb 0f8h	    ;6f79   f8	.
    defb 0ach	    ;6f7a   ac	.
    defb 006h	    ;6f7b   06	.
    defb 0d5h	    ;6f7c   d5	.
    defb 0c5h	    ;6f7d   c5	.
    defb 0afh	    ;6f7e   af	.
    defb 0c0h	    ;6f7f   c0	.
    defb 0dch	    ;6f80   dc	.
    defb 020h	    ;6f81   20
    defb 0b4h	    ;6f82   b4	.
    defb 04dh	    ;6f83   4d	M
    defb 0bfh	    ;6f84   bf	.
    defb 063h	    ;6f85   63	c
    defb 03ch	    ;6f86   3c	<
    defb 0aah	    ;6f87   aa	.
    defb 022h	    ;6f88   22	"
    defb 0e6h	    ;6f89   e6	.
    defb 0e0h	    ;6f8a   e0	.
    defb 0fah	    ;6f8b   fa	.
    defb 0a6h	    ;6f8c   a6	.
    defb 02ah	    ;6f8d   2a	*
    defb 0f5h	    ;6f8e   f5	.
    defb 04eh	    ;6f8f   4e	N
    defb 0c8h	    ;6f90   c8	.
    defb 06dh	    ;6f91   6d	m
    defb 048h	    ;6f92   48	H
    defb 0f9h	    ;6f93   f9	.
    defb 0f0h	    ;6f94   f0	.
    defb 0e5h	    ;6f95   e5	.
    defb 0a6h	    ;6f96   a6	.
    defb 042h	    ;6f97   42	B
    defb 0abh	    ;6f98   ab	.
    defb 0c1h	    ;6f99   c1	.
    defb 0f5h	    ;6f9a   f5	.
    defb 00dh	    ;6f9b   0d	.
    defb 082h	    ;6f9c   82	.
    defb 04fh	    ;6f9d   4f	O
    defb 02fh	    ;6f9e   2f	/
    defb 0e9h	    ;6f9f   e9	.
    defb 004h	    ;6fa0   04	.
    defb 0a8h	    ;6fa1   a8	.
    defb 0c5h	    ;6fa2   c5	.
    defb 0d6h	    ;6fa3   d6	.
    defb 0c0h	    ;6fa4   c0	.
    defb 0dch	    ;6fa5   dc	.
    defb 020h	    ;6fa6   20
    defb 0f8h	    ;6fa7   f8	.
    defb 0f4h	    ;6fa8   f4	.
    defb 076h	    ;6fa9   76	v
    defb 063h	    ;6faa   63	c
    defb 03ch	    ;6fab   3c	<
    defb 0aah	    ;6fac   aa	.
    defb 022h	    ;6fad   22	"
    defb 0e6h	    ;6fae   e6	.
    defb 070h	    ;6faf   70	p
    defb 0deh	    ;6fb0   de	.
    defb 037h	    ;6fb1   37	7
    defb 055h	    ;6fb2   55	U
    defb 0a9h	    ;6fb3   a9	.
    defb 077h	    ;6fb4   77	w
    defb 082h	    ;6fb5   82	.
    defb 0cfh	    ;6fb6   cf	.
    defb 0eah	    ;6fb7   ea	.
    defb 0e5h	    ;6fb8   e5	.
    defb 01bh	    ;6fb9   1b	.
    defb 0a0h	    ;6fba   a0	.
    defb 08ah	    ;6fbb   8a	.
    defb 098h	    ;6fbc   98	.
    defb 003h	    ;6fbd   03	.
    defb 0dbh	    ;6fbe   db	.
    defb 006h	    ;6fbf   06	.
    defb 0c1h	    ;6fc0   c1	.
    defb 00fh	    ;6fc1   0f	.
    defb 059h	    ;6fc2   59	Y
    defb 0c8h	    ;6fc3   c8	.
    defb 036h	    ;6fc4   36	6
    defb 07eh	    ;6fc5   7e	~
    defb 0abh	    ;6fc6   ab	.
    defb 086h	    ;6fc7   86	.
    defb 0cdh	    ;6fc8   cd	.
    defb 001h	    ;6fc9   01	.
    defb 098h	    ;6fca   98	.
    defb 01bh	    ;6fcb   1b	.
    defb 004h	    ;6fcc   04	.
    defb 03fh	    ;6fcd   3f	?
    defb 03ch	    ;6fce   3c	<
    defb 0b9h	    ;6fcf   b9	.
    defb 073h	    ;6fd0   73	s
    defb 0ffh	    ;6fd1   ff	.
    defb 082h	    ;6fd2   82	.
    defb 02ah	    ;6fd3   2a	*
    defb 062h	    ;6fd4   62	b
    defb 00eh	    ;6fd5   0e	.
    defb 0fdh	    ;6fd6   fd	.
    defb 0b6h	    ;6fd7   b6	.
    defb 0a9h	    ;6fd8   a9	.
    defb 04ah	    ;6fd9   4a	J
    defb 0bdh	    ;6fda   bd	.
    defb 013h	    ;6fdb   13	.
    defb 0fch	    ;6fdc   fc	.
    defb 092h	    ;6fdd   92	.
    defb 015h	    ;6fde   15	.
    defb 0c5h	    ;6fdf   c5	.
    defb 08bh	    ;6fe0   8b	.
    defb 073h	    ;6fe1   73	s
    defb 0aah	    ;6fe2   aa	.
    defb 088h	    ;6fe3   88	.
    defb 039h	    ;6fe4   39	9
    defb 0b0h	    ;6fe5   b0	.
    defb 06dh	    ;6fe6   6d	m
    defb 010h	    ;6fe7   10	.
    defb 0fch	    ;6fe8   fc	.
    defb 029h	    ;6fe9   29	)
    defb 0beh	    ;6fea   be	.
    defb 01ch	    ;6feb   1c	.
    defb 086h	    ;6fec   86	.
    defb 03bh	    ;6fed   3b	;
    defb 054h	    ;6fee   54	T
    defb 0eah	    ;6fef   ea	.
    defb 034h	    ;6ff0   34	4
    defb 030h	    ;6ff1   30	0
    defb 037h	    ;6ff2   37	7
    defb 008h	    ;6ff3   08	.
    defb 0feh	    ;6ff4   fe	.
    defb 0b4h	    ;6ff5   b4	.
    defb 0e4h	    ;6ff6   e4	.
    defb 05eh	    ;6ff7   5e	^
    defb 0dbh	    ;6ff8   db	.
    defb 08dh	    ;6ff9   8d	.
    defb 02ah	    ;6ffa   2a	*
    defb 062h	    ;6ffb   62	b
    defb 00eh	    ;6ffc   0e	.
    defb 0fdh	    ;6ffd   fd	.
    defb 0b6h	    ;6ffe   b6	.
    defb 0a9h	    ;6fff   a9	.
    defb 04ah	    ;7000   4a	J
    defb 0bdh	    ;7001   bd	.
    defb 013h	    ;7002   13	.
    defb 0eah	    ;7003   ea	.
    defb 0ach	    ;7004   ac	.
    defb 0c8h	    ;7005   c8	.
    defb 0deh	    ;7006   de	.
    defb 06eh	    ;7007   6e	n
    defb 03bh	    ;7008   3b	;
    defb 094h	    ;7009   94	.
    defb 06dh	    ;700a   6d	m
    defb 003h	    ;700b   03	.
    defb 0b0h	    ;700c   b0	.
    defb 06dh	    ;700d   6d	m
    defb 010h	    ;700e   10	.
    defb 0eah	    ;700f   ea	.
    defb 0ach	    ;7010   ac	.
    defb 0c8h	    ;7011   c8	.
    defb 0deh	    ;7012   de	.
    defb 06eh	    ;7013   6e	n
    defb 03bh	    ;7014   3b	;
    defb 054h	    ;7015   54	T
    defb 017h	    ;7016   17	.
    defb 0bfh	    ;7017   bf	.
    defb 002h	    ;7018   02	.
    defb 073h	    ;7019   73	s
    defb 083h	    ;701a   83	.
    defb 070h	    ;701b   70	p
    defb 062h	    ;701c   62	b
    defb 0fch	    ;701d   fc	.
    defb 00fh	    ;701e   0f	.
    defb 065h	    ;701f   65	e
    defb 0dbh	    ;7020   db	.
    defb 000h	    ;7021   00	.
    defb 0cch	    ;7022   cc	.
    defb 04dh	    ;7023   4d	M
    defb 055h	    ;7024   55	U
    defb 0eah	    ;7025   ea	.
    defb 09dh	    ;7026   9d	.
    defb 0f0h	    ;7027   f0	.
    defb 0edh	    ;7028   ed	.
    defb 06ah	    ;7029   6a	j
    defb 06bh	    ;702a   6b	k
    defb 0bfh	    ;702b   bf	.
    defb 0c9h	    ;702c   c9	.
    defb 0beh	    ;702d   be	.
    defb 029h	    ;702e   29	)
    defb 0ddh	    ;702f   dd	.
    defb 005h	    ;7030   05	.
    defb 060h	    ;7031   60	`
    defb 06eh	    ;7032   6e	n
    defb 010h	    ;7033   10	.
    defb 0eeh	    ;7034   ee	.
    defb 0d2h	    ;7035   d2	.
    defb 0cbh	    ;7036   cb	.
    defb 0edh	    ;7037   ed	.
    defb 03fh	    ;7038   3f	?
    defb 0b7h	    ;7039   b7	.
    defb 00eh	    ;703a   0e	.
    defb 065h	    ;703b   65	e
    defb 0dbh	    ;703c   db	.
    defb 000h	    ;703d   00	.
    defb 0fdh	    ;703e   fd	.
    defb 0aeh	    ;703f   ae	.
    defb 041h	    ;7040   41	A
    defb 078h	    ;7041   78	x
    defb 0f5h	    ;7042   f5	.
    defb 043h	    ;7043   43	C
    defb 03ah	    ;7044   3a	:
    defb 00ch	    ;7045   0c	.
    defb 077h	    ;7046   77	w
    defb 0a8h	    ;7047   a8	.
    defb 0c3h	    ;7048   c3	.
    defb 070h	    ;7049   70	p
    defb 007h	    ;704a   07	.
    defb 0cch	    ;704b   cc	.
    defb 04dh	    ;704c   4d	M
    defb 055h	    ;704d   55	U
    defb 056h	    ;704e   56	V
    defb 065h	    ;704f   65	e
    defb 071h	    ;7050   71	q
    defb 0f9h	    ;7051   f9	.
    defb 098h	    ;7052   98	.
    defb 0deh	    ;7053   de	.
    defb 0a7h	    ;7054   a7	.
    defb 07bh	    ;7055   7b	{
    defb 0d2h	    ;7056   d2	.
    defb 065h	    ;7057   65	e
    defb 07ah	    ;7058   7a	z
    defb 0fch	    ;7059   fc	.
    defb 0feh	    ;705a   fe	.
    defb 0f3h	    ;705b   f3	.
    defb 079h	    ;705c   79	y
    defb 0bah	    ;705d   ba	.
    defb 0e7h	    ;705e   e7	.
    defb 0c7h	    ;705f   c7	.
    defb 0f3h	    ;7060   f3	.
    defb 084h	    ;7061   84	.
    defb 0deh	    ;7062   de	.
    defb 089h	    ;7063   89	.
    defb 0eeh	    ;7064   ee	.
    defb 0c2h	    ;7065   c2	.
    defb 062h	    ;7066   62	b
    defb 0f3h	    ;7067   f3	.
    defb 00ch	    ;7068   0c	.
    defb 055h	    ;7069   55	U
    defb 0c4h	    ;706a   c4	.
    defb 01ch	    ;706b   1c	.
    defb 0fah	    ;706c   fa	.
    defb 09dh	    ;706d   9d	.
    defb 0a9h	    ;706e   a9	.
    defb 04ah	    ;706f   4a	J
    defb 0bdh	    ;7070   bd	.
    defb 013h	    ;7071   13	.
    defb 076h	    ;7072   76	v
    defb 0fdh	    ;7073   fd	.
    defb 0a6h	    ;7074   a6	.
    defb 0fbh	    ;7075   fb	.
    defb 0b2h	    ;7076   b2	.
    defb 09dh	    ;7077   9d	.
    defb 051h	    ;7078   51	Q
    defb 08ch	    ;7079   8c	.
    defb 0bfh	    ;707a   bf	.
    defb 076h	    ;707b   76	v
    defb 006h	    ;707c   06	.
    defb 041h	    ;707d   41	A
    defb 077h	    ;707e   77	w
    defb 061h	    ;707f   61	a
    defb 0b1h	    ;7080   b1	.
    defb 079h	    ;7081   79	y
    defb 086h	    ;7082   86	.
    defb 04ah	    ;7083   4a	J
    defb 09dh	    ;7084   9d	.
    defb 006h	    ;7085   06	.
    defb 09ch	    ;7086   9c	.
    defb 041h	    ;7087   41	A
    defb 0d0h	    ;7088   d0	.
    defb 05dh	    ;7089   5d	]
    defb 058h	    ;708a   58	X
    defb 06ch	    ;708b   6c	l
    defb 09eh	    ;708c   9e	.
    defb 0a1h	    ;708d   a1	.
    defb 074h	    ;708e   74	t
    defb 017h	    ;708f   17	.
    defb 0c0h	    ;7090   c0	.
    defb 09dh	    ;7091   9d	.
    defb 04dh	    ;7092   4d	M
    defb 055h	    ;7093   55	U
    defb 056h	    ;7094   56	V
    defb 065h	    ;7095   65	e
    defb 071h	    ;7096   71	q
    defb 0f9h	    ;7097   f9	.
    defb 098h	    ;7098   98	.
    defb 0deh	    ;7099   de	.
    defb 0a7h	    ;709a   a7	.
    defb 07bh	    ;709b   7b	{
    defb 0d2h	    ;709c   d2	.
    defb 065h	    ;709d   65	e
    defb 07ah	    ;709e   7a	z
    defb 0fch	    ;709f   fc	.
    defb 0feh	    ;70a0   fe	.
    defb 0f3h	    ;70a1   f3	.
    defb 079h	    ;70a2   79	y
    defb 0bah	    ;70a3   ba	.
    defb 0e7h	    ;70a4   e7	.
    defb 0c7h	    ;70a5   c7	.
    defb 0f3h	    ;70a6   f3	.
    defb 084h	    ;70a7   84	.
    defb 0deh	    ;70a8   de	.
    defb 089h	    ;70a9   89	.
    defb 05eh	    ;70aa   5e	^
    defb 0c2h	    ;70ab   c2	.
    defb 05ah	    ;70ac   5a	Z
    defb 00ch	    ;70ad   0c	.
    defb 011h	    ;70ae   11	.
    defb 055h	    ;70af   55	U
    defb 0c4h	    ;70b0   c4	.
    defb 01ch	    ;70b1   1c	.
    defb 0d8h	    ;70b2   d8	.
    defb 09ah	    ;70b3   9a	.
    defb 0aah	    ;70b4   aa	.
    defb 0d4h	    ;70b5   d4	.
    defb 03bh	    ;70b6   3b	;
    defb 041h	    ;70b7   41	A
    defb 02fh	    ;70b8   2f	/
    defb 061h	    ;70b9   61	a
    defb 02dh	    ;70ba   2d	-
    defb 086h	    ;70bb   86	.
    defb 088h	    ;70bc   88	.
    defb 04ah	    ;70bd   4a	J
    defb 0adh	    ;70be   ad	.
    defb 006h	    ;70bf   06	.
    defb 0f6h	    ;70c0   f6	.
    defb 006h	    ;70c1   06	.
    defb 041h	    ;70c2   41	A
    defb 02fh	    ;70c3   2f	/
    defb 061h	    ;70c4   61	a
    defb 02dh	    ;70c5   2d	-
    defb 086h	    ;70c6   86	.
    defb 088h	    ;70c7   88	.
    defb 0cah	    ;70c8   ca	.
    defb 0b3h	    ;70c9   b3	.
    defb 002h	    ;70ca   02	.
    defb 0e8h	    ;70cb   e8	.
    defb 00dh	    ;70cc   0d	.
    defb 042h	    ;70cd   42	B
    defb 055h	    ;70ce   55	U
    defb 056h	    ;70cf   56	V
    defb 065h	    ;70d0   65	e
    defb 071h	    ;70d1   71	q
    defb 0f9h	    ;70d2   f9	.
    defb 098h	    ;70d3   98	.
    defb 0deh	    ;70d4   de	.
    defb 0a7h	    ;70d5   a7	.
    defb 07bh	    ;70d6   7b	{
    defb 0d2h	    ;70d7   d2	.
    defb 065h	    ;70d8   65	e
    defb 07ah	    ;70d9   7a	z
    defb 0fch	    ;70da   fc	.
    defb 0feh	    ;70db   fe	.
    defb 0f3h	    ;70dc   f3	.
    defb 079h	    ;70dd   79	y
    defb 0bah	    ;70de   ba	.
    defb 0e7h	    ;70df   e7	.
    defb 0c7h	    ;70e0   c7	.
    defb 0f3h	    ;70e1   f3	.
    defb 084h	    ;70e2   84	.
    defb 0deh	    ;70e3   de	.
    defb 049h	    ;70e4   49	I
    defb 03ah	    ;70e5   3a	:
    defb 0bdh	    ;70e6   bd	.
    defb 07ch	    ;70e7   7c	|
    defb 0d9h	    ;70e8   d9	.
    defb 09eh	    ;70e9   9e	.
    defb 041h	    ;70ea   41	A
    defb 015h	    ;70eb   15	.
    defb 031h	    ;70ec   31	1
    defb 087h	    ;70ed   87	.
    defb 0dbh	    ;70ee   db	.
    defb 0deh	    ;70ef   de	.
    defb 054h	    ;70f0   54	T
    defb 0a5h	    ;70f1   a5	.
    defb 0deh	    ;70f2   de	.
    defb 009h	    ;70f3   09	.
    defb 0e9h	    ;70f4   e9	.
    defb 0f4h	    ;70f5   f4	.
    defb 0f2h	    ;70f6   f2	.
    defb 065h	    ;70f7   65	e
    defb 07bh	    ;70f8   7b	{
    defb 006h	    ;70f9   06	.
    defb 095h	    ;70fa   95	.
    defb 05ah	    ;70fb   5a	Z
    defb 00dh	    ;70fc   0d	.
    defb 06ch	    ;70fd   6c	l
    defb 00dh	    ;70fe   0d	.

    ld b,d	    ;70ff   42	B
*

;end file f80.com

.COMMENT *
    org 0fa05h
;-------------------------------------
    defb 000h	    ;fa05 66c6	00  . 1
    defb 000h	    ;fa06 66c7	00  . 2
    defb 000h	    ;fa07 66c8	00  . 3
    defb 000h	    ;fa08 66c9	00  . 4
    defb 000h	    ;fa09 66ca	00  . 5
    defb 000h	    ;fa0a 66cb	00  . 6
    defb 000h	    ;fa0b 66cc	00  . 7
    defb 000h	    ;fa0c 66cd	00  . 8
    defb 011h	    ;fa0d 66ce	11  . 9
    defb 004h	    ;fa0e 66cf	04  . 10
    defb 0ffh	    ;fa0f 66d0	ff  . 11
    defb 0ffh	    ;fa10 66d1	ff  . 12
    defb 0ffh	    ;fa11 66d2	ff  . 13
    defb 0ffh	    ;fa12 66d3	ff  . 14
    defb 000h	    ;fa13 66d4	00  . 15
    defb 000h	    ;fa14 66d5	00  . 16
    defb 000h	    ;fa15 66d6	00  . 17
    defb 000h	    ;fa16 66d7	00  . 18
    defb 011h	    ;fa17 66d8	11  . 19
    defb 004h	    ;fa18 66d9	04  . 20
    defb 000h	    ;fa19 66da	00  . 21
    defb 000h	    ;fa1a 66db	00  . 22
    defb 000h	    ;fa1b 66dc	00  . 23
    defb 000h	    ;fa1c 66dd	00  . 24
    defb 000h	    ;fa1d 66de	00  . 25
    defb 000h	    ;fa1e 66df	00  . 26
    defb 000h	    ;fa1f 66e0	00  . 27
    defb 000h	    ;fa20 66e1	00  . 28
    defb 001h	    ;fa21 66e2	01  . 29
    defb 004h	    ;fa22 66e3	04  . 30 (l02b0h)
    defb 001h	    ;fa23 66e4	01  . 31
    defb 000h	    ;fa24 66e5	00  . 32
    defb 000h	    ;fa25 66e6	00  . 33
    defb 000h	    ;fa26 66e7	00  . 34
    defb 000h	    ;fa27 66e8	00  . 35
    defb 000h	    ;fa28 66e9	00  . 36
    defb 000h	    ;fa29 66ea	00  . 37
    defb 000h	    ;fa2a 66eb	00  . 38
    defb 001h	    ;fa2b 66ec	01  . 39
    defb 004h	    ;fa2c 66ed	04  . 40 (l023eh)
    defb 002h	    ;fa2d 66ee	02  . 41
    defb 000h	    ;fa2e 66ef	00  . 42
    defb 000h	    ;fa2f 66f0	00  . 43
    defb 000h	    ;fa30 66f1	00  . 44
    defb 000h	    ;fa31 66f2	00  . 45
    defb 000h	    ;fa32 66f3	00  . 46
    defb 000h	    ;fa33 66f4	00  . 47
    defb 000h	    ;fa34 66f5	00  . 48
    defb 001h	    ;fa35 66f6	01  . 49
    defb 004h	    ;fa36 66f7	04  . 50 (l02a0h)
    defb 000h	    ;fa37 66f8	00  . 51
    defb 000h	    ;fa38 66f9	00  . 52
    defb 000h	    ;fa39 66fa	00  . 53
    defb 000h	    ;fa3a 66fb	00  . 54
    defb 000h	    ;fa3b 66fc	00  . 55
    defb 000h	    ;fa3c 66fd	00  . 56
    defb 000h	    ;fa3d 66fe	00  . 57
    defb 000h	    ;fa3e 66ff	00  . 58
    defb 009h	    ;fa3f 6700	09  . 59
    defb 004h	    ;fa40 6701	04  . 60 (l02b2h)
    defb 000h	    ;fa41 6702	00  . 61
    defb 000h	    ;fa42 6703	00  . 62
    defb 000h	    ;fa43 6704	00  . 63
    defb 000h	    ;fa44 6705	00  . 64
    defb 000h	    ;fa45 6706	00  . 65
    defb 000h	    ;fa46 6707	00  . 66
    defb 000h	    ;fa47 6708	00  . 67
    defb 000h	    ;fa48 6709	00  . 68
    defb 000h	    ;fa49 670a	00  . 69
    defb 000h	    ;fa4a 670b	00  . 70
    defb 000h	    ;fa4b 670c	00  . 71
    defb 000h	    ;fa4c 670d	00  . 72
    defb 019h	    ;fa4d 670e	19  . 73
    defb 008h	    ;fa4e 670f	08  . 74 (l02aeh)
    defb 000h	    ;fa4f 6710	00  . 75
    defb 000h	    ;fa50 6711	00  . 76
    defb 000h	    ;fa51 6712	00  . 77
    defb 081h	    ;fa52 6713	81  . 78
    defb 000h	    ;fa53 6714	00  . 79
    defb 000h	    ;fa54 6715	00  . 80
    defb 000h	    ;fa55 6716	00  . 81
    defb 000h	    ;fa56 6717	00  . 82
    defb 009h	    ;fa57 6718	09  . 83
    defb 004h	    ;fa58 6719	04  . 84 (l0240h)
    defb 000h	    ;fa59 671a	00  . 85
    defb 000h	    ;fa5a 671b	00  . 86
    defb 000h	    ;fa5b 671c	00  . 87
    defb 000h	    ;fa5c 671d	00  . 88
    defb 000h	    ;fa5d 671e	00  . 89
    defb 000h	    ;fa5e 671f	00  . 90
    defb 000h	    ;fa5f 6720	00  . 91
    defb 081h	    ;fa60 6721	81  . 92
    defb 000h	    ;fa61 6722	00  . 93
    defb 000h	    ;fa62 6723	00  . 94
    defb 000h	    ;fa63 6724	00  . 95
    defb 000h	    ;fa64 6725	00  . 96
    defb 019h	    ;fa65 6726	19  . 97
    defb 008h	    ;fa66 6727	08  . 98 (l023ch)(l031ch)
;-------------------------------------
    defb 053h	    ;fa67 6728	53  S	1
    defb 042h	    ;fa68 6729	42  B	2
    defb 041h	    ;fa69 672a	41  A	3
    defb 000h	    ;fa6a 672b	00  .	4
    defb 000h	    ;fa6b 672c	00  .	5
    defb 000h	    ;fa6c 672d	00  .	6
    defb 000h	    ;fa6d 672e	00  .	7
    defb 00dh	    ;fa6e 672f	0d  .	8
    defb 003h	    ;fa6f 6730	03  .	9
    defb 053h	    ;fa70 6731	53  S  10
    defb 042h	    ;fa71 6732	42  B  11
    defb 041h	    ;fa72 6733	41  A  12
    defb 049h	    ;fa73 6734	49  I  13
    defb 000h	    ;fa74 6735	00  .  14
    defb 000h	    ;fa75 6736	00  .  15
    defb 000h	    ;fa76 6737	00  .  16
    defb 000h	    ;fa77 6738	00  .  17
    defb 005h	    ;fa78 6739	05  .  18
    defb 004h	    ;fa79 673a	04  .  19
    defb 054h	    ;fa7a 673b	54  T  20
    defb 04eh	    ;fa7b 673c	4e  N  21
    defb 049h	    ;fa7c 673d	49  I  22
    defb 041h	    ;fa7d 673e	41  A  23
    defb 000h	    ;fa7e 673f	00  .  24
    defb 000h	    ;fa7f 6740	00  .  25
    defb 000h	    ;fa80 6741	00  .  26
    defb 000h	    ;fa81 6742	00  .  27
    defb 00dh	    ;fa82 6743	0d  .  28
    defb 004h	    ;fa83 6744	04  .  29
    defb 054h	    ;fa84 6745	54  T  30
    defb 04eh	    ;fa85 6746	4e  N  31
    defb 049h	    ;fa86 6747	49  I  32
    defb 000h	    ;fa87 6748	00  .  33
    defb 000h	    ;fa88 6749	00  .  34
    defb 000h	    ;fa89 674a	00  .  35
    defb 000h	    ;fa8a 674b	00  .  36
    defb 005h	    ;fa8b 674c	05  .  37
    defb 003h	    ;fa8c 674d	03  .  38
    defb 054h	    ;fa8d 674e	54  T  39
    defb 04eh	    ;fa8e 674f	4e  N  40
    defb 049h	    ;fa8f 6750	49  I  41
    defb 044h	    ;fa90 6751	44  D  42
    defb 049h	    ;fa91 6752	49  I  43
    defb 000h	    ;fa92 6753	00  .  44
    defb 000h	    ;fa93 6754	00  .  45
    defb 000h	    ;fa94 6755	00  .  46
    defb 000h	    ;fa95 6756	00  .  47
    defb 005h	    ;fa96 6757	05  .  48
    defb 005h	    ;fa97 6758	05  .  49
    defb 044h	    ;fa98 6759	44  D  50
    defb 04fh	    ;fa99 675a	4f  O  51
    defb 04dh	    ;fa9a 675b	4d  M  52
    defb 041h	    ;fa9b 675c	41  A  53
    defb 000h	    ;fa9c 675d	00  .  54
    defb 000h	    ;fa9d 675e	00  .  55
    defb 000h	    ;fa9e 675f	00  .  56
    defb 000h	    ;fa9f 6760	00  .  57
    defb 00dh	    ;faa0 6761	0d  .  58
    defb 004h	    ;faa1 6762	04  .  59
    defb 044h	    ;faa2 6763	44  D  60
    defb 04fh	    ;faa3 6764	4f  O  61
    defb 04dh	    ;faa4 6765	4d  M  62
    defb 000h	    ;faa5 6766	00  .  63
    defb 000h	    ;faa6 6767	00  .  64
    defb 000h	    ;faa7 6768	00  .  65
    defb 000h	    ;faa8 6769	00  .  66
    defb 005h	    ;faa9 676a	05  .  67
    defb 003h	    ;faaa 676b	03  .  68
    defb 054h	    ;faab 676c	54  T  69
    defb 041h	    ;faac 676d	41  A  70
    defb 04fh	    ;faad 676e	4f  O  71
    defb 04ch	    ;faae 676f	4c  L  72
    defb 046h	    ;faaf 6770	46  F  73
    defb 000h	    ;fab0 6771	00  .  74
    defb 000h	    ;fab1 6772	00  .  75
    defb 000h	    ;fab2 6773	00  .  76
    defb 000h	    ;fab3 6774	00  .  77
    defb 00dh	    ;fab4 6775	0d  .  78
    defb 005h	    ;fab5 6776	05  .  79
    defb 058h	    ;fab6 6777	58  X  80
    defb 049h	    ;fab7 6778	49  I  81
    defb 046h	    ;fab8 6779	46  F  82
    defb 049h	    ;fab9 677a	49  I  83
    defb 000h	    ;faba 677b	00  .  84
    defb 000h	    ;fabb 677c	00  .  85
    defb 000h	    ;fabc 677d	00  .  86
    defb 000h	    ;fabd 677e	00  .  87
    defb 005h	    ;fabe 677f	05  .  88
    defb 004h	    ;fabf 6780	04  .  89
    defb 04eh	    ;fac0 6781	4e  N  90
    defb 047h	    ;fac1 6782	47  G  91
    defb 049h	    ;fac2 6783	49  I  92
    defb 053h	    ;fac3 6784	53  S  93
    defb 000h	    ;fac4 6785	00  .  94
    defb 000h	    ;fac5 6786	00  .  95
    defb 000h	    ;fac6 6787	00  .  96
    defb 000h	    ;fac7 6788	00  .  97
    defb 00dh	    ;fac8 6789	0d  .  98
    defb 004h	    ;fac9 678a	04  .  99
    defb 04eh	    ;faca 678b	4e  N 100
    defb 047h	    ;facb 678c	47  G 101
    defb 049h	    ;facc 678d	49  I 102
    defb 053h	    ;facd 678e	53  S 103
    defb 049h	    ;face 678f	49  I 104
    defb 000h	    ;facf 6790	00  . 105
    defb 000h	    ;fad0 6791	00  . 106
    defb 000h	    ;fad1 6792	00  . 107
    defb 000h	    ;fad2 6793	00  . 108
    defb 005h	    ;fad3 6794	05  . 109
    defb 005h	    ;fad4 6795	05  . 110
    defb 04dh	    ;fad5 6796	4d  M 111
    defb 049h	    ;fad6 6797	49  I 112
    defb 044h	    ;fad7 6798	44  D 113
    defb 000h	    ;fad8 6799	00  . 114
    defb 000h	    ;fad9 679a	00  . 115
    defb 000h	    ;fada 679b	00  . 116
    defb 000h	    ;fadb 679c	00  . 117
    defb 00dh	    ;fadc 679d	0d  . 118
    defb 003h	    ;fadd 679e	03  . 119
    defb 04dh	    ;fade 679f	4d  M 120
    defb 049h	    ;fadf 67a0	49  I 121
    defb 044h	    ;fae0 67a1	44  D 122
    defb 049h	    ;fae1 67a2	49  I
    defb 000h	    ;fae2 67a3	00  .
    defb 000h	    ;fae3 67a4	00  .
    defb 000h	    ;fae4 67a5	00  .
    defb 000h	    ;fae5 67a6	00  .
    defb 005h	    ;fae6 67a7	05  .
    defb 004h	    ;fae7 67a8	04  .
    defb 045h	    ;fae8 67a9	45  E
    defb 04ch	    ;fae9 67aa	4c  L
    defb 047h	    ;faea 67ab	47  G
    defb 04eh	    ;faeb 67ac	4e  N
    defb 053h	    ;faec 67ad	53  S
    defb 000h	    ;faed 67ae	00  .
    defb 000h	    ;faee 67af	00  .
    defb 000h	    ;faef 67b0	00  .
    defb 000h	    ;faf0 67b1	00  .
    defb 00dh	    ;faf1 67b2	0d  .
    defb 005h	    ;faf2 67b3	05  .
    defb 050h	    ;faf3 67b4	50  P
    defb 058h	    ;faf4 67b5	58  X
    defb 045h	    ;faf5 67b6	45  E
    defb 000h	    ;faf6 67b7	00  .
    defb 000h	    ;faf7 67b8	00  .
    defb 000h	    ;faf8 67b9	00  .
    defb 000h	    ;faf9 67ba	00  .
    defb 00dh	    ;fafa 67bb	0d  .
    defb 003h	    ;fafb 67bc	03  .
    defb 047h	    ;fafc 67bd	47  G 150
    defb 04fh	    ;fafd 67be	4f  O 151
    defb 04ch	    ;fafe 67bf	4c  L
    defb 041h	    ;faff 67c0	41  A
    defb 000h	    ;fb00 67c1	00  .
    defb 000h	    ;fb01 67c2	00  .
    defb 000h	    ;fb02 67c3	00  .
    defb 000h	    ;fb03 67c4	00  .
    defb 00dh	    ;fb04 67c5	0d  .
    defb 004h	    ;fb05 67c6	04  .
    defb 030h	    ;fb06 67c7	30  0
    defb 031h	    ;fb07 67c8	31  1
    defb 047h	    ;fb08 67c9	47  G
    defb 04fh	    ;fb09 67ca	4f  O
    defb 04ch	    ;fb0a 67cb	4c  L
    defb 041h	    ;fb0b 67cc	41  A
    defb 000h	    ;fb0c 67cd	00  .
    defb 000h	    ;fb0d 67ce	00  .
    defb 000h	    ;fb0e 67cf	00  .
    defb 000h	    ;fb0f 67d0	00  .
    defb 00dh	    ;fb10 67d1	0d  .
    defb 006h	    ;fb11 67d2	06  .
    defb 04eh	    ;fb12 67d3	4e  N
    defb 049h	    ;fb13 67d4	49  I
    defb 053h	    ;fb14 67d5	53  S
    defb 000h	    ;fb15 67d6	00  .
    defb 000h	    ;fb16 67d7	00  .
    defb 000h	    ;fb17 67d8	00  .
    defb 000h	    ;fb18 67d9	00  .
    defb 00dh	    ;fb19 67da	0d  .
    defb 003h	    ;fb1a 67db	03  .
    defb 053h	    ;fb1b 67dc	53  S
    defb 04fh	    ;fb1c 67dd	4f  O
    defb 043h	    ;fb1d 67de	43  C
    defb 000h	    ;fb1e 67df	00  .
    defb 000h	    ;fb1f 67e0	00  .
    defb 000h	    ;fb20 67e1	00  .
    defb 000h	    ;fb21 67e2	00  .
    defb 00dh	    ;fb22 67e3	0d  .
    defb 003h	    ;fb23 67e4	03  .
    defb 048h	    ;fb24 67e5	48  H
    defb 04eh	    ;fb25 67e6	4e  N
    defb 041h	    ;fb26 67e7	41  A
    defb 054h	    ;fb27 67e8	54  T
    defb 000h	    ;fb28 67e9	00  .
    defb 000h	    ;fb29 67ea	00  .
    defb 000h	    ;fb2a 67eb	00  .
    defb 000h	    ;fb2b 67ec	00  .
    defb 00dh	    ;fb2c 67ed	0d  .
    defb 004h	    ;fb2d 67ee	04  .
    defb 054h	    ;fb2e 67ef	54  T 200
    defb 052h	    ;fb2f 67f0	52  R 201
    defb 051h	    ;fb30 67f1	51  Q
    defb 053h	    ;fb31 67f2	53  S
    defb 000h	    ;fb32 67f3	00  .
    defb 000h	    ;fb33 67f4	00  .
    defb 000h	    ;fb34 67f5	00  .
    defb 000h	    ;fb35 67f6	00  .
    defb 00dh	    ;fb36 67f7	0d  .
    defb 004h	    ;fb37 67f8	04  .
    defb 04eh	    ;fb38 67f9	4e  N
    defb 041h	    ;fb39 67fa	41  A
    defb 054h	    ;fb3a 67fb	54  T
    defb 041h	    ;fb3b 67fc	41  A
    defb 000h	    ;fb3c 67fd	00  .
    defb 000h	    ;fb3d 67fe	00  .
    defb 000h	    ;fb3e 67ff	00  .
    defb 000h	    ;fb3f 6800	00  .
    defb 00dh	    ;fb40 6801	0d  .
    defb 004h	    ;fb41 6802	04  .
    defb 032h	    ;fb42 6803	32  2
    defb 04eh	    ;fb43 6804	4e  N
    defb 041h	    ;fb44 6805	41  A
    defb 054h	    ;fb45 6806	54  T
    defb 041h	    ;fb46 6807	41  A
    defb 000h	    ;fb47 6808	00  .
    defb 000h	    ;fb48 6809	00  .
    defb 000h	    ;fb49 680a	00  .
    defb 000h	    ;fb4a 680b	00  .
    defb 00dh	    ;fb4b 680c	0d  .
    defb 005h	    ;fb4c 680d	05  .
    defb 04bh	    ;fb4d 680e	4b  K
    defb 045h	    ;fb4e 680f	45  E
    defb 045h	    ;fb4f 6810	45  E
    defb 050h	    ;fb50 6811	50  P
    defb 000h	    ;fb51 6812	00  .
    defb 000h	    ;fb52 6813	00  .
    defb 000h	    ;fb53 6814	00  .
    defb 000h	    ;fb54 6815	00  .
    defb 015h	    ;fb55 6816	15  .
    defb 004h	    ;fb56 6817	04  .
    defb 050h	    ;fb57 6818	50  P
    defb 04eh	    ;fb58 6819	4e  N
    defb 049h	    ;fb59 681a	49  I
    defb 000h	    ;fb5a 681b	00  .
    defb 000h	    ;fb5b 681c	00  .
    defb 000h	    ;fb5c 681d	00  .
    defb 000h	    ;fb5d 681e	00  .
    defb 015h	    ;fb5e 681f	15  .
    defb 003h	    ;fb5f 6820	03  .
    defb 053h	    ;fb60 6821	53  S 250
    defb 042h	    ;fb61 6822	42  B 251
    defb 041h	    ;fb62 6823	41  A
    defb 044h	    ;fb63 6824	44  D
    defb 000h	    ;fb64 6825	00  .
    defb 000h	    ;fb65 6826	00  .
    defb 000h	    ;fb66 6827	00  .
    defb 000h	    ;fb67 6828	00  .
    defb 01dh	    ;fb68 6829	1d  .
    defb 004h	    ;fb69 682a	04  .
    defb 04eh	    ;fb6a 682b	4e  N
    defb 047h	    ;fb6b 682c	47  G
    defb 049h	    ;fb6c 682d	49  I
    defb 053h	    ;fb6d 682e	53  S
    defb 044h	    ;fb6e 682f	44  D
    defb 000h	    ;fb6f 6830	00  .
    defb 000h	    ;fb70 6831	00  .
    defb 000h	    ;fb71 6832	00  .
    defb 000h	    ;fb72 6833	00  .
    defb 01dh	    ;fb73 6834	1d  .
    defb 005h	    ;fb74 6835	05  .
    defb 045h	    ;fb75 6836	45  E
    defb 04ch	    ;fb76 6837	4c  L
    defb 042h	    ;fb77 6838	42  B
    defb 044h	    ;fb78 6839	44  D
    defb 000h	    ;fb79 683a	00  .
    defb 000h	    ;fb7a 683b	00  .
    defb 000h	    ;fb7b 683c	00  .
    defb 000h	    ;fb7c 683d	00  .
    defb 01dh	    ;fb7d 683e	1d  .
    defb 004h	    ;fb7e 683f	04  .
    defb 050h	    ;fb7f 6840	50  P
    defb 058h	    ;fb80 6841	58  X
    defb 045h	    ;fb81 6842	45  E
    defb 044h	    ;fb82 6843	44  D
    defb 000h	    ;fb83 6844	00  .
    defb 000h	    ;fb84 6845	00  .
    defb 000h	    ;fb85 6846	00  .
    defb 000h	    ;fb86 6847	00  .
    defb 01dh	    ;fb87 6848	1d  .
    defb 004h	    ;fb88 6849	04  .
    defb 047h	    ;fb89 684a	47  G
    defb 04fh	    ;fb8a 684b	4f  O
    defb 04ch	    ;fb8b 684c	4c  L
    defb 044h	    ;fb8c 684d	44  D
    defb 000h	    ;fb8d 684e	00  .
    defb 000h	    ;fb8e 684f	00  .
    defb 000h	    ;fb8f 6850	00  .
    defb 000h	    ;fb90 6851	00  .
    defb 01dh	    ;fb91 6852	1d  .
    defb 004h	    ;fb92 6853	04  . 300
    defb 030h	    ;fb93 6854	30  0 301
    defb 031h	    ;fb94 6855	31  1
    defb 047h	    ;fb95 6856	47  G
    defb 04fh	    ;fb96 6857	4f  O
    defb 04ch	    ;fb97 6858	4c  L
    defb 044h	    ;fb98 6859	44  D
    defb 000h	    ;fb99 685a	00  .
    defb 000h	    ;fb9a 685b	00  .
    defb 000h	    ;fb9b 685c	00  .
    defb 000h	    ;fb9c 685d	00  .
    defb 01dh	    ;fb9d 685e	1d  .
    defb 006h	    ;fb9e 685f	06  .
    defb 04eh	    ;fb9f 6860	4e  N
    defb 049h	    ;fba0 6861	49  I
    defb 053h	    ;fba1 6862	53  S
    defb 044h	    ;fba2 6863	44  D
    defb 000h	    ;fba3 6864	00  .
    defb 000h	    ;fba4 6865	00  .
    defb 000h	    ;fba5 6866	00  .
    defb 000h	    ;fba6 6867	00  .
    defb 01dh	    ;fba7 6868	1d  .
    defb 004h	    ;fba8 6869	04  .
    defb 053h	    ;fba9 686a	53  S
    defb 04fh	    ;fbaa 686b	4f  O
    defb 043h	    ;fbab 686c	43  C
    defb 044h	    ;fbac 686d	44  D
    defb 000h	    ;fbad 686e	00  .
    defb 000h	    ;fbae 686f	00  .
    defb 000h	    ;fbaf 6870	00  .
    defb 000h	    ;fbb0 6871	00  .
    defb 01dh	    ;fbb1 6872	1d  .
    defb 004h	    ;fbb2 6873	04  .
    defb 054h	    ;fbb3 6874	54  T
    defb 052h	    ;fbb4 6875	52  R
    defb 051h	    ;fbb5 6876	51  Q
    defb 053h	    ;fbb6 6877	53  S
    defb 044h	    ;fbb7 6878	44  D
    defb 000h	    ;fbb8 6879	00  .
    defb 000h	    ;fbb9 687a	00  .
    defb 000h	    ;fbba 687b	00  .
    defb 000h	    ;fbbb 687c	00  .
    defb 01dh	    ;fbbc 687d	1d  .
    defb 005h	    ;fbbd 687e	05  .
    defb 04eh	    ;fbbe 687f	4e  N
    defb 041h	    ;fbbf 6880	41  A
    defb 054h	    ;fbc0 6881	54  T
    defb 041h	    ;fbc1 6882	41  A
    defb 044h	    ;fbc2 6883	44  D
    defb 000h	    ;fbc3 6884	00  .
    defb 000h	    ;fbc4 6885	00  . 350
    defb 000h	    ;fbc5 6886	00  . 351
    defb 000h	    ;fbc6 6887	00  .
    defb 01dh	    ;fbc7 6888	1d  .
    defb 005h	    ;fbc8 6889	05  .
    defb 032h	    ;fbc9 688a	32  2
    defb 04eh	    ;fbca 688b	4e  N
    defb 041h	    ;fbcb 688c	41  A
    defb 054h	    ;fbcc 688d	54  T
    defb 041h	    ;fbcd 688e	41  A
    defb 044h	    ;fbce 688f	44  D
    defb 000h	    ;fbcf 6890	00  .
    defb 000h	    ;fbd0 6891	00  .
    defb 000h	    ;fbd1 6892	00  .
    defb 000h	    ;fbd2 6893	00  .
    defb 01dh	    ;fbd3 6894	1d  .
    defb 006h	    ;fbd4 6895	06  .
    defb 044h	    ;fbd5 6896	44  D
    defb 04fh	    ;fbd6 6897	4f  O
    defb 04dh	    ;fbd7 6898	4d  M
    defb 044h	    ;fbd8 6899	44  D
    defb 000h	    ;fbd9 689a	00  .
    defb 000h	    ;fbda 689b	00  .
    defb 000h	    ;fbdb 689c	00  .
    defb 000h	    ;fbdc 689d	00  .
    defb 01dh	    ;fbdd 689e	1d  .
    defb 004h	    ;fbde 689f	04  .
    defb 030h	    ;fbdf 68a0	30  0
    defb 049h	    ;fbe0 68a1	49  I
    defb 024h	    ;fbe1 68a2	24  $
    defb 000h	    ;fbe2 68a3	00  .
    defb 000h	    ;fbe3 68a4	00  .
    defb 000h	    ;fbe4 68a5	00  .
    defb 000h	    ;fbe5 68a6	00  .
    defb 00dh	    ;fbe6 68a7	0d  . (l01c4h)
    defb 003h	    ;fbe7 68a8	03  .
    defb 031h	    ;fbe8 68a9	31  1
    defb 049h	    ;fbe9 68aa	49  I
    defb 024h	    ;fbea 68ab	24  $
    defb 000h	    ;fbeb 68ac	00  .
    defb 000h	    ;fbec 68ad	00  .
    defb 000h	    ;fbed 68ae	00  .
    defb 000h	    ;fbee 68af	00  .
    defb 00dh	    ;fbef 68b0	0d  .
    defb 003h	    ;fbf0 68b1	03  .
    defb 032h	    ;fbf1 68b2	32  2
    defb 049h	    ;fbf2 68b3	49  I
    defb 024h	    ;fbf3 68b4	24  $
    defb 000h	    ;fbf4 68b5	00  .
    defb 000h	    ;fbf5 68b6	00  .
    defb 000h	    ;fbf6 68b7	00  . 400
    defb 000h	    ;fbf7 68b8	00  . 401
    defb 00dh	    ;fbf8 68b9	0d  .
    defb 003h	    ;fbf9 68ba	03  .
    defb 034h	    ;fbfa 68bb	34  4
    defb 049h	    ;fbfb 68bc	49  I
    defb 024h	    ;fbfc 68bd	24  $
    defb 000h	    ;fbfd 68be	00  .
    defb 000h	    ;fbfe 68bf	00  .
    defb 000h	    ;fbff 68c0	00  .
    defb 000h	    ;fc00 68c1	00  .
    defb 00dh	    ;fc01 68c2	0d  .
    defb 003h	    ;fc02 68c3	03  .
    defb 033h	    ;fc03 68c4	33  3
    defb 049h	    ;fc04 68c5	49  I
    defb 024h	    ;fc05 68c6	24  $
    defb 000h	    ;fc06 68c7	00  .
    defb 000h	    ;fc07 68c8	00  .
    defb 000h	    ;fc08 68c9	00  .
    defb 000h	    ;fc09 68ca	00  .
    defb 00dh	    ;fc0a 68cb	0d  .
    defb 003h	    ;fc0b 68cc	03  .
    defb 031h	    ;fc0c 68cd	31  1
    defb 058h	    ;fc0d 68ce	58  X
    defb 041h	    ;fc0e 68cf	41  A
    defb 04dh	    ;fc0f 68d0	4d  M
    defb 044h	    ;fc10 68d1	44  D
    defb 000h	    ;fc11 68d2	00  .
    defb 000h	    ;fc12 68d3	00  .
    defb 000h	    ;fc13 68d4	00  .
    defb 000h	    ;fc14 68d5	00  .
    defb 01dh	    ;fc15 68d6	1d  .
    defb 005h	    ;fc16 68d7	05  .
    defb 031h	    ;fc17 68d8	31  1
    defb 04eh	    ;fc18 68d9	4e  N
    defb 049h	    ;fc19 68da	49  I
    defb 04dh	    ;fc1a 68db	4d  M
    defb 044h	    ;fc1b 68dc	44  D
    defb 000h	    ;fc1c 68dd	00  .
    defb 000h	    ;fc1d 68de	00  .
    defb 000h	    ;fc1e 68df	00  .
    defb 000h	    ;fc1f 68e0	00  .
    defb 01dh	    ;fc20 68e1	1d  .
    defb 005h	    ;fc21 68e2	05  .
    defb 030h	    ;fc22 68e3	30  0
    defb 04eh	    ;fc23 68e4	4e  N
    defb 049h	    ;fc24 68e5	49  I
    defb 04dh	    ;fc25 68e6	4d  M
    defb 041h	    ;fc26 68e7	41  A
    defb 000h	    ;fc27 68e8	00  .
    defb 000h	    ;fc28 68e9	00  . 450
    defb 000h	    ;fc29 68ea	00  . 451
    defb 000h	    ;fc2a 68eb	00  .
    defb 00dh	    ;fc2b 68ec	0d  .
    defb 005h	    ;fc2c 68ed	05  .
    defb 031h	    ;fc2d 68ee	31  1
    defb 04eh	    ;fc2e 68ef	4e  N
    defb 049h	    ;fc2f 68f0	49  I
    defb 04dh	    ;fc30 68f1	4d  M
    defb 041h	    ;fc31 68f2	41  A
    defb 000h	    ;fc32 68f3	00  .
    defb 000h	    ;fc33 68f4	00  .
    defb 000h	    ;fc34 68f5	00  .
    defb 000h	    ;fc35 68f6	00  .
    defb 00dh	    ;fc36 68f7	0d  .
    defb 005h	    ;fc37 68f8	05  .
    defb 030h	    ;fc38 68f9	30  0
    defb 04eh	    ;fc39 68fa	4e  N
    defb 049h	    ;fc3a 68fb	49  I
    defb 04dh	    ;fc3b 68fc	4d  M
    defb 000h	    ;fc3c 68fd	00  .
    defb 000h	    ;fc3d 68fe	00  .
    defb 000h	    ;fc3e 68ff	00  .
    defb 000h	    ;fc3f 6900	00  .
    defb 005h	    ;fc40 6901	05  .
    defb 004h	    ;fc41 6902	04  .
    defb 031h	    ;fc42 6903	31  1
    defb 04eh	    ;fc43 6904	4e  N
    defb 049h	    ;fc44 6905	49  I
    defb 04dh	    ;fc45 6906	4d  M
    defb 000h	    ;fc46 6907	00  .
    defb 000h	    ;fc47 6908	00  .
    defb 000h	    ;fc48 6909	00  .
    defb 000h	    ;fc49 690a	00  .
    defb 005h	    ;fc4a 690b	05  .
    defb 004h	    ;fc4b 690c	04  .
    defb 031h	    ;fc4c 690d	31  1
    defb 058h	    ;fc4d 690e	58  X
    defb 041h	    ;fc4e 690f	41  A
    defb 04dh	    ;fc4f 6910	4d  M
    defb 000h	    ;fc50 6911	00  .
    defb 000h	    ;fc51 6912	00  .
    defb 000h	    ;fc52 6913	00  .
    defb 000h	    ;fc53 6914	00  .
    defb 005h	    ;fc54 6915	05  .
    defb 004h	    ;fc55 6916	04  .
    defb 030h	    ;fc56 6917	30  0
    defb 058h	    ;fc57 6918	58  X
    defb 041h	    ;fc58 6919	41  A
    defb 04dh	    ;fc59 691a	4d  M
    defb 000h	    ;fc5a 691b	00  . 500
    defb 000h	    ;fc5b 691c	00  . 501
    defb 000h	    ;fc5c 691d	00  . 502
    defb 000h	    ;fc5d 691e	00  . 503
    defb 005h	    ;fc5e 691f	05  . 504.
    defb 004h	    ;fc5f 6920	04  . 505
    defb 031h	    ;fc60 6921	31  1 506
    defb 058h	    ;fc61 6922	58  X 507
    defb 041h	    ;fc62 6923	41  A 508
    defb 04dh	    ;fc63 6924	4d  M 509
    defb 041h	    ;fc64 6925	41  A 510
    defb 000h	    ;fc65 6926	00  . 511
    defb 000h	    ;fc66 6927	00  . 512
    defb 000h	    ;fc67 6928	00  . 513
    defb 000h	    ;fc68 6929	00  . 514
    defb 00dh	    ;fc69 692a	0d  . 515.
    defb 005h	    ;fc6a 692b	05  . 516
    defb 030h	    ;fc6b 692c	30  0 517
    defb 058h	    ;fc6c 692d	58  X 518
    defb 041h	    ;fc6d 692e	41  A 519
    defb 04dh	    ;fc6e 692f	4d  M 520
    defb 041h	    ;fc6f 6930	41  A 521
    defb 000h	    ;fc70 6931	00  . 522
    defb 000h	    ;fc71 6932	00  . 523
    defb 000h	    ;fc72 6933	00  . 524
    defb 000h	    ;fc73 6934	00  . 525
    defb 00dh	    ;fc74 6935	0d  . 526.
    defb 005h	    ;fc75 6936	05  . 527

    end
*

